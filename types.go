// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/flagright/flagright-go/internal"
)

// Model for ACH payment method
type AchDetails struct {
	// Routing number of the bank
	RoutingNumber *string `json:"routingNumber,omitempty" url:"routingNumber,omitempty"`
	// Bank account number of the individual
	AccountNumber  *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	AccountBalance *Amount `json:"accountBalance,omitempty" url:"accountBalance,omitempty"`
	// Name of the bank
	BankName *string `json:"bankName,omitempty" url:"bankName,omitempty"`
	// Name of the account holder
	Name        *string  `json:"name,omitempty" url:"name,omitempty"`
	BankAddress *Address `json:"bankAddress,omitempty" url:"bankAddress,omitempty"`
	// Beneficiary name of the account
	BeneficiaryName *string  `json:"beneficiaryName,omitempty" url:"beneficiaryName,omitempty"`
	EmailId         *EmailId `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchDetails) GetRoutingNumber() *string {
	if a == nil {
		return nil
	}
	return a.RoutingNumber
}

func (a *AchDetails) GetAccountNumber() *string {
	if a == nil {
		return nil
	}
	return a.AccountNumber
}

func (a *AchDetails) GetAccountBalance() *Amount {
	if a == nil {
		return nil
	}
	return a.AccountBalance
}

func (a *AchDetails) GetBankName() *string {
	if a == nil {
		return nil
	}
	return a.BankName
}

func (a *AchDetails) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AchDetails) GetBankAddress() *Address {
	if a == nil {
		return nil
	}
	return a.BankAddress
}

func (a *AchDetails) GetBeneficiaryName() *string {
	if a == nil {
		return nil
	}
	return a.BeneficiaryName
}

func (a *AchDetails) GetEmailId() *EmailId {
	if a == nil {
		return nil
	}
	return a.EmailId
}

func (a *AchDetails) GetTags() []*Tag {
	if a == nil {
		return nil
	}
	return a.Tags
}

func (a *AchDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AchDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchDetails) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Classify the method of payment as "ACH" for ACHDetails
type AchPaymentMethod = string

// Model for User acquisition channel
type AcquisitionChannel string

const (
	AcquisitionChannelOrganic   AcquisitionChannel = "ORGANIC"
	AcquisitionChannelPaid      AcquisitionChannel = "PAID"
	AcquisitionChannelReferral  AcquisitionChannel = "REFERRAL"
	AcquisitionChannelOffline   AcquisitionChannel = "OFFLINE"
	AcquisitionChannelGathering AcquisitionChannel = "GATHERING"
	AcquisitionChannelUnknown   AcquisitionChannel = "UNKNOWN"
)

func NewAcquisitionChannelFromString(s string) (AcquisitionChannel, error) {
	switch s {
	case "ORGANIC":
		return AcquisitionChannelOrganic, nil
	case "PAID":
		return AcquisitionChannelPaid, nil
	case "REFERRAL":
		return AcquisitionChannelReferral, nil
	case "OFFLINE":
		return AcquisitionChannelOffline, nil
	case "GATHERING":
		return AcquisitionChannelGathering, nil
	case "UNKNOWN":
		return AcquisitionChannelUnknown, nil
	}
	var t AcquisitionChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcquisitionChannel) Ptr() *AcquisitionChannel {
	return &a
}

// Model for standardized address
type Address struct {
	// Address lines of the user's residence address
	AddressLines []string `json:"addressLines,omitempty" url:"addressLines,omitempty"`
	// Post code of the user's residence address
	Postcode *string `json:"postcode,omitempty" url:"postcode,omitempty"`
	// City of the user's residence address
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// State of the user's residence address
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// User's country of residence
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// Type of the address (ex - Residential, Postal, etc.)
	AddressType *string `json:"addressType,omitempty" url:"addressType,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Address) GetAddressLines() []string {
	if a == nil {
		return nil
	}
	return a.AddressLines
}

func (a *Address) GetPostcode() *string {
	if a == nil {
		return nil
	}
	return a.Postcode
}

func (a *Address) GetCity() *string {
	if a == nil {
		return nil
	}
	return a.City
}

func (a *Address) GetState() *string {
	if a == nil {
		return nil
	}
	return a.State
}

func (a *Address) GetCountry() *string {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *Address) GetAddressType() *string {
	if a == nil {
		return nil
	}
	return a.AddressType
}

func (a *Address) GetTags() []*Tag {
	if a == nil {
		return nil
	}
	return a.Tags
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AdverseMediaStatus = bool

type AlertClosedDetails struct {
	AlertId                   *string  `json:"alertId,omitempty" url:"alertId,omitempty"`
	Status                    *string  `json:"status,omitempty" url:"status,omitempty"`
	Reasons                   []string `json:"reasons,omitempty" url:"reasons,omitempty"`
	ReasonDescriptionForOther *string  `json:"reasonDescriptionForOther,omitempty" url:"reasonDescriptionForOther,omitempty"`
	Comment                   *string  `json:"comment,omitempty" url:"comment,omitempty"`
	UserId                    *string  `json:"userId,omitempty" url:"userId,omitempty"`
	TransactionIds            []string `json:"transactionIds,omitempty" url:"transactionIds,omitempty"`
	RuleName                  *string  `json:"ruleName,omitempty" url:"ruleName,omitempty"`
	RuleDescription           *string  `json:"ruleDescription,omitempty" url:"ruleDescription,omitempty"`
	RuleId                    *string  `json:"ruleId,omitempty" url:"ruleId,omitempty"`
	RuleInstanceId            *string  `json:"ruleInstanceId,omitempty" url:"ruleInstanceId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AlertClosedDetails) GetAlertId() *string {
	if a == nil {
		return nil
	}
	return a.AlertId
}

func (a *AlertClosedDetails) GetStatus() *string {
	if a == nil {
		return nil
	}
	return a.Status
}

func (a *AlertClosedDetails) GetReasons() []string {
	if a == nil {
		return nil
	}
	return a.Reasons
}

func (a *AlertClosedDetails) GetReasonDescriptionForOther() *string {
	if a == nil {
		return nil
	}
	return a.ReasonDescriptionForOther
}

func (a *AlertClosedDetails) GetComment() *string {
	if a == nil {
		return nil
	}
	return a.Comment
}

func (a *AlertClosedDetails) GetUserId() *string {
	if a == nil {
		return nil
	}
	return a.UserId
}

func (a *AlertClosedDetails) GetTransactionIds() []string {
	if a == nil {
		return nil
	}
	return a.TransactionIds
}

func (a *AlertClosedDetails) GetRuleName() *string {
	if a == nil {
		return nil
	}
	return a.RuleName
}

func (a *AlertClosedDetails) GetRuleDescription() *string {
	if a == nil {
		return nil
	}
	return a.RuleDescription
}

func (a *AlertClosedDetails) GetRuleId() *string {
	if a == nil {
		return nil
	}
	return a.RuleId
}

func (a *AlertClosedDetails) GetRuleInstanceId() *string {
	if a == nil {
		return nil
	}
	return a.RuleInstanceId
}

func (a *AlertClosedDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlertClosedDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AlertClosedDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlertClosedDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AlertClosedDetails) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AlertOpenedDetails struct {
	AlertId         *string  `json:"alertId,omitempty" url:"alertId,omitempty"`
	Status          *string  `json:"status,omitempty" url:"status,omitempty"`
	TransactionIds  []string `json:"transactionIds,omitempty" url:"transactionIds,omitempty"`
	RuleName        *string  `json:"ruleName,omitempty" url:"ruleName,omitempty"`
	RuleDescription *string  `json:"ruleDescription,omitempty" url:"ruleDescription,omitempty"`
	RuleId          *string  `json:"ruleId,omitempty" url:"ruleId,omitempty"`
	RuleInstanceId  *string  `json:"ruleInstanceId,omitempty" url:"ruleInstanceId,omitempty"`
	CaseId          *string  `json:"caseId,omitempty" url:"caseId,omitempty"`
	UserId          *string  `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AlertOpenedDetails) GetAlertId() *string {
	if a == nil {
		return nil
	}
	return a.AlertId
}

func (a *AlertOpenedDetails) GetStatus() *string {
	if a == nil {
		return nil
	}
	return a.Status
}

func (a *AlertOpenedDetails) GetTransactionIds() []string {
	if a == nil {
		return nil
	}
	return a.TransactionIds
}

func (a *AlertOpenedDetails) GetRuleName() *string {
	if a == nil {
		return nil
	}
	return a.RuleName
}

func (a *AlertOpenedDetails) GetRuleDescription() *string {
	if a == nil {
		return nil
	}
	return a.RuleDescription
}

func (a *AlertOpenedDetails) GetRuleId() *string {
	if a == nil {
		return nil
	}
	return a.RuleId
}

func (a *AlertOpenedDetails) GetRuleInstanceId() *string {
	if a == nil {
		return nil
	}
	return a.RuleInstanceId
}

func (a *AlertOpenedDetails) GetCaseId() *string {
	if a == nil {
		return nil
	}
	return a.CaseId
}

func (a *AlertOpenedDetails) GetUserId() *string {
	if a == nil {
		return nil
	}
	return a.UserId
}

func (a *AlertOpenedDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlertOpenedDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AlertOpenedDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlertOpenedDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AlertOpenedDetails) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Model for amount
type Amount struct {
	// Numerical value of the transaction
	AmountValue    float64      `json:"amountValue" url:"amountValue"`
	AmountCurrency CurrencyCode `json:"amountCurrency" url:"amountCurrency"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Amount) GetAmountValue() float64 {
	if a == nil {
		return 0
	}
	return a.AmountValue
}

func (a *Amount) GetAmountCurrency() CurrencyCode {
	if a == nil {
		return ""
	}
	return a.AmountCurrency
}

func (a *Amount) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Amount) UnmarshalJSON(data []byte) error {
	type unmarshaler Amount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Amount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Amount) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiErrorResponse struct {
	Message          string  `json:"message" url:"message"`
	ValidationErrors *string `json:"validationErrors,omitempty" url:"validationErrors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApiErrorResponse) GetMessage() string {
	if a == nil {
		return ""
	}
	return a.Message
}

func (a *ApiErrorResponse) GetValidationErrors() *string {
	if a == nil {
		return nil
	}
	return a.ValidationErrors
}

func (a *ApiErrorResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiErrorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiErrorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiErrorResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiErrorResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BatchBusinessUserWithRulesResult struct {
	// Unique user ID for the user
	UserId string `json:"userId" url:"userId"`
	// Timestamp when the user was created
	CreatedTimestamp float64      `json:"createdTimestamp" url:"createdTimestamp"`
	LegalEntity      *LegalEntity `json:"legalEntity,omitempty" url:"legalEntity,omitempty"`
	// Timestamp when the user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	// Shareholders (beneficiaries) of the company that hold at least 25% ownership. Can be another company or an individual
	ShareHolders []*Person `json:"shareHolders,omitempty" url:"shareHolders,omitempty"`
	// Director(s) of the company. Must be at least one
	Directors             []*Person          `json:"directors,omitempty" url:"directors,omitempty"`
	TransactionLimits     *TransactionLimits `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	RiskLevel             *RiskLevel         `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel          *RiskLevel         `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AllowedPaymentMethods []PaymentMethod    `json:"allowedPaymentMethods,omitempty" url:"allowedPaymentMethods,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                                                   `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                                            `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	AcquisitionChannel       *AcquisitionChannel                                        `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	SavedPaymentDetails      []*BatchBusinessUserWithRulesResultSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	MccDetails               *MccDetails                                                `json:"mccDetails,omitempty" url:"mccDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// User's attachments uploaded by business user
	Attachments      []*PersonAttachment    `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount      *float64               `json:"updateCount,omitempty" url:"updateCount,omitempty"`
	ExecutedRules    []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	RiskScoreDetails *UserRiskScoreDetails  `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchBusinessUserWithRulesResult) GetUserId() string {
	if b == nil {
		return ""
	}
	return b.UserId
}

func (b *BatchBusinessUserWithRulesResult) GetCreatedTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.CreatedTimestamp
}

func (b *BatchBusinessUserWithRulesResult) GetLegalEntity() *LegalEntity {
	if b == nil {
		return nil
	}
	return b.LegalEntity
}

func (b *BatchBusinessUserWithRulesResult) GetActivatedTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.ActivatedTimestamp
}

func (b *BatchBusinessUserWithRulesResult) GetUserStateDetails() *UserStateDetails {
	if b == nil {
		return nil
	}
	return b.UserStateDetails
}

func (b *BatchBusinessUserWithRulesResult) GetKycStatusDetails() *KycStatusDetails {
	if b == nil {
		return nil
	}
	return b.KycStatusDetails
}

func (b *BatchBusinessUserWithRulesResult) GetShareHolders() []*Person {
	if b == nil {
		return nil
	}
	return b.ShareHolders
}

func (b *BatchBusinessUserWithRulesResult) GetDirectors() []*Person {
	if b == nil {
		return nil
	}
	return b.Directors
}

func (b *BatchBusinessUserWithRulesResult) GetTransactionLimits() *TransactionLimits {
	if b == nil {
		return nil
	}
	return b.TransactionLimits
}

func (b *BatchBusinessUserWithRulesResult) GetRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.RiskLevel
}

func (b *BatchBusinessUserWithRulesResult) GetKycRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.KycRiskLevel
}

func (b *BatchBusinessUserWithRulesResult) GetAllowedPaymentMethods() []PaymentMethod {
	if b == nil {
		return nil
	}
	return b.AllowedPaymentMethods
}

func (b *BatchBusinessUserWithRulesResult) GetLastTransactionTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.LastTransactionTimestamp
}

func (b *BatchBusinessUserWithRulesResult) GetLinkedEntities() *UserEntityLink {
	if b == nil {
		return nil
	}
	return b.LinkedEntities
}

func (b *BatchBusinessUserWithRulesResult) GetAcquisitionChannel() *AcquisitionChannel {
	if b == nil {
		return nil
	}
	return b.AcquisitionChannel
}

func (b *BatchBusinessUserWithRulesResult) GetSavedPaymentDetails() []*BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	if b == nil {
		return nil
	}
	return b.SavedPaymentDetails
}

func (b *BatchBusinessUserWithRulesResult) GetMccDetails() *MccDetails {
	if b == nil {
		return nil
	}
	return b.MccDetails
}

func (b *BatchBusinessUserWithRulesResult) GetTags() []*UserTag {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BatchBusinessUserWithRulesResult) GetAttachments() []*PersonAttachment {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *BatchBusinessUserWithRulesResult) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *BatchBusinessUserWithRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if b == nil {
		return nil
	}
	return b.ExecutedRules
}

func (b *BatchBusinessUserWithRulesResult) GetRiskScoreDetails() *UserRiskScoreDetails {
	if b == nil {
		return nil
	}
	return b.RiskScoreDetails
}

func (b *BatchBusinessUserWithRulesResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchBusinessUserWithRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchBusinessUserWithRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchBusinessUserWithRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchBusinessUserWithRulesResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchBusinessUserWithRulesResultSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromCard(value *CardDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromIban(value *IbanDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromAch(value *AchDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromUpi(value *UpiDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromWallet(value *WalletDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromCheck(value *CheckDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromCash(value *CashDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewBatchBusinessUserWithRulesResultSavedPaymentDetailsItemFromNpp(value *NppDetails) *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchBusinessUserWithRulesResultSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetMethod() string {
	if b == nil {
		return ""
	}
	return b.Method
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetCard() *CardDetails {
	if b == nil {
		return nil
	}
	return b.Card
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if b == nil {
		return nil
	}
	return b.GenericBankAccount
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if b == nil {
		return nil
	}
	return b.Iban
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetAch() *AchDetails {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if b == nil {
		return nil
	}
	return b.Swift
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if b == nil {
		return nil
	}
	return b.Mpesa
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if b == nil {
		return nil
	}
	return b.Upi
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if b == nil {
		return nil
	}
	return b.Wallet
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if b == nil {
		return nil
	}
	return b.Check
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetCash() *CashDetails {
	if b == nil {
		return nil
	}
	return b.Cash
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if b == nil {
		return nil
	}
	return b.Npp
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", b)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Npp = value
	}
	return nil
}

func (b BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	switch b.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(b.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(b.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(b.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(b.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(b.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(b.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(b.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(b.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(b.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(b.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(b.Npp, "method", "NPP")
	}
}

type BatchBusinessUserWithRulesResultSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) Accept(visitor BatchBusinessUserWithRulesResultSavedPaymentDetailsItemVisitor) error {
	switch b.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return visitor.VisitCard(b.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(b.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(b.Iban)
	case "ACH":
		return visitor.VisitAch(b.Ach)
	case "SWIFT":
		return visitor.VisitSwift(b.Swift)
	case "MPESA":
		return visitor.VisitMpesa(b.Mpesa)
	case "UPI":
		return visitor.VisitUpi(b.Upi)
	case "WALLET":
		return visitor.VisitWallet(b.Wallet)
	case "CHECK":
		return visitor.VisitCheck(b.Check)
	case "CASH":
		return visitor.VisitCash(b.Cash)
	case "NPP":
		return visitor.VisitNpp(b.Npp)
	}
}

func (b *BatchBusinessUserWithRulesResultSavedPaymentDetailsItem) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Card != nil {
		fields = append(fields, "CARD")
	}
	if b.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if b.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if b.Ach != nil {
		fields = append(fields, "ACH")
	}
	if b.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if b.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if b.Upi != nil {
		fields = append(fields, "UPI")
	}
	if b.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if b.Check != nil {
		fields = append(fields, "CHECK")
	}
	if b.Cash != nil {
		fields = append(fields, "CASH")
	}
	if b.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if b.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Method)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Method != "" {
		field := fields[0]
		if b.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Method,
				b,
			)
		}
	}
	return nil
}

type BatchBusinessUsersWithRulesResults struct {
	BusinessUsers []*BatchBusinessUserWithRulesResult `json:"businessUsers,omitempty" url:"businessUsers,omitempty"`
	TotalCount    float64                             `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchBusinessUsersWithRulesResults) GetBusinessUsers() []*BatchBusinessUserWithRulesResult {
	if b == nil {
		return nil
	}
	return b.BusinessUsers
}

func (b *BatchBusinessUsersWithRulesResults) GetTotalCount() float64 {
	if b == nil {
		return 0
	}
	return b.TotalCount
}

func (b *BatchBusinessUsersWithRulesResults) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchBusinessUsersWithRulesResults) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchBusinessUsersWithRulesResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchBusinessUsersWithRulesResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchBusinessUsersWithRulesResults) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchConsumerUserEventWithRulesResult struct {
	// Timestamp of the event
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// Transaction ID the event pertains to
	UserId string `json:"userId" url:"userId"`
	// Unique event ID
	EventId *string `json:"eventId,omitempty" url:"eventId,omitempty"`
	// Reason for the event or a state change
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// Event description
	EventDescription              *string                `json:"eventDescription,omitempty" url:"eventDescription,omitempty"`
	UpdatedConsumerUserAttributes *UserOptional          `json:"updatedConsumerUserAttributes,omitempty" url:"updatedConsumerUserAttributes,omitempty"`
	UpdateCount                   *float64               `json:"updateCount,omitempty" url:"updateCount,omitempty"`
	ExecutedRules                 []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	RiskScoreDetails              *UserRiskScoreDetails  `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchConsumerUserEventWithRulesResult) GetTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.Timestamp
}

func (b *BatchConsumerUserEventWithRulesResult) GetUserId() string {
	if b == nil {
		return ""
	}
	return b.UserId
}

func (b *BatchConsumerUserEventWithRulesResult) GetEventId() *string {
	if b == nil {
		return nil
	}
	return b.EventId
}

func (b *BatchConsumerUserEventWithRulesResult) GetReason() *string {
	if b == nil {
		return nil
	}
	return b.Reason
}

func (b *BatchConsumerUserEventWithRulesResult) GetEventDescription() *string {
	if b == nil {
		return nil
	}
	return b.EventDescription
}

func (b *BatchConsumerUserEventWithRulesResult) GetUpdatedConsumerUserAttributes() *UserOptional {
	if b == nil {
		return nil
	}
	return b.UpdatedConsumerUserAttributes
}

func (b *BatchConsumerUserEventWithRulesResult) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *BatchConsumerUserEventWithRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if b == nil {
		return nil
	}
	return b.ExecutedRules
}

func (b *BatchConsumerUserEventWithRulesResult) GetRiskScoreDetails() *UserRiskScoreDetails {
	if b == nil {
		return nil
	}
	return b.RiskScoreDetails
}

func (b *BatchConsumerUserEventWithRulesResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchConsumerUserEventWithRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchConsumerUserEventWithRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchConsumerUserEventWithRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchConsumerUserEventWithRulesResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchConsumerUserEventsRulesResult struct {
	ConsumerUserEvents []*BatchConsumerUserEventWithRulesResult `json:"consumerUserEvents,omitempty" url:"consumerUserEvents,omitempty"`
	TotalCount         float64                                  `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchConsumerUserEventsRulesResult) GetConsumerUserEvents() []*BatchConsumerUserEventWithRulesResult {
	if b == nil {
		return nil
	}
	return b.ConsumerUserEvents
}

func (b *BatchConsumerUserEventsRulesResult) GetTotalCount() float64 {
	if b == nil {
		return 0
	}
	return b.TotalCount
}

func (b *BatchConsumerUserEventsRulesResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchConsumerUserEventsRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchConsumerUserEventsRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchConsumerUserEventsRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchConsumerUserEventsRulesResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchConsumerUserWithRulesResult struct {
	// Unique user ID
	UserId string `json:"userId" url:"userId"`
	// Timestamp when userId is created
	CreatedTimestamp float64 `json:"createdTimestamp" url:"createdTimestamp"`
	// Timestamp when user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserDetails        *UserDetails      `json:"userDetails,omitempty" url:"userDetails,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	EoddDate           *float64          `json:"eoddDate,omitempty" url:"eoddDate,omitempty"`
	EmploymentStatus   *EmploymentStatus `json:"employmentStatus,omitempty" url:"employmentStatus,omitempty"`
	Occupation         *string           `json:"occupation,omitempty" url:"occupation,omitempty"`
	// User's legal identity documents - See Document Model for details
	LegalDocuments          []*LegalDocument     `json:"legalDocuments,omitempty" url:"legalDocuments,omitempty"`
	ContactDetails          *ContactDetails      `json:"contactDetails,omitempty" url:"contactDetails,omitempty"`
	EmploymentDetails       *EmploymentDetails   `json:"employmentDetails,omitempty" url:"employmentDetails,omitempty"`
	TransactionLimits       *TransactionLimits   `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	ExpectedIncome          *ExpectedIncome      `json:"expectedIncome,omitempty" url:"expectedIncome,omitempty"`
	RiskLevel               *RiskLevel           `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel            *RiskLevel           `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AcquisitionChannel      *AcquisitionChannel  `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	ReasonForAccountOpening []string             `json:"reasonForAccountOpening,omitempty" url:"reasonForAccountOpening,omitempty"`
	SourceOfFunds           []SourceOfFunds      `json:"sourceOfFunds,omitempty" url:"sourceOfFunds,omitempty"`
	UserSegment             *ConsumerUserSegment `json:"userSegment,omitempty" url:"userSegment,omitempty"`
	PepStatus               []*PepStatus         `json:"pepStatus,omitempty" url:"pepStatus,omitempty"`
	SanctionsStatus         *SanctionsStatus     `json:"sanctionsStatus,omitempty" url:"sanctionsStatus,omitempty"`
	AdverseMediaStatus      *AdverseMediaStatus  `json:"adverseMediaStatus,omitempty" url:"adverseMediaStatus,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                                                   `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                                            `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	SavedPaymentDetails      []*BatchConsumerUserWithRulesResultSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// Uploaded user's attachment
	Attachments      []*PersonAttachment    `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount      *float64               `json:"updateCount,omitempty" url:"updateCount,omitempty"`
	ExecutedRules    []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	RiskScoreDetails *UserRiskScoreDetails  `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchConsumerUserWithRulesResult) GetUserId() string {
	if b == nil {
		return ""
	}
	return b.UserId
}

func (b *BatchConsumerUserWithRulesResult) GetCreatedTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.CreatedTimestamp
}

func (b *BatchConsumerUserWithRulesResult) GetActivatedTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.ActivatedTimestamp
}

func (b *BatchConsumerUserWithRulesResult) GetUserDetails() *UserDetails {
	if b == nil {
		return nil
	}
	return b.UserDetails
}

func (b *BatchConsumerUserWithRulesResult) GetUserStateDetails() *UserStateDetails {
	if b == nil {
		return nil
	}
	return b.UserStateDetails
}

func (b *BatchConsumerUserWithRulesResult) GetKycStatusDetails() *KycStatusDetails {
	if b == nil {
		return nil
	}
	return b.KycStatusDetails
}

func (b *BatchConsumerUserWithRulesResult) GetEoddDate() *float64 {
	if b == nil {
		return nil
	}
	return b.EoddDate
}

func (b *BatchConsumerUserWithRulesResult) GetEmploymentStatus() *EmploymentStatus {
	if b == nil {
		return nil
	}
	return b.EmploymentStatus
}

func (b *BatchConsumerUserWithRulesResult) GetOccupation() *string {
	if b == nil {
		return nil
	}
	return b.Occupation
}

func (b *BatchConsumerUserWithRulesResult) GetLegalDocuments() []*LegalDocument {
	if b == nil {
		return nil
	}
	return b.LegalDocuments
}

func (b *BatchConsumerUserWithRulesResult) GetContactDetails() *ContactDetails {
	if b == nil {
		return nil
	}
	return b.ContactDetails
}

func (b *BatchConsumerUserWithRulesResult) GetEmploymentDetails() *EmploymentDetails {
	if b == nil {
		return nil
	}
	return b.EmploymentDetails
}

func (b *BatchConsumerUserWithRulesResult) GetTransactionLimits() *TransactionLimits {
	if b == nil {
		return nil
	}
	return b.TransactionLimits
}

func (b *BatchConsumerUserWithRulesResult) GetExpectedIncome() *ExpectedIncome {
	if b == nil {
		return nil
	}
	return b.ExpectedIncome
}

func (b *BatchConsumerUserWithRulesResult) GetRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.RiskLevel
}

func (b *BatchConsumerUserWithRulesResult) GetKycRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.KycRiskLevel
}

func (b *BatchConsumerUserWithRulesResult) GetAcquisitionChannel() *AcquisitionChannel {
	if b == nil {
		return nil
	}
	return b.AcquisitionChannel
}

func (b *BatchConsumerUserWithRulesResult) GetReasonForAccountOpening() []string {
	if b == nil {
		return nil
	}
	return b.ReasonForAccountOpening
}

func (b *BatchConsumerUserWithRulesResult) GetSourceOfFunds() []SourceOfFunds {
	if b == nil {
		return nil
	}
	return b.SourceOfFunds
}

func (b *BatchConsumerUserWithRulesResult) GetUserSegment() *ConsumerUserSegment {
	if b == nil {
		return nil
	}
	return b.UserSegment
}

func (b *BatchConsumerUserWithRulesResult) GetPepStatus() []*PepStatus {
	if b == nil {
		return nil
	}
	return b.PepStatus
}

func (b *BatchConsumerUserWithRulesResult) GetSanctionsStatus() *SanctionsStatus {
	if b == nil {
		return nil
	}
	return b.SanctionsStatus
}

func (b *BatchConsumerUserWithRulesResult) GetAdverseMediaStatus() *AdverseMediaStatus {
	if b == nil {
		return nil
	}
	return b.AdverseMediaStatus
}

func (b *BatchConsumerUserWithRulesResult) GetLastTransactionTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.LastTransactionTimestamp
}

func (b *BatchConsumerUserWithRulesResult) GetLinkedEntities() *UserEntityLink {
	if b == nil {
		return nil
	}
	return b.LinkedEntities
}

func (b *BatchConsumerUserWithRulesResult) GetSavedPaymentDetails() []*BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	if b == nil {
		return nil
	}
	return b.SavedPaymentDetails
}

func (b *BatchConsumerUserWithRulesResult) GetTags() []*UserTag {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BatchConsumerUserWithRulesResult) GetAttachments() []*PersonAttachment {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *BatchConsumerUserWithRulesResult) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *BatchConsumerUserWithRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if b == nil {
		return nil
	}
	return b.ExecutedRules
}

func (b *BatchConsumerUserWithRulesResult) GetRiskScoreDetails() *UserRiskScoreDetails {
	if b == nil {
		return nil
	}
	return b.RiskScoreDetails
}

func (b *BatchConsumerUserWithRulesResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchConsumerUserWithRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchConsumerUserWithRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchConsumerUserWithRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchConsumerUserWithRulesResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchConsumerUserWithRulesResultSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromCard(value *CardDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromIban(value *IbanDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromAch(value *AchDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromUpi(value *UpiDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromWallet(value *WalletDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromCheck(value *CheckDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromCash(value *CashDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewBatchConsumerUserWithRulesResultSavedPaymentDetailsItemFromNpp(value *NppDetails) *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem {
	return &BatchConsumerUserWithRulesResultSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetMethod() string {
	if b == nil {
		return ""
	}
	return b.Method
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetCard() *CardDetails {
	if b == nil {
		return nil
	}
	return b.Card
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if b == nil {
		return nil
	}
	return b.GenericBankAccount
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if b == nil {
		return nil
	}
	return b.Iban
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetAch() *AchDetails {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if b == nil {
		return nil
	}
	return b.Swift
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if b == nil {
		return nil
	}
	return b.Mpesa
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if b == nil {
		return nil
	}
	return b.Upi
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if b == nil {
		return nil
	}
	return b.Wallet
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if b == nil {
		return nil
	}
	return b.Check
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetCash() *CashDetails {
	if b == nil {
		return nil
	}
	return b.Cash
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if b == nil {
		return nil
	}
	return b.Npp
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", b)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Npp = value
	}
	return nil
}

func (b BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	switch b.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(b.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(b.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(b.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(b.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(b.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(b.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(b.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(b.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(b.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(b.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(b.Npp, "method", "NPP")
	}
}

type BatchConsumerUserWithRulesResultSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) Accept(visitor BatchConsumerUserWithRulesResultSavedPaymentDetailsItemVisitor) error {
	switch b.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return visitor.VisitCard(b.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(b.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(b.Iban)
	case "ACH":
		return visitor.VisitAch(b.Ach)
	case "SWIFT":
		return visitor.VisitSwift(b.Swift)
	case "MPESA":
		return visitor.VisitMpesa(b.Mpesa)
	case "UPI":
		return visitor.VisitUpi(b.Upi)
	case "WALLET":
		return visitor.VisitWallet(b.Wallet)
	case "CHECK":
		return visitor.VisitCheck(b.Check)
	case "CASH":
		return visitor.VisitCash(b.Cash)
	case "NPP":
		return visitor.VisitNpp(b.Npp)
	}
}

func (b *BatchConsumerUserWithRulesResultSavedPaymentDetailsItem) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Card != nil {
		fields = append(fields, "CARD")
	}
	if b.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if b.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if b.Ach != nil {
		fields = append(fields, "ACH")
	}
	if b.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if b.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if b.Upi != nil {
		fields = append(fields, "UPI")
	}
	if b.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if b.Check != nil {
		fields = append(fields, "CHECK")
	}
	if b.Cash != nil {
		fields = append(fields, "CASH")
	}
	if b.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if b.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Method)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Method != "" {
		field := fields[0]
		if b.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Method,
				b,
			)
		}
	}
	return nil
}

type BatchConsumerUsersWithRulesResult struct {
	ConsumerUsers []*BatchConsumerUserWithRulesResult `json:"consumerUsers,omitempty" url:"consumerUsers,omitempty"`
	TotalCount    float64                             `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchConsumerUsersWithRulesResult) GetConsumerUsers() []*BatchConsumerUserWithRulesResult {
	if b == nil {
		return nil
	}
	return b.ConsumerUsers
}

func (b *BatchConsumerUsersWithRulesResult) GetTotalCount() float64 {
	if b == nil {
		return 0
	}
	return b.TotalCount
}

func (b *BatchConsumerUsersWithRulesResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchConsumerUsersWithRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchConsumerUsersWithRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchConsumerUsersWithRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchConsumerUsersWithRulesResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchTransactionEventMonitoringResult struct {
	TransactionState TransactionState `json:"transactionState" url:"transactionState"`
	// Timestamp of the event
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// Transaction ID the event pertains to
	TransactionId string `json:"transactionId" url:"transactionId"`
	// Unique event ID
	EventId *string `json:"eventId,omitempty" url:"eventId,omitempty"`
	// Reason for the event or a state change
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// Event description
	EventDescription             *string                       `json:"eventDescription,omitempty" url:"eventDescription,omitempty"`
	UpdatedTransactionAttributes *TransactionUpdatable         `json:"updatedTransactionAttributes,omitempty" url:"updatedTransactionAttributes,omitempty"`
	MetaData                     *DeviceData                   `json:"metaData,omitempty" url:"metaData,omitempty"`
	UpdateCount                  *float64                      `json:"updateCount,omitempty" url:"updateCount,omitempty"`
	HitRules                     []*HitRulesDetails            `json:"hitRules,omitempty" url:"hitRules,omitempty"`
	Status                       *RuleAction                   `json:"status,omitempty" url:"status,omitempty"`
	RiskScoreDetails             *TransactionRiskScoringResult `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchTransactionEventMonitoringResult) GetTransactionState() TransactionState {
	if b == nil {
		return ""
	}
	return b.TransactionState
}

func (b *BatchTransactionEventMonitoringResult) GetTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.Timestamp
}

func (b *BatchTransactionEventMonitoringResult) GetTransactionId() string {
	if b == nil {
		return ""
	}
	return b.TransactionId
}

func (b *BatchTransactionEventMonitoringResult) GetEventId() *string {
	if b == nil {
		return nil
	}
	return b.EventId
}

func (b *BatchTransactionEventMonitoringResult) GetReason() *string {
	if b == nil {
		return nil
	}
	return b.Reason
}

func (b *BatchTransactionEventMonitoringResult) GetEventDescription() *string {
	if b == nil {
		return nil
	}
	return b.EventDescription
}

func (b *BatchTransactionEventMonitoringResult) GetUpdatedTransactionAttributes() *TransactionUpdatable {
	if b == nil {
		return nil
	}
	return b.UpdatedTransactionAttributes
}

func (b *BatchTransactionEventMonitoringResult) GetMetaData() *DeviceData {
	if b == nil {
		return nil
	}
	return b.MetaData
}

func (b *BatchTransactionEventMonitoringResult) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *BatchTransactionEventMonitoringResult) GetHitRules() []*HitRulesDetails {
	if b == nil {
		return nil
	}
	return b.HitRules
}

func (b *BatchTransactionEventMonitoringResult) GetStatus() *RuleAction {
	if b == nil {
		return nil
	}
	return b.Status
}

func (b *BatchTransactionEventMonitoringResult) GetRiskScoreDetails() *TransactionRiskScoringResult {
	if b == nil {
		return nil
	}
	return b.RiskScoreDetails
}

func (b *BatchTransactionEventMonitoringResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchTransactionEventMonitoringResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchTransactionEventMonitoringResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchTransactionEventMonitoringResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchTransactionEventMonitoringResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchTransactionEventMonitoringResults struct {
	TransactionEvents []*BatchTransactionEventMonitoringResult `json:"transactionEvents,omitempty" url:"transactionEvents,omitempty"`
	TotalCount        float64                                  `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchTransactionEventMonitoringResults) GetTransactionEvents() []*BatchTransactionEventMonitoringResult {
	if b == nil {
		return nil
	}
	return b.TransactionEvents
}

func (b *BatchTransactionEventMonitoringResults) GetTotalCount() float64 {
	if b == nil {
		return 0
	}
	return b.TotalCount
}

func (b *BatchTransactionEventMonitoringResults) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchTransactionEventMonitoringResults) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchTransactionEventMonitoringResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchTransactionEventMonitoringResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchTransactionEventMonitoringResults) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchTransactionMonitoringResult struct {
	// Transaction ID that the results pertain to
	TransactionId    string                        `json:"transactionId" url:"transactionId"`
	Status           RuleAction                    `json:"status" url:"status"`
	RiskScoreDetails *TransactionRiskScoringResult `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`
	// Uniquue transaction identifier
	HitRules []*HitRulesDetails `json:"hitRules,omitempty" url:"hitRules,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchTransactionMonitoringResult) GetTransactionId() string {
	if b == nil {
		return ""
	}
	return b.TransactionId
}

func (b *BatchTransactionMonitoringResult) GetStatus() RuleAction {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BatchTransactionMonitoringResult) GetRiskScoreDetails() *TransactionRiskScoringResult {
	if b == nil {
		return nil
	}
	return b.RiskScoreDetails
}

func (b *BatchTransactionMonitoringResult) GetHitRules() []*HitRulesDetails {
	if b == nil {
		return nil
	}
	return b.HitRules
}

func (b *BatchTransactionMonitoringResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchTransactionMonitoringResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchTransactionMonitoringResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchTransactionMonitoringResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchTransactionMonitoringResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchTransactionMonitoringResults struct {
	Transactions []*BatchTransactionMonitoringResult `json:"transactions,omitempty" url:"transactions,omitempty"`
	TotalCount   float64                             `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchTransactionMonitoringResults) GetTransactions() []*BatchTransactionMonitoringResult {
	if b == nil {
		return nil
	}
	return b.Transactions
}

func (b *BatchTransactionMonitoringResults) GetTotalCount() float64 {
	if b == nil {
		return 0
	}
	return b.TotalCount
}

func (b *BatchTransactionMonitoringResults) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchTransactionMonitoringResults) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchTransactionMonitoringResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchTransactionMonitoringResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchTransactionMonitoringResults) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchUserRulesResult struct {
	ExecutedRules    []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	RiskScoreDetails *UserRiskScoreDetails  `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchUserRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if b == nil {
		return nil
	}
	return b.ExecutedRules
}

func (b *BatchUserRulesResult) GetRiskScoreDetails() *UserRiskScoreDetails {
	if b == nil {
		return nil
	}
	return b.RiskScoreDetails
}

func (b *BatchUserRulesResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUserRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUserRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUserRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUserRulesResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BooleanString string

const (
	BooleanStringTrue  BooleanString = "true"
	BooleanStringFalse BooleanString = "false"
)

func NewBooleanStringFromString(s string) (BooleanString, error) {
	switch s {
	case "true":
		return BooleanStringTrue, nil
	case "false":
		return BooleanStringFalse, nil
	}
	var t BooleanString
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BooleanString) Ptr() *BooleanString {
	return &b
}

type Business struct {
	// Unique user ID for the user
	UserId string `json:"userId" url:"userId"`
	// Timestamp when the user was created
	CreatedTimestamp float64      `json:"createdTimestamp" url:"createdTimestamp"`
	LegalEntity      *LegalEntity `json:"legalEntity,omitempty" url:"legalEntity,omitempty"`
	// Timestamp when the user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	// Shareholders (beneficiaries) of the company that hold at least 25% ownership. Can be another company or an individual
	ShareHolders []*Person `json:"shareHolders,omitempty" url:"shareHolders,omitempty"`
	// Director(s) of the company. Must be at least one
	Directors             []*Person          `json:"directors,omitempty" url:"directors,omitempty"`
	TransactionLimits     *TransactionLimits `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	RiskLevel             *RiskLevel         `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel          *RiskLevel         `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AllowedPaymentMethods []PaymentMethod    `json:"allowedPaymentMethods,omitempty" url:"allowedPaymentMethods,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                           `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                    `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	AcquisitionChannel       *AcquisitionChannel                `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	SavedPaymentDetails      []*BusinessSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	MccDetails               *MccDetails                        `json:"mccDetails,omitempty" url:"mccDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// User's attachments uploaded by business user
	Attachments []*PersonAttachment `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount *float64            `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Business) GetUserId() string {
	if b == nil {
		return ""
	}
	return b.UserId
}

func (b *Business) GetCreatedTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.CreatedTimestamp
}

func (b *Business) GetLegalEntity() *LegalEntity {
	if b == nil {
		return nil
	}
	return b.LegalEntity
}

func (b *Business) GetActivatedTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.ActivatedTimestamp
}

func (b *Business) GetUserStateDetails() *UserStateDetails {
	if b == nil {
		return nil
	}
	return b.UserStateDetails
}

func (b *Business) GetKycStatusDetails() *KycStatusDetails {
	if b == nil {
		return nil
	}
	return b.KycStatusDetails
}

func (b *Business) GetShareHolders() []*Person {
	if b == nil {
		return nil
	}
	return b.ShareHolders
}

func (b *Business) GetDirectors() []*Person {
	if b == nil {
		return nil
	}
	return b.Directors
}

func (b *Business) GetTransactionLimits() *TransactionLimits {
	if b == nil {
		return nil
	}
	return b.TransactionLimits
}

func (b *Business) GetRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.RiskLevel
}

func (b *Business) GetKycRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.KycRiskLevel
}

func (b *Business) GetAllowedPaymentMethods() []PaymentMethod {
	if b == nil {
		return nil
	}
	return b.AllowedPaymentMethods
}

func (b *Business) GetLastTransactionTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.LastTransactionTimestamp
}

func (b *Business) GetLinkedEntities() *UserEntityLink {
	if b == nil {
		return nil
	}
	return b.LinkedEntities
}

func (b *Business) GetAcquisitionChannel() *AcquisitionChannel {
	if b == nil {
		return nil
	}
	return b.AcquisitionChannel
}

func (b *Business) GetSavedPaymentDetails() []*BusinessSavedPaymentDetailsItem {
	if b == nil {
		return nil
	}
	return b.SavedPaymentDetails
}

func (b *Business) GetMccDetails() *MccDetails {
	if b == nil {
		return nil
	}
	return b.MccDetails
}

func (b *Business) GetTags() []*UserTag {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *Business) GetAttachments() []*PersonAttachment {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *Business) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *Business) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Business) UnmarshalJSON(data []byte) error {
	type unmarshaler Business
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Business(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Business) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Model for a business user base fields
type BusinessBase struct {
	// Unique user ID for the user
	UserId string `json:"userId" url:"userId"`
	// Timestamp when the user was created
	CreatedTimestamp float64      `json:"createdTimestamp" url:"createdTimestamp"`
	LegalEntity      *LegalEntity `json:"legalEntity,omitempty" url:"legalEntity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BusinessBase) GetUserId() string {
	if b == nil {
		return ""
	}
	return b.UserId
}

func (b *BusinessBase) GetCreatedTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.CreatedTimestamp
}

func (b *BusinessBase) GetLegalEntity() *LegalEntity {
	if b == nil {
		return nil
	}
	return b.LegalEntity
}

func (b *BusinessBase) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessBase) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessBase) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Model for a business user - optional fields
type BusinessOptional struct {
	// Timestamp when the user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	LegalEntity        *LegalEntity      `json:"legalEntity,omitempty" url:"legalEntity,omitempty"`
	// Shareholders (beneficiaries) of the company that hold at least 25% ownership. Can be another company or an individual
	ShareHolders []*Person `json:"shareHolders,omitempty" url:"shareHolders,omitempty"`
	// Director(s) of the company. Must be at least one
	Directors             []*Person          `json:"directors,omitempty" url:"directors,omitempty"`
	TransactionLimits     *TransactionLimits `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	RiskLevel             *RiskLevel         `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel          *RiskLevel         `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AllowedPaymentMethods []PaymentMethod    `json:"allowedPaymentMethods,omitempty" url:"allowedPaymentMethods,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                                   `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                            `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	AcquisitionChannel       *AcquisitionChannel                        `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	SavedPaymentDetails      []*BusinessOptionalSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	MccDetails               *MccDetails                                `json:"mccDetails,omitempty" url:"mccDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// User's attachments uploaded by business user
	Attachments []*PersonAttachment `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount *float64            `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BusinessOptional) GetActivatedTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.ActivatedTimestamp
}

func (b *BusinessOptional) GetUserStateDetails() *UserStateDetails {
	if b == nil {
		return nil
	}
	return b.UserStateDetails
}

func (b *BusinessOptional) GetKycStatusDetails() *KycStatusDetails {
	if b == nil {
		return nil
	}
	return b.KycStatusDetails
}

func (b *BusinessOptional) GetLegalEntity() *LegalEntity {
	if b == nil {
		return nil
	}
	return b.LegalEntity
}

func (b *BusinessOptional) GetShareHolders() []*Person {
	if b == nil {
		return nil
	}
	return b.ShareHolders
}

func (b *BusinessOptional) GetDirectors() []*Person {
	if b == nil {
		return nil
	}
	return b.Directors
}

func (b *BusinessOptional) GetTransactionLimits() *TransactionLimits {
	if b == nil {
		return nil
	}
	return b.TransactionLimits
}

func (b *BusinessOptional) GetRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.RiskLevel
}

func (b *BusinessOptional) GetKycRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.KycRiskLevel
}

func (b *BusinessOptional) GetAllowedPaymentMethods() []PaymentMethod {
	if b == nil {
		return nil
	}
	return b.AllowedPaymentMethods
}

func (b *BusinessOptional) GetLastTransactionTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.LastTransactionTimestamp
}

func (b *BusinessOptional) GetLinkedEntities() *UserEntityLink {
	if b == nil {
		return nil
	}
	return b.LinkedEntities
}

func (b *BusinessOptional) GetAcquisitionChannel() *AcquisitionChannel {
	if b == nil {
		return nil
	}
	return b.AcquisitionChannel
}

func (b *BusinessOptional) GetSavedPaymentDetails() []*BusinessOptionalSavedPaymentDetailsItem {
	if b == nil {
		return nil
	}
	return b.SavedPaymentDetails
}

func (b *BusinessOptional) GetMccDetails() *MccDetails {
	if b == nil {
		return nil
	}
	return b.MccDetails
}

func (b *BusinessOptional) GetTags() []*UserTag {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BusinessOptional) GetAttachments() []*PersonAttachment {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *BusinessOptional) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *BusinessOptional) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessOptional) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessOptional
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessOptional(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessOptional) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessOptionalSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewBusinessOptionalSavedPaymentDetailsItemFromCard(value *CardDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromIban(value *IbanDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromAch(value *AchDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromUpi(value *UpiDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromWallet(value *WalletDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromCheck(value *CheckDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromCash(value *CashDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewBusinessOptionalSavedPaymentDetailsItemFromNpp(value *NppDetails) *BusinessOptionalSavedPaymentDetailsItem {
	return &BusinessOptionalSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetMethod() string {
	if b == nil {
		return ""
	}
	return b.Method
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetCard() *CardDetails {
	if b == nil {
		return nil
	}
	return b.Card
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if b == nil {
		return nil
	}
	return b.GenericBankAccount
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if b == nil {
		return nil
	}
	return b.Iban
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetAch() *AchDetails {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if b == nil {
		return nil
	}
	return b.Swift
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if b == nil {
		return nil
	}
	return b.Mpesa
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if b == nil {
		return nil
	}
	return b.Upi
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if b == nil {
		return nil
	}
	return b.Wallet
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if b == nil {
		return nil
	}
	return b.Check
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetCash() *CashDetails {
	if b == nil {
		return nil
	}
	return b.Cash
}

func (b *BusinessOptionalSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if b == nil {
		return nil
	}
	return b.Npp
}

func (b *BusinessOptionalSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", b)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Npp = value
	}
	return nil
}

func (b BusinessOptionalSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	switch b.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(b.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(b.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(b.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(b.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(b.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(b.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(b.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(b.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(b.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(b.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(b.Npp, "method", "NPP")
	}
}

type BusinessOptionalSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (b *BusinessOptionalSavedPaymentDetailsItem) Accept(visitor BusinessOptionalSavedPaymentDetailsItemVisitor) error {
	switch b.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return visitor.VisitCard(b.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(b.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(b.Iban)
	case "ACH":
		return visitor.VisitAch(b.Ach)
	case "SWIFT":
		return visitor.VisitSwift(b.Swift)
	case "MPESA":
		return visitor.VisitMpesa(b.Mpesa)
	case "UPI":
		return visitor.VisitUpi(b.Upi)
	case "WALLET":
		return visitor.VisitWallet(b.Wallet)
	case "CHECK":
		return visitor.VisitCheck(b.Check)
	case "CASH":
		return visitor.VisitCash(b.Cash)
	case "NPP":
		return visitor.VisitNpp(b.Npp)
	}
}

func (b *BusinessOptionalSavedPaymentDetailsItem) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Card != nil {
		fields = append(fields, "CARD")
	}
	if b.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if b.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if b.Ach != nil {
		fields = append(fields, "ACH")
	}
	if b.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if b.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if b.Upi != nil {
		fields = append(fields, "UPI")
	}
	if b.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if b.Check != nil {
		fields = append(fields, "CHECK")
	}
	if b.Cash != nil {
		fields = append(fields, "CASH")
	}
	if b.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if b.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Method)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Method != "" {
		field := fields[0]
		if b.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Method,
				b,
			)
		}
	}
	return nil
}

type BusinessSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewBusinessSavedPaymentDetailsItemFromCard(value *CardDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewBusinessSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewBusinessSavedPaymentDetailsItemFromIban(value *IbanDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewBusinessSavedPaymentDetailsItemFromAch(value *AchDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewBusinessSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewBusinessSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewBusinessSavedPaymentDetailsItemFromUpi(value *UpiDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewBusinessSavedPaymentDetailsItemFromWallet(value *WalletDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewBusinessSavedPaymentDetailsItemFromCheck(value *CheckDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewBusinessSavedPaymentDetailsItemFromCash(value *CashDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewBusinessSavedPaymentDetailsItemFromNpp(value *NppDetails) *BusinessSavedPaymentDetailsItem {
	return &BusinessSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (b *BusinessSavedPaymentDetailsItem) GetMethod() string {
	if b == nil {
		return ""
	}
	return b.Method
}

func (b *BusinessSavedPaymentDetailsItem) GetCard() *CardDetails {
	if b == nil {
		return nil
	}
	return b.Card
}

func (b *BusinessSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if b == nil {
		return nil
	}
	return b.GenericBankAccount
}

func (b *BusinessSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if b == nil {
		return nil
	}
	return b.Iban
}

func (b *BusinessSavedPaymentDetailsItem) GetAch() *AchDetails {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BusinessSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if b == nil {
		return nil
	}
	return b.Swift
}

func (b *BusinessSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if b == nil {
		return nil
	}
	return b.Mpesa
}

func (b *BusinessSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if b == nil {
		return nil
	}
	return b.Upi
}

func (b *BusinessSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if b == nil {
		return nil
	}
	return b.Wallet
}

func (b *BusinessSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if b == nil {
		return nil
	}
	return b.Check
}

func (b *BusinessSavedPaymentDetailsItem) GetCash() *CashDetails {
	if b == nil {
		return nil
	}
	return b.Cash
}

func (b *BusinessSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if b == nil {
		return nil
	}
	return b.Npp
}

func (b *BusinessSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", b)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Npp = value
	}
	return nil
}

func (b BusinessSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	switch b.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(b.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(b.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(b.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(b.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(b.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(b.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(b.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(b.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(b.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(b.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(b.Npp, "method", "NPP")
	}
}

type BusinessSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (b *BusinessSavedPaymentDetailsItem) Accept(visitor BusinessSavedPaymentDetailsItemVisitor) error {
	switch b.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return visitor.VisitCard(b.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(b.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(b.Iban)
	case "ACH":
		return visitor.VisitAch(b.Ach)
	case "SWIFT":
		return visitor.VisitSwift(b.Swift)
	case "MPESA":
		return visitor.VisitMpesa(b.Mpesa)
	case "UPI":
		return visitor.VisitUpi(b.Upi)
	case "WALLET":
		return visitor.VisitWallet(b.Wallet)
	case "CHECK":
		return visitor.VisitCheck(b.Check)
	case "CASH":
		return visitor.VisitCash(b.Cash)
	case "NPP":
		return visitor.VisitNpp(b.Npp)
	}
}

func (b *BusinessSavedPaymentDetailsItem) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Card != nil {
		fields = append(fields, "CARD")
	}
	if b.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if b.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if b.Ach != nil {
		fields = append(fields, "ACH")
	}
	if b.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if b.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if b.Upi != nil {
		fields = append(fields, "UPI")
	}
	if b.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if b.Check != nil {
		fields = append(fields, "CHECK")
	}
	if b.Cash != nil {
		fields = append(fields, "CASH")
	}
	if b.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if b.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Method)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Method != "" {
		field := fields[0]
		if b.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Method,
				b,
			)
		}
	}
	return nil
}

// Model for business user-related events
type BusinessUserEvent struct {
	// Timestamp of the event
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// Transaction ID the event pertains to
	UserId string `json:"userId" url:"userId"`
	// Unique event ID
	EventId *string `json:"eventId,omitempty" url:"eventId,omitempty"`
	// Reason for the event or a state change
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// Event description
	EventDescription              *string           `json:"eventDescription,omitempty" url:"eventDescription,omitempty"`
	UpdatedBusinessUserAttributes *BusinessOptional `json:"updatedBusinessUserAttributes,omitempty" url:"updatedBusinessUserAttributes,omitempty"`
	UpdateCount                   *float64          `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BusinessUserEvent) GetTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.Timestamp
}

func (b *BusinessUserEvent) GetUserId() string {
	if b == nil {
		return ""
	}
	return b.UserId
}

func (b *BusinessUserEvent) GetEventId() *string {
	if b == nil {
		return nil
	}
	return b.EventId
}

func (b *BusinessUserEvent) GetReason() *string {
	if b == nil {
		return nil
	}
	return b.Reason
}

func (b *BusinessUserEvent) GetEventDescription() *string {
	if b == nil {
		return nil
	}
	return b.EventDescription
}

func (b *BusinessUserEvent) GetUpdatedBusinessUserAttributes() *BusinessOptional {
	if b == nil {
		return nil
	}
	return b.UpdatedBusinessUserAttributes
}

func (b *BusinessUserEvent) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *BusinessUserEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessUserEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessUserEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessUserEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessUserEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessUserSegment string

const (
	BusinessUserSegmentSoleProprietorship BusinessUserSegment = "SOLE_PROPRIETORSHIP"
	BusinessUserSegmentLimited            BusinessUserSegment = "LIMITED"
	BusinessUserSegmentSmb                BusinessUserSegment = "SMB"
	BusinessUserSegmentSmall              BusinessUserSegment = "SMALL"
	BusinessUserSegmentMedium             BusinessUserSegment = "MEDIUM"
	BusinessUserSegmentLarge              BusinessUserSegment = "LARGE"
	BusinessUserSegmentUnknown            BusinessUserSegment = "UNKNOWN"
)

func NewBusinessUserSegmentFromString(s string) (BusinessUserSegment, error) {
	switch s {
	case "SOLE_PROPRIETORSHIP":
		return BusinessUserSegmentSoleProprietorship, nil
	case "LIMITED":
		return BusinessUserSegmentLimited, nil
	case "SMB":
		return BusinessUserSegmentSmb, nil
	case "SMALL":
		return BusinessUserSegmentSmall, nil
	case "MEDIUM":
		return BusinessUserSegmentMedium, nil
	case "LARGE":
		return BusinessUserSegmentLarge, nil
	case "UNKNOWN":
		return BusinessUserSegmentUnknown, nil
	}
	var t BusinessUserSegment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessUserSegment) Ptr() *BusinessUserSegment {
	return &b
}

type BusinessWithRulesResult struct {
	// Unique user ID for the user
	UserId string `json:"userId" url:"userId"`
	// Timestamp when the user was created
	CreatedTimestamp float64      `json:"createdTimestamp" url:"createdTimestamp"`
	LegalEntity      *LegalEntity `json:"legalEntity,omitempty" url:"legalEntity,omitempty"`
	// Timestamp when the user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	// Shareholders (beneficiaries) of the company that hold at least 25% ownership. Can be another company or an individual
	ShareHolders []*Person `json:"shareHolders,omitempty" url:"shareHolders,omitempty"`
	// Director(s) of the company. Must be at least one
	Directors             []*Person          `json:"directors,omitempty" url:"directors,omitempty"`
	TransactionLimits     *TransactionLimits `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	RiskLevel             *RiskLevel         `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel          *RiskLevel         `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AllowedPaymentMethods []PaymentMethod    `json:"allowedPaymentMethods,omitempty" url:"allowedPaymentMethods,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                                          `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                                   `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	AcquisitionChannel       *AcquisitionChannel                               `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	SavedPaymentDetails      []*BusinessWithRulesResultSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	MccDetails               *MccDetails                                       `json:"mccDetails,omitempty" url:"mccDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// User's attachments uploaded by business user
	Attachments      []*PersonAttachment    `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount      *float64               `json:"updateCount,omitempty" url:"updateCount,omitempty"`
	ExecutedRules    []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	HitRules         []*HitRulesDetails     `json:"hitRules,omitempty" url:"hitRules,omitempty"`
	RiskScoreDetails *UserRiskScoreDetails  `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BusinessWithRulesResult) GetUserId() string {
	if b == nil {
		return ""
	}
	return b.UserId
}

func (b *BusinessWithRulesResult) GetCreatedTimestamp() float64 {
	if b == nil {
		return 0
	}
	return b.CreatedTimestamp
}

func (b *BusinessWithRulesResult) GetLegalEntity() *LegalEntity {
	if b == nil {
		return nil
	}
	return b.LegalEntity
}

func (b *BusinessWithRulesResult) GetActivatedTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.ActivatedTimestamp
}

func (b *BusinessWithRulesResult) GetUserStateDetails() *UserStateDetails {
	if b == nil {
		return nil
	}
	return b.UserStateDetails
}

func (b *BusinessWithRulesResult) GetKycStatusDetails() *KycStatusDetails {
	if b == nil {
		return nil
	}
	return b.KycStatusDetails
}

func (b *BusinessWithRulesResult) GetShareHolders() []*Person {
	if b == nil {
		return nil
	}
	return b.ShareHolders
}

func (b *BusinessWithRulesResult) GetDirectors() []*Person {
	if b == nil {
		return nil
	}
	return b.Directors
}

func (b *BusinessWithRulesResult) GetTransactionLimits() *TransactionLimits {
	if b == nil {
		return nil
	}
	return b.TransactionLimits
}

func (b *BusinessWithRulesResult) GetRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.RiskLevel
}

func (b *BusinessWithRulesResult) GetKycRiskLevel() *RiskLevel {
	if b == nil {
		return nil
	}
	return b.KycRiskLevel
}

func (b *BusinessWithRulesResult) GetAllowedPaymentMethods() []PaymentMethod {
	if b == nil {
		return nil
	}
	return b.AllowedPaymentMethods
}

func (b *BusinessWithRulesResult) GetLastTransactionTimestamp() *float64 {
	if b == nil {
		return nil
	}
	return b.LastTransactionTimestamp
}

func (b *BusinessWithRulesResult) GetLinkedEntities() *UserEntityLink {
	if b == nil {
		return nil
	}
	return b.LinkedEntities
}

func (b *BusinessWithRulesResult) GetAcquisitionChannel() *AcquisitionChannel {
	if b == nil {
		return nil
	}
	return b.AcquisitionChannel
}

func (b *BusinessWithRulesResult) GetSavedPaymentDetails() []*BusinessWithRulesResultSavedPaymentDetailsItem {
	if b == nil {
		return nil
	}
	return b.SavedPaymentDetails
}

func (b *BusinessWithRulesResult) GetMccDetails() *MccDetails {
	if b == nil {
		return nil
	}
	return b.MccDetails
}

func (b *BusinessWithRulesResult) GetTags() []*UserTag {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BusinessWithRulesResult) GetAttachments() []*PersonAttachment {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *BusinessWithRulesResult) GetUpdateCount() *float64 {
	if b == nil {
		return nil
	}
	return b.UpdateCount
}

func (b *BusinessWithRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if b == nil {
		return nil
	}
	return b.ExecutedRules
}

func (b *BusinessWithRulesResult) GetHitRules() []*HitRulesDetails {
	if b == nil {
		return nil
	}
	return b.HitRules
}

func (b *BusinessWithRulesResult) GetRiskScoreDetails() *UserRiskScoreDetails {
	if b == nil {
		return nil
	}
	return b.RiskScoreDetails
}

func (b *BusinessWithRulesResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessWithRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessWithRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessWithRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessWithRulesResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessWithRulesResultSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromCard(value *CardDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromIban(value *IbanDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromAch(value *AchDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromUpi(value *UpiDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromWallet(value *WalletDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromCheck(value *CheckDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromCash(value *CashDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewBusinessWithRulesResultSavedPaymentDetailsItemFromNpp(value *NppDetails) *BusinessWithRulesResultSavedPaymentDetailsItem {
	return &BusinessWithRulesResultSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetMethod() string {
	if b == nil {
		return ""
	}
	return b.Method
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetCard() *CardDetails {
	if b == nil {
		return nil
	}
	return b.Card
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if b == nil {
		return nil
	}
	return b.GenericBankAccount
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if b == nil {
		return nil
	}
	return b.Iban
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetAch() *AchDetails {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if b == nil {
		return nil
	}
	return b.Swift
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if b == nil {
		return nil
	}
	return b.Mpesa
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if b == nil {
		return nil
	}
	return b.Upi
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if b == nil {
		return nil
	}
	return b.Wallet
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if b == nil {
		return nil
	}
	return b.Check
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetCash() *CashDetails {
	if b == nil {
		return nil
	}
	return b.Cash
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if b == nil {
		return nil
	}
	return b.Npp
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", b)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Npp = value
	}
	return nil
}

func (b BusinessWithRulesResultSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	switch b.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(b.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(b.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(b.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(b.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(b.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(b.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(b.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(b.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(b.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(b.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(b.Npp, "method", "NPP")
	}
}

type BusinessWithRulesResultSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) Accept(visitor BusinessWithRulesResultSavedPaymentDetailsItemVisitor) error {
	switch b.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", b.Method, b)
	case "CARD":
		return visitor.VisitCard(b.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(b.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(b.Iban)
	case "ACH":
		return visitor.VisitAch(b.Ach)
	case "SWIFT":
		return visitor.VisitSwift(b.Swift)
	case "MPESA":
		return visitor.VisitMpesa(b.Mpesa)
	case "UPI":
		return visitor.VisitUpi(b.Upi)
	case "WALLET":
		return visitor.VisitWallet(b.Wallet)
	case "CHECK":
		return visitor.VisitCheck(b.Check)
	case "CASH":
		return visitor.VisitCash(b.Cash)
	case "NPP":
		return visitor.VisitNpp(b.Npp)
	}
}

func (b *BusinessWithRulesResultSavedPaymentDetailsItem) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Card != nil {
		fields = append(fields, "CARD")
	}
	if b.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if b.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if b.Ach != nil {
		fields = append(fields, "ACH")
	}
	if b.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if b.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if b.Upi != nil {
		fields = append(fields, "UPI")
	}
	if b.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if b.Check != nil {
		fields = append(fields, "CHECK")
	}
	if b.Cash != nil {
		fields = append(fields, "CASH")
	}
	if b.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if b.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Method)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Method != "" {
		field := fields[0]
		if b.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Method,
				b,
			)
		}
	}
	return nil
}

type CraRiskLevelUpdatedDetails struct {
	RiskLevel *string `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	UserId    *string `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CraRiskLevelUpdatedDetails) GetRiskLevel() *string {
	if c == nil {
		return nil
	}
	return c.RiskLevel
}

func (c *CraRiskLevelUpdatedDetails) GetUserId() *string {
	if c == nil {
		return nil
	}
	return c.UserId
}

func (c *CraRiskLevelUpdatedDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CraRiskLevelUpdatedDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CraRiskLevelUpdatedDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CraRiskLevelUpdatedDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CraRiskLevelUpdatedDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Brand of Card
type CardBrand string

const (
	CardBrandVisa            CardBrand = "VISA"
	CardBrandMastercard      CardBrand = "MASTERCARD"
	CardBrandAmericanExpress CardBrand = "AMERICAN_EXPRESS"
	CardBrandDiscover        CardBrand = "DISCOVER"
	CardBrandUnionpay        CardBrand = "UNIONPAY"
	CardBrandRupay           CardBrand = "RUPAY"
	CardBrandJcb             CardBrand = "JCB"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "VISA":
		return CardBrandVisa, nil
	case "MASTERCARD":
		return CardBrandMastercard, nil
	case "AMERICAN_EXPRESS":
		return CardBrandAmericanExpress, nil
	case "DISCOVER":
		return CardBrandDiscover, nil
	case "UNIONPAY":
		return CardBrandUnionpay, nil
	case "RUPAY":
		return CardBrandRupay, nil
	case "JCB":
		return CardBrandJcb, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

// Model for credit or debit card details
type CardDetails struct {
	// Unique card fingerprint that helps identify a specific card without having to use explicit card number. This is likely available at your card payment scheme provider
	CardFingerprint   *string      `json:"cardFingerprint,omitempty" url:"cardFingerprint,omitempty"`
	EmailId           *EmailId     `json:"emailId,omitempty" url:"emailId,omitempty"`
	CardStatus        *CardStatus  `json:"cardStatus,omitempty" url:"cardStatus,omitempty"`
	CardIssuedCountry *CountryCode `json:"cardIssuedCountry,omitempty" url:"cardIssuedCountry,omitempty"`
	// Reference for the transaction
	TransactionReferenceField *string       `json:"transactionReferenceField,omitempty" url:"transactionReferenceField,omitempty"`
	NameOnCard                *ConsumerName `json:"nameOnCard,omitempty" url:"nameOnCard,omitempty"`
	CardExpiry                *CardExpiry   `json:"cardExpiry,omitempty" url:"cardExpiry,omitempty"`
	PosDetails                *PosDetails   `json:"posDetails,omitempty" url:"posDetails,omitempty"`
	// Last 4 digits of Card
	CardLast4Digits *string      `json:"cardLast4Digits,omitempty" url:"cardLast4Digits,omitempty"`
	CardBrand       *CardBrand   `json:"cardBrand,omitempty" url:"cardBrand,omitempty"`
	CardFunding     *CardFunding `json:"cardFunding,omitempty" url:"cardFunding,omitempty"`
	// Authentication of Card
	CardAuthenticated *bool `json:"cardAuthenticated,omitempty" url:"cardAuthenticated,omitempty"`
	// Was the card tokenized
	CardTokenized *bool `json:"cardTokenized,omitempty" url:"cardTokenized,omitempty"`
	// Card Present
	CardPresent     *bool                `json:"cardPresent,omitempty" url:"cardPresent,omitempty"`
	PaymentChannel  *string              `json:"paymentChannel,omitempty" url:"paymentChannel,omitempty"`
	CardType        *CardType            `json:"cardType,omitempty" url:"cardType,omitempty"`
	CardBalance     *Amount              `json:"cardBalance,omitempty" url:"cardBalance,omitempty"`
	MerchantDetails *CardMerchantDetails `json:"merchantDetails,omitempty" url:"merchantDetails,omitempty"`
	// Risk score of the card from your network provider
	NetworkProviderRiskScore *float64 `json:"networkProviderRiskScore,omitempty" url:"networkProviderRiskScore,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardDetails) GetCardFingerprint() *string {
	if c == nil {
		return nil
	}
	return c.CardFingerprint
}

func (c *CardDetails) GetEmailId() *EmailId {
	if c == nil {
		return nil
	}
	return c.EmailId
}

func (c *CardDetails) GetCardStatus() *CardStatus {
	if c == nil {
		return nil
	}
	return c.CardStatus
}

func (c *CardDetails) GetCardIssuedCountry() *CountryCode {
	if c == nil {
		return nil
	}
	return c.CardIssuedCountry
}

func (c *CardDetails) GetTransactionReferenceField() *string {
	if c == nil {
		return nil
	}
	return c.TransactionReferenceField
}

func (c *CardDetails) GetNameOnCard() *ConsumerName {
	if c == nil {
		return nil
	}
	return c.NameOnCard
}

func (c *CardDetails) GetCardExpiry() *CardExpiry {
	if c == nil {
		return nil
	}
	return c.CardExpiry
}

func (c *CardDetails) GetPosDetails() *PosDetails {
	if c == nil {
		return nil
	}
	return c.PosDetails
}

func (c *CardDetails) GetCardLast4Digits() *string {
	if c == nil {
		return nil
	}
	return c.CardLast4Digits
}

func (c *CardDetails) GetCardBrand() *CardBrand {
	if c == nil {
		return nil
	}
	return c.CardBrand
}

func (c *CardDetails) GetCardFunding() *CardFunding {
	if c == nil {
		return nil
	}
	return c.CardFunding
}

func (c *CardDetails) GetCardAuthenticated() *bool {
	if c == nil {
		return nil
	}
	return c.CardAuthenticated
}

func (c *CardDetails) GetCardTokenized() *bool {
	if c == nil {
		return nil
	}
	return c.CardTokenized
}

func (c *CardDetails) GetCardPresent() *bool {
	if c == nil {
		return nil
	}
	return c.CardPresent
}

func (c *CardDetails) GetPaymentChannel() *string {
	if c == nil {
		return nil
	}
	return c.PaymentChannel
}

func (c *CardDetails) GetCardType() *CardType {
	if c == nil {
		return nil
	}
	return c.CardType
}

func (c *CardDetails) GetCardBalance() *Amount {
	if c == nil {
		return nil
	}
	return c.CardBalance
}

func (c *CardDetails) GetMerchantDetails() *CardMerchantDetails {
	if c == nil {
		return nil
	}
	return c.MerchantDetails
}

func (c *CardDetails) GetNetworkProviderRiskScore() *float64 {
	if c == nil {
		return nil
	}
	return c.NetworkProviderRiskScore
}

func (c *CardDetails) GetTags() []*Tag {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *CardDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardExpiry struct {
	Month *float64 `json:"month,omitempty" url:"month,omitempty"`
	Year  *float64 `json:"year,omitempty" url:"year,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardExpiry) GetMonth() *float64 {
	if c == nil {
		return nil
	}
	return c.Month
}

func (c *CardExpiry) GetYear() *float64 {
	if c == nil {
		return nil
	}
	return c.Year
}

func (c *CardExpiry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardExpiry) UnmarshalJSON(data []byte) error {
	type unmarshaler CardExpiry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardExpiry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardExpiry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Funding of Card
type CardFunding string

const (
	CardFundingCredit  CardFunding = "CREDIT"
	CardFundingDebit   CardFunding = "DEBIT"
	CardFundingPrepaid CardFunding = "PREPAID"
)

func NewCardFundingFromString(s string) (CardFunding, error) {
	switch s {
	case "CREDIT":
		return CardFundingCredit, nil
	case "DEBIT":
		return CardFundingDebit, nil
	case "PREPAID":
		return CardFundingPrepaid, nil
	}
	var t CardFunding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardFunding) Ptr() *CardFunding {
	return &c
}

type CardMerchantDetails struct {
	Id       *string      `json:"id,omitempty" url:"id,omitempty"`
	Name     *string      `json:"name,omitempty" url:"name,omitempty"`
	Category *string      `json:"category,omitempty" url:"category,omitempty"`
	Mcc      *string      `json:"MCC,omitempty" url:"MCC,omitempty"`
	City     *string      `json:"city,omitempty" url:"city,omitempty"`
	Country  *CountryCode `json:"country,omitempty" url:"country,omitempty"`
	State    *string      `json:"state,omitempty" url:"state,omitempty"`
	PostCode *string      `json:"postCode,omitempty" url:"postCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardMerchantDetails) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *CardMerchantDetails) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CardMerchantDetails) GetCategory() *string {
	if c == nil {
		return nil
	}
	return c.Category
}

func (c *CardMerchantDetails) GetMcc() *string {
	if c == nil {
		return nil
	}
	return c.Mcc
}

func (c *CardMerchantDetails) GetCity() *string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CardMerchantDetails) GetCountry() *CountryCode {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CardMerchantDetails) GetState() *string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CardMerchantDetails) GetPostCode() *string {
	if c == nil {
		return nil
	}
	return c.PostCode
}

func (c *CardMerchantDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardMerchantDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CardMerchantDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardMerchantDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardMerchantDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Classify the method of payment as "Card" for CardDetails
type CardPaymentMethod = string

// Status of the card
type CardStatus string

const (
	CardStatusActive         CardStatus = "ACTIVE"
	CardStatusFrozen         CardStatus = "FROZEN"
	CardStatusBlocked        CardStatus = "BLOCKED"
	CardStatusSuspectedFraud CardStatus = "SUSPECTED_FRAUD"
	CardStatusStolen         CardStatus = "STOLEN"
	CardStatusLost           CardStatus = "LOST"
	CardStatusClosed         CardStatus = "CLOSED"
	CardStatusOther          CardStatus = "OTHER"
)

func NewCardStatusFromString(s string) (CardStatus, error) {
	switch s {
	case "ACTIVE":
		return CardStatusActive, nil
	case "FROZEN":
		return CardStatusFrozen, nil
	case "BLOCKED":
		return CardStatusBlocked, nil
	case "SUSPECTED_FRAUD":
		return CardStatusSuspectedFraud, nil
	case "STOLEN":
		return CardStatusStolen, nil
	case "LOST":
		return CardStatusLost, nil
	case "CLOSED":
		return CardStatusClosed, nil
	case "OTHER":
		return CardStatusOther, nil
	}
	var t CardStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardStatus) Ptr() *CardStatus {
	return &c
}

// Type of card
type CardType string

const (
	CardTypeVirtual  CardType = "VIRTUAL"
	CardTypePhysical CardType = "PHYSICAL"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "VIRTUAL":
		return CardTypeVirtual, nil
	case "PHYSICAL":
		return CardTypePhysical, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

type CaseClosedDetails struct {
	CaseId                    *string  `json:"caseId,omitempty" url:"caseId,omitempty"`
	Status                    *string  `json:"status,omitempty" url:"status,omitempty"`
	Reasons                   []string `json:"reasons,omitempty" url:"reasons,omitempty"`
	ReasonDescriptionForOther *string  `json:"reasonDescriptionForOther,omitempty" url:"reasonDescriptionForOther,omitempty"`
	Comment                   *string  `json:"comment,omitempty" url:"comment,omitempty"`
	UserId                    *string  `json:"userId,omitempty" url:"userId,omitempty"`
	TransactionIds            []string `json:"transactionIds,omitempty" url:"transactionIds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CaseClosedDetails) GetCaseId() *string {
	if c == nil {
		return nil
	}
	return c.CaseId
}

func (c *CaseClosedDetails) GetStatus() *string {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CaseClosedDetails) GetReasons() []string {
	if c == nil {
		return nil
	}
	return c.Reasons
}

func (c *CaseClosedDetails) GetReasonDescriptionForOther() *string {
	if c == nil {
		return nil
	}
	return c.ReasonDescriptionForOther
}

func (c *CaseClosedDetails) GetComment() *string {
	if c == nil {
		return nil
	}
	return c.Comment
}

func (c *CaseClosedDetails) GetUserId() *string {
	if c == nil {
		return nil
	}
	return c.UserId
}

func (c *CaseClosedDetails) GetTransactionIds() []string {
	if c == nil {
		return nil
	}
	return c.TransactionIds
}

func (c *CaseClosedDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaseClosedDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CaseClosedDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaseClosedDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaseClosedDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Model for case management events
type CaseManagementEvent struct {
	// Status of a case. E.g. Open, Closed etc.
	CaseStatus CaseManagementEventCaseStatus `json:"caseStatus" url:"caseStatus"`
	// Timestamp of the event
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// Case status reason. E.g. Closed & False Positive, Closed & Investigation Completed etc.
	CaseStatusReason CaseManagementEventCaseStatusReason `json:"caseStatusReason" url:"caseStatusReason"`
	// Transaction ID the case pertains to
	TransactionId *string `json:"transactionId,omitempty" url:"transactionId,omitempty"`
	// User ID the case pertains to
	UserId *string `json:"userId,omitempty" url:"userId,omitempty"`
	// Event ID the case pertains to
	EventId *string `json:"eventId,omitempty" url:"eventId,omitempty"`
	// Case status reason description
	CaseStatusReasonDescription *string `json:"caseStatusReasonDescription,omitempty" url:"caseStatusReasonDescription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CaseManagementEvent) GetCaseStatus() CaseManagementEventCaseStatus {
	if c == nil {
		return ""
	}
	return c.CaseStatus
}

func (c *CaseManagementEvent) GetTimestamp() float64 {
	if c == nil {
		return 0
	}
	return c.Timestamp
}

func (c *CaseManagementEvent) GetCaseStatusReason() CaseManagementEventCaseStatusReason {
	if c == nil {
		return ""
	}
	return c.CaseStatusReason
}

func (c *CaseManagementEvent) GetTransactionId() *string {
	if c == nil {
		return nil
	}
	return c.TransactionId
}

func (c *CaseManagementEvent) GetUserId() *string {
	if c == nil {
		return nil
	}
	return c.UserId
}

func (c *CaseManagementEvent) GetEventId() *string {
	if c == nil {
		return nil
	}
	return c.EventId
}

func (c *CaseManagementEvent) GetCaseStatusReasonDescription() *string {
	if c == nil {
		return nil
	}
	return c.CaseStatusReasonDescription
}

func (c *CaseManagementEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaseManagementEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CaseManagementEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaseManagementEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaseManagementEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Status of a case. E.g. Open, Closed etc.
type CaseManagementEventCaseStatus string

const (
	CaseManagementEventCaseStatusClosed CaseManagementEventCaseStatus = "CLOSED"
	CaseManagementEventCaseStatusHit    CaseManagementEventCaseStatus = "HIT"
)

func NewCaseManagementEventCaseStatusFromString(s string) (CaseManagementEventCaseStatus, error) {
	switch s {
	case "CLOSED":
		return CaseManagementEventCaseStatusClosed, nil
	case "HIT":
		return CaseManagementEventCaseStatusHit, nil
	}
	var t CaseManagementEventCaseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CaseManagementEventCaseStatus) Ptr() *CaseManagementEventCaseStatus {
	return &c
}

// Case status reason. E.g. Closed & False Positive, Closed & Investigation Completed etc.
type CaseManagementEventCaseStatusReason string

const (
	CaseManagementEventCaseStatusReasonFalsePositive          CaseManagementEventCaseStatusReason = "FALSE_POSITIVE"
	CaseManagementEventCaseStatusReasonInvestigationCompleted CaseManagementEventCaseStatusReason = "INVESTIGATION_COMPLETED"
	CaseManagementEventCaseStatusReasonDocumentsCollected     CaseManagementEventCaseStatusReason = "DOCUMENTS_COLLECTED"
	CaseManagementEventCaseStatusReasonOther                  CaseManagementEventCaseStatusReason = "OTHER"
)

func NewCaseManagementEventCaseStatusReasonFromString(s string) (CaseManagementEventCaseStatusReason, error) {
	switch s {
	case "FALSE_POSITIVE":
		return CaseManagementEventCaseStatusReasonFalsePositive, nil
	case "INVESTIGATION_COMPLETED":
		return CaseManagementEventCaseStatusReasonInvestigationCompleted, nil
	case "DOCUMENTS_COLLECTED":
		return CaseManagementEventCaseStatusReasonDocumentsCollected, nil
	case "OTHER":
		return CaseManagementEventCaseStatusReasonOther, nil
	}
	var t CaseManagementEventCaseStatusReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CaseManagementEventCaseStatusReason) Ptr() *CaseManagementEventCaseStatusReason {
	return &c
}

type CaseOpenedDetails struct {
	CaseId         *string  `json:"caseId,omitempty" url:"caseId,omitempty"`
	Status         *string  `json:"status,omitempty" url:"status,omitempty"`
	UserId         *string  `json:"userId,omitempty" url:"userId,omitempty"`
	TransactionIds []string `json:"transactionIds,omitempty" url:"transactionIds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CaseOpenedDetails) GetCaseId() *string {
	if c == nil {
		return nil
	}
	return c.CaseId
}

func (c *CaseOpenedDetails) GetStatus() *string {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CaseOpenedDetails) GetUserId() *string {
	if c == nil {
		return nil
	}
	return c.UserId
}

func (c *CaseOpenedDetails) GetTransactionIds() []string {
	if c == nil {
		return nil
	}
	return c.TransactionIds
}

func (c *CaseOpenedDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaseOpenedDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CaseOpenedDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaseOpenedDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaseOpenedDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CashDetails struct {
	// Identifier for the cash transaction
	Identifier *string `json:"identifier,omitempty" url:"identifier,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CashDetails) GetIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.Identifier
}

func (c *CashDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Classify the method of payment as "CASH" for Details
type CashPaymentMethod = string

type CheckDeliveryStatus string

const (
	CheckDeliveryStatusCompleted CheckDeliveryStatus = "COMPLETED"
	CheckDeliveryStatusPending   CheckDeliveryStatus = "PENDING"
	CheckDeliveryStatusSettled   CheckDeliveryStatus = "SETTLED"
	CheckDeliveryStatusCanceled  CheckDeliveryStatus = "CANCELED"
	CheckDeliveryStatusRefund    CheckDeliveryStatus = "REFUND"
	CheckDeliveryStatusDeclined  CheckDeliveryStatus = "DECLINED"
)

func NewCheckDeliveryStatusFromString(s string) (CheckDeliveryStatus, error) {
	switch s {
	case "COMPLETED":
		return CheckDeliveryStatusCompleted, nil
	case "PENDING":
		return CheckDeliveryStatusPending, nil
	case "SETTLED":
		return CheckDeliveryStatusSettled, nil
	case "CANCELED":
		return CheckDeliveryStatusCanceled, nil
	case "REFUND":
		return CheckDeliveryStatusRefund, nil
	case "DECLINED":
		return CheckDeliveryStatusDeclined, nil
	}
	var t CheckDeliveryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckDeliveryStatus) Ptr() *CheckDeliveryStatus {
	return &c
}

type CheckDetails struct {
	CheckNumber     *string              `json:"checkNumber,omitempty" url:"checkNumber,omitempty"`
	CheckIdentifier *string              `json:"checkIdentifier,omitempty" url:"checkIdentifier,omitempty"`
	Name            *string              `json:"name,omitempty" url:"name,omitempty"`
	DeliveryStatus  *CheckDeliveryStatus `json:"deliveryStatus,omitempty" url:"deliveryStatus,omitempty"`
	EtaTimestamp    *float64             `json:"etaTimestamp,omitempty" url:"etaTimestamp,omitempty"`
	ShippingAddress *Address             `json:"shippingAddress,omitempty" url:"shippingAddress,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CheckDetails) GetCheckNumber() *string {
	if c == nil {
		return nil
	}
	return c.CheckNumber
}

func (c *CheckDetails) GetCheckIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.CheckIdentifier
}

func (c *CheckDetails) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CheckDetails) GetDeliveryStatus() *CheckDeliveryStatus {
	if c == nil {
		return nil
	}
	return c.DeliveryStatus
}

func (c *CheckDetails) GetEtaTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.EtaTimestamp
}

func (c *CheckDetails) GetShippingAddress() *Address {
	if c == nil {
		return nil
	}
	return c.ShippingAddress
}

func (c *CheckDetails) GetTags() []*Tag {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *CheckDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Classify the method of payment as "CHECK" for CheckDetails
type CheckPaymentMethod = string

type ColumnType string

const (
	ColumnTypeString ColumnType = "STRING"
	ColumnTypeNumber ColumnType = "NUMBER"
	ColumnTypeDate   ColumnType = "DATE"
)

func NewColumnTypeFromString(s string) (ColumnType, error) {
	switch s {
	case "STRING":
		return ColumnTypeString, nil
	case "NUMBER":
		return ColumnTypeNumber, nil
	case "DATE":
		return ColumnTypeDate, nil
	}
	var t ColumnType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ColumnType) Ptr() *ColumnType {
	return &c
}

// Model for business user company financial details
type CompanyFinancialDetails struct {
	ExpectedTransactionAmountPerMonth *Amount `json:"expectedTransactionAmountPerMonth,omitempty" url:"expectedTransactionAmountPerMonth,omitempty"`
	ExpectedTurnoverPerMonth          *Amount `json:"expectedTurnoverPerMonth,omitempty" url:"expectedTurnoverPerMonth,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CompanyFinancialDetails) GetExpectedTransactionAmountPerMonth() *Amount {
	if c == nil {
		return nil
	}
	return c.ExpectedTransactionAmountPerMonth
}

func (c *CompanyFinancialDetails) GetExpectedTurnoverPerMonth() *Amount {
	if c == nil {
		return nil
	}
	return c.ExpectedTurnoverPerMonth
}

func (c *CompanyFinancialDetails) GetTags() []*Tag {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *CompanyFinancialDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompanyFinancialDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyFinancialDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyFinancialDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyFinancialDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Model for business user company general details
type CompanyGeneralDetails struct {
	// Legal name of the company
	LegalName *string `json:"legalName,omitempty" url:"legalName,omitempty"`
	// The industry in which the business operates for a business customer
	BusinessIndustry []string `json:"businessIndustry,omitempty" url:"businessIndustry,omitempty"`
	// The key products and services provided by the company
	MainProductsServicesSold []string `json:"mainProductsServicesSold,omitempty" url:"mainProductsServicesSold,omitempty"`
	// Segmentation of the business user
	UserSegment            *BusinessUserSegment    `json:"userSegment,omitempty" url:"userSegment,omitempty"`
	UserRegistrationStatus *UserRegistrationStatus `json:"userRegistrationStatus,omitempty" url:"userRegistrationStatus,omitempty"`
	// Countries where the business operates
	OperatingCountries []CountryCode `json:"operatingCountries,omitempty" url:"operatingCountries,omitempty"`
	// Alias names of the business entity
	Alias []string `json:"alias,omitempty" url:"alias,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CompanyGeneralDetails) GetLegalName() *string {
	if c == nil {
		return nil
	}
	return c.LegalName
}

func (c *CompanyGeneralDetails) GetBusinessIndustry() []string {
	if c == nil {
		return nil
	}
	return c.BusinessIndustry
}

func (c *CompanyGeneralDetails) GetMainProductsServicesSold() []string {
	if c == nil {
		return nil
	}
	return c.MainProductsServicesSold
}

func (c *CompanyGeneralDetails) GetUserSegment() *BusinessUserSegment {
	if c == nil {
		return nil
	}
	return c.UserSegment
}

func (c *CompanyGeneralDetails) GetUserRegistrationStatus() *UserRegistrationStatus {
	if c == nil {
		return nil
	}
	return c.UserRegistrationStatus
}

func (c *CompanyGeneralDetails) GetOperatingCountries() []CountryCode {
	if c == nil {
		return nil
	}
	return c.OperatingCountries
}

func (c *CompanyGeneralDetails) GetAlias() []string {
	if c == nil {
		return nil
	}
	return c.Alias
}

func (c *CompanyGeneralDetails) GetTags() []*Tag {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *CompanyGeneralDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompanyGeneralDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyGeneralDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyGeneralDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyGeneralDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Model for business user company registration details
type CompanyRegistrationDetails struct {
	// Commercial registry registration number for the company in its registration country
	RegistrationIdentifier string       `json:"registrationIdentifier" url:"registrationIdentifier"`
	RegistrationCountry    CountryCode  `json:"registrationCountry" url:"registrationCountry"`
	TaxResidenceCountry    *CountryCode `json:"taxResidenceCountry,omitempty" url:"taxResidenceCountry,omitempty"`
	// Tax ID number of the registered entity
	TaxIdentifier *string `json:"taxIdentifier,omitempty" url:"taxIdentifier,omitempty"`
	// Type of legal entity, e.g., Limited Liability
	LegalEntityType    *string `json:"legalEntityType,omitempty" url:"legalEntityType,omitempty"`
	DateOfRegistration *string `json:"dateOfRegistration,omitempty" url:"dateOfRegistration,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CompanyRegistrationDetails) GetRegistrationIdentifier() string {
	if c == nil {
		return ""
	}
	return c.RegistrationIdentifier
}

func (c *CompanyRegistrationDetails) GetRegistrationCountry() CountryCode {
	if c == nil {
		return ""
	}
	return c.RegistrationCountry
}

func (c *CompanyRegistrationDetails) GetTaxResidenceCountry() *CountryCode {
	if c == nil {
		return nil
	}
	return c.TaxResidenceCountry
}

func (c *CompanyRegistrationDetails) GetTaxIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.TaxIdentifier
}

func (c *CompanyRegistrationDetails) GetLegalEntityType() *string {
	if c == nil {
		return nil
	}
	return c.LegalEntityType
}

func (c *CompanyRegistrationDetails) GetDateOfRegistration() *string {
	if c == nil {
		return nil
	}
	return c.DateOfRegistration
}

func (c *CompanyRegistrationDetails) GetTags() []*Tag {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *CompanyRegistrationDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompanyRegistrationDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyRegistrationDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyRegistrationDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyRegistrationDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Model for a generic consumer name
type ConsumerName struct {
	// First name of the user
	FirstName string `json:"firstName" url:"firstName"`
	// Middle name of the user
	MiddleName *string `json:"middleName,omitempty" url:"middleName,omitempty"`
	// Last name of the user
	LastName *string `json:"lastName,omitempty" url:"lastName,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConsumerName) GetFirstName() string {
	if c == nil {
		return ""
	}
	return c.FirstName
}

func (c *ConsumerName) GetMiddleName() *string {
	if c == nil {
		return nil
	}
	return c.MiddleName
}

func (c *ConsumerName) GetLastName() *string {
	if c == nil {
		return nil
	}
	return c.LastName
}

func (c *ConsumerName) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConsumerName) UnmarshalJSON(data []byte) error {
	type unmarshaler ConsumerName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConsumerName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConsumerName) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Model for consumer user-related events
type ConsumerUserEvent struct {
	// Timestamp of the event
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// Transaction ID the event pertains to
	UserId string `json:"userId" url:"userId"`
	// Unique event ID
	EventId *string `json:"eventId,omitempty" url:"eventId,omitempty"`
	// Reason for the event or a state change
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// Event description
	EventDescription              *string       `json:"eventDescription,omitempty" url:"eventDescription,omitempty"`
	UpdatedConsumerUserAttributes *UserOptional `json:"updatedConsumerUserAttributes,omitempty" url:"updatedConsumerUserAttributes,omitempty"`
	UpdateCount                   *float64      `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConsumerUserEvent) GetTimestamp() float64 {
	if c == nil {
		return 0
	}
	return c.Timestamp
}

func (c *ConsumerUserEvent) GetUserId() string {
	if c == nil {
		return ""
	}
	return c.UserId
}

func (c *ConsumerUserEvent) GetEventId() *string {
	if c == nil {
		return nil
	}
	return c.EventId
}

func (c *ConsumerUserEvent) GetReason() *string {
	if c == nil {
		return nil
	}
	return c.Reason
}

func (c *ConsumerUserEvent) GetEventDescription() *string {
	if c == nil {
		return nil
	}
	return c.EventDescription
}

func (c *ConsumerUserEvent) GetUpdatedConsumerUserAttributes() *UserOptional {
	if c == nil {
		return nil
	}
	return c.UpdatedConsumerUserAttributes
}

func (c *ConsumerUserEvent) GetUpdateCount() *float64 {
	if c == nil {
		return nil
	}
	return c.UpdateCount
}

func (c *ConsumerUserEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConsumerUserEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ConsumerUserEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConsumerUserEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConsumerUserEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConsumerUserSegment string

const (
	ConsumerUserSegmentRetail       ConsumerUserSegment = "RETAIL"
	ConsumerUserSegmentProfessional ConsumerUserSegment = "PROFESSIONAL"
)

func NewConsumerUserSegmentFromString(s string) (ConsumerUserSegment, error) {
	switch s {
	case "RETAIL":
		return ConsumerUserSegmentRetail, nil
	case "PROFESSIONAL":
		return ConsumerUserSegmentProfessional, nil
	}
	var t ConsumerUserSegment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsumerUserSegment) Ptr() *ConsumerUserSegment {
	return &c
}

// Model for business user contact information details
type ContactDetails struct {
	// Email addresses of the contacts for a given business customer
	EmailIds []string `json:"emailIds,omitempty" url:"emailIds,omitempty"`
	// Phone numbers to contact a given business customer
	ContactNumbers []string `json:"contactNumbers,omitempty" url:"contactNumbers,omitempty"`
	// Fax numbers to contact a business customer
	FaxNumbers []string `json:"faxNumbers,omitempty" url:"faxNumbers,omitempty"`
	// Website of the company
	Websites []string `json:"websites,omitempty" url:"websites,omitempty"`
	// Address(es) of the company
	Addresses []*Address    `json:"addresses,omitempty" url:"addresses,omitempty"`
	Name      *ConsumerName `json:"name,omitempty" url:"name,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContactDetails) GetEmailIds() []string {
	if c == nil {
		return nil
	}
	return c.EmailIds
}

func (c *ContactDetails) GetContactNumbers() []string {
	if c == nil {
		return nil
	}
	return c.ContactNumbers
}

func (c *ContactDetails) GetFaxNumbers() []string {
	if c == nil {
		return nil
	}
	return c.FaxNumbers
}

func (c *ContactDetails) GetWebsites() []string {
	if c == nil {
		return nil
	}
	return c.Websites
}

func (c *ContactDetails) GetAddresses() []*Address {
	if c == nil {
		return nil
	}
	return c.Addresses
}

func (c *ContactDetails) GetName() *ConsumerName {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContactDetails) GetTags() []*Tag {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ContactDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContactDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CountryCode string

const (
	CountryCodeAf            CountryCode = "AF"
	CountryCodeAl            CountryCode = "AL"
	CountryCodeDz            CountryCode = "DZ"
	CountryCodeAs            CountryCode = "AS"
	CountryCodeAd            CountryCode = "AD"
	CountryCodeAo            CountryCode = "AO"
	CountryCodeAi            CountryCode = "AI"
	CountryCodeAq            CountryCode = "AQ"
	CountryCodeAg            CountryCode = "AG"
	CountryCodeAr            CountryCode = "AR"
	CountryCodeAm            CountryCode = "AM"
	CountryCodeAw            CountryCode = "AW"
	CountryCodeAu            CountryCode = "AU"
	CountryCodeAt            CountryCode = "AT"
	CountryCodeAz            CountryCode = "AZ"
	CountryCodeBs            CountryCode = "BS"
	CountryCodeBh            CountryCode = "BH"
	CountryCodeBd            CountryCode = "BD"
	CountryCodeBb            CountryCode = "BB"
	CountryCodeBy            CountryCode = "BY"
	CountryCodeBe            CountryCode = "BE"
	CountryCodeBz            CountryCode = "BZ"
	CountryCodeBj            CountryCode = "BJ"
	CountryCodeBm            CountryCode = "BM"
	CountryCodeBt            CountryCode = "BT"
	CountryCodeBo            CountryCode = "BO"
	CountryCodeBq            CountryCode = "BQ"
	CountryCodeBa            CountryCode = "BA"
	CountryCodeBw            CountryCode = "BW"
	CountryCodeBv            CountryCode = "BV"
	CountryCodeBr            CountryCode = "BR"
	CountryCodeIo            CountryCode = "IO"
	CountryCodeBn            CountryCode = "BN"
	CountryCodeBg            CountryCode = "BG"
	CountryCodeBf            CountryCode = "BF"
	CountryCodeBi            CountryCode = "BI"
	CountryCodeCv            CountryCode = "CV"
	CountryCodeKh            CountryCode = "KH"
	CountryCodeCm            CountryCode = "CM"
	CountryCodeCa            CountryCode = "CA"
	CountryCodeKy            CountryCode = "KY"
	CountryCodeCf            CountryCode = "CF"
	CountryCodeTd            CountryCode = "TD"
	CountryCodeCl            CountryCode = "CL"
	CountryCodeCn            CountryCode = "CN"
	CountryCodeCx            CountryCode = "CX"
	CountryCodeCc            CountryCode = "CC"
	CountryCodeCo            CountryCode = "CO"
	CountryCodeKm            CountryCode = "KM"
	CountryCodeCd            CountryCode = "CD"
	CountryCodeCg            CountryCode = "CG"
	CountryCodeCk            CountryCode = "CK"
	CountryCodeCr            CountryCode = "CR"
	CountryCodeHr            CountryCode = "HR"
	CountryCodeCu            CountryCode = "CU"
	CountryCodeCw            CountryCode = "CW"
	CountryCodeCy            CountryCode = "CY"
	CountryCodeCz            CountryCode = "CZ"
	CountryCodeCi            CountryCode = "CI"
	CountryCodeDk            CountryCode = "DK"
	CountryCodeDj            CountryCode = "DJ"
	CountryCodeDm            CountryCode = "DM"
	CountryCodeDo            CountryCode = "DO"
	CountryCodeEc            CountryCode = "EC"
	CountryCodeEg            CountryCode = "EG"
	CountryCodeSv            CountryCode = "SV"
	CountryCodeGq            CountryCode = "GQ"
	CountryCodeEr            CountryCode = "ER"
	CountryCodeEe            CountryCode = "EE"
	CountryCodeSz            CountryCode = "SZ"
	CountryCodeEt            CountryCode = "ET"
	CountryCodeFk            CountryCode = "FK"
	CountryCodeFo            CountryCode = "FO"
	CountryCodeFj            CountryCode = "FJ"
	CountryCodeFi            CountryCode = "FI"
	CountryCodeFr            CountryCode = "FR"
	CountryCodeGf            CountryCode = "GF"
	CountryCodePf            CountryCode = "PF"
	CountryCodeTf            CountryCode = "TF"
	CountryCodeGa            CountryCode = "GA"
	CountryCodeGm            CountryCode = "GM"
	CountryCodeGe            CountryCode = "GE"
	CountryCodeDe            CountryCode = "DE"
	CountryCodeGh            CountryCode = "GH"
	CountryCodeGi            CountryCode = "GI"
	CountryCodeGr            CountryCode = "GR"
	CountryCodeGl            CountryCode = "GL"
	CountryCodeGd            CountryCode = "GD"
	CountryCodeGp            CountryCode = "GP"
	CountryCodeGu            CountryCode = "GU"
	CountryCodeGt            CountryCode = "GT"
	CountryCodeGg            CountryCode = "GG"
	CountryCodeGn            CountryCode = "GN"
	CountryCodeGw            CountryCode = "GW"
	CountryCodeGy            CountryCode = "GY"
	CountryCodeHt            CountryCode = "HT"
	CountryCodeHm            CountryCode = "HM"
	CountryCodeVa            CountryCode = "VA"
	CountryCodeHn            CountryCode = "HN"
	CountryCodeHk            CountryCode = "HK"
	CountryCodeHu            CountryCode = "HU"
	CountryCodeIs            CountryCode = "IS"
	CountryCodeIn            CountryCode = "IN"
	CountryCodeId            CountryCode = "ID"
	CountryCodeIr            CountryCode = "IR"
	CountryCodeIq            CountryCode = "IQ"
	CountryCodeIe            CountryCode = "IE"
	CountryCodeIm            CountryCode = "IM"
	CountryCodeIl            CountryCode = "IL"
	CountryCodeIt            CountryCode = "IT"
	CountryCodeJm            CountryCode = "JM"
	CountryCodeJp            CountryCode = "JP"
	CountryCodeJe            CountryCode = "JE"
	CountryCodeJo            CountryCode = "JO"
	CountryCodeKz            CountryCode = "KZ"
	CountryCodeKe            CountryCode = "KE"
	CountryCodeKi            CountryCode = "KI"
	CountryCodeKp            CountryCode = "KP"
	CountryCodeKr            CountryCode = "KR"
	CountryCodeKw            CountryCode = "KW"
	CountryCodeKg            CountryCode = "KG"
	CountryCodeLa            CountryCode = "LA"
	CountryCodeLv            CountryCode = "LV"
	CountryCodeLb            CountryCode = "LB"
	CountryCodeLs            CountryCode = "LS"
	CountryCodeLr            CountryCode = "LR"
	CountryCodeLy            CountryCode = "LY"
	CountryCodeLi            CountryCode = "LI"
	CountryCodeLt            CountryCode = "LT"
	CountryCodeLu            CountryCode = "LU"
	CountryCodeMo            CountryCode = "MO"
	CountryCodeMg            CountryCode = "MG"
	CountryCodeMw            CountryCode = "MW"
	CountryCodeMy            CountryCode = "MY"
	CountryCodeMv            CountryCode = "MV"
	CountryCodeMl            CountryCode = "ML"
	CountryCodeMt            CountryCode = "MT"
	CountryCodeMh            CountryCode = "MH"
	CountryCodeMq            CountryCode = "MQ"
	CountryCodeMr            CountryCode = "MR"
	CountryCodeMu            CountryCode = "MU"
	CountryCodeYt            CountryCode = "YT"
	CountryCodeMx            CountryCode = "MX"
	CountryCodeFm            CountryCode = "FM"
	CountryCodeMd            CountryCode = "MD"
	CountryCodeMc            CountryCode = "MC"
	CountryCodeMn            CountryCode = "MN"
	CountryCodeMe            CountryCode = "ME"
	CountryCodeMs            CountryCode = "MS"
	CountryCodeMa            CountryCode = "MA"
	CountryCodeMz            CountryCode = "MZ"
	CountryCodeMm            CountryCode = "MM"
	CountryCodeNa            CountryCode = "NA"
	CountryCodeNr            CountryCode = "NR"
	CountryCodeNp            CountryCode = "NP"
	CountryCodeNl            CountryCode = "NL"
	CountryCodeNc            CountryCode = "NC"
	CountryCodeNz            CountryCode = "NZ"
	CountryCodeNi            CountryCode = "NI"
	CountryCodeNe            CountryCode = "NE"
	CountryCodeNg            CountryCode = "NG"
	CountryCodeNu            CountryCode = "NU"
	CountryCodeNf            CountryCode = "NF"
	CountryCodeMk            CountryCode = "MK"
	CountryCodeMp            CountryCode = "MP"
	CountryCodeNo            CountryCode = "NO"
	CountryCodeOm            CountryCode = "OM"
	CountryCodePk            CountryCode = "PK"
	CountryCodePw            CountryCode = "PW"
	CountryCodePs            CountryCode = "PS"
	CountryCodePa            CountryCode = "PA"
	CountryCodePg            CountryCode = "PG"
	CountryCodePy            CountryCode = "PY"
	CountryCodePe            CountryCode = "PE"
	CountryCodePh            CountryCode = "PH"
	CountryCodePn            CountryCode = "PN"
	CountryCodePl            CountryCode = "PL"
	CountryCodePt            CountryCode = "PT"
	CountryCodePr            CountryCode = "PR"
	CountryCodeQa            CountryCode = "QA"
	CountryCodeRo            CountryCode = "RO"
	CountryCodeRu            CountryCode = "RU"
	CountryCodeRw            CountryCode = "RW"
	CountryCodeRe            CountryCode = "RE"
	CountryCodeBl            CountryCode = "BL"
	CountryCodeSh            CountryCode = "SH"
	CountryCodeKn            CountryCode = "KN"
	CountryCodeLc            CountryCode = "LC"
	CountryCodeMf            CountryCode = "MF"
	CountryCodePm            CountryCode = "PM"
	CountryCodeVc            CountryCode = "VC"
	CountryCodeWs            CountryCode = "WS"
	CountryCodeSm            CountryCode = "SM"
	CountryCodeSt            CountryCode = "ST"
	CountryCodeSa            CountryCode = "SA"
	CountryCodeSn            CountryCode = "SN"
	CountryCodeRs            CountryCode = "RS"
	CountryCodeSc            CountryCode = "SC"
	CountryCodeSl            CountryCode = "SL"
	CountryCodeSg            CountryCode = "SG"
	CountryCodeSx            CountryCode = "SX"
	CountryCodeSk            CountryCode = "SK"
	CountryCodeSi            CountryCode = "SI"
	CountryCodeSb            CountryCode = "SB"
	CountryCodeSo            CountryCode = "SO"
	CountryCodeZa            CountryCode = "ZA"
	CountryCodeGs            CountryCode = "GS"
	CountryCodeSs            CountryCode = "SS"
	CountryCodeEs            CountryCode = "ES"
	CountryCodeLk            CountryCode = "LK"
	CountryCodeSd            CountryCode = "SD"
	CountryCodeSr            CountryCode = "SR"
	CountryCodeSj            CountryCode = "SJ"
	CountryCodeSe            CountryCode = "SE"
	CountryCodeCh            CountryCode = "CH"
	CountryCodeSy            CountryCode = "SY"
	CountryCodeTw            CountryCode = "TW"
	CountryCodeTj            CountryCode = "TJ"
	CountryCodeTz            CountryCode = "TZ"
	CountryCodeTh            CountryCode = "TH"
	CountryCodeTl            CountryCode = "TL"
	CountryCodeTg            CountryCode = "TG"
	CountryCodeTk            CountryCode = "TK"
	CountryCodeTo            CountryCode = "TO"
	CountryCodeTt            CountryCode = "TT"
	CountryCodeTn            CountryCode = "TN"
	CountryCodeTm            CountryCode = "TM"
	CountryCodeTc            CountryCode = "TC"
	CountryCodeTv            CountryCode = "TV"
	CountryCodeTr            CountryCode = "TR"
	CountryCodeUg            CountryCode = "UG"
	CountryCodeUa            CountryCode = "UA"
	CountryCodeAe            CountryCode = "AE"
	CountryCodeGb            CountryCode = "GB"
	CountryCodeUm            CountryCode = "UM"
	CountryCodeUs            CountryCode = "US"
	CountryCodeUy            CountryCode = "UY"
	CountryCodeUz            CountryCode = "UZ"
	CountryCodeVu            CountryCode = "VU"
	CountryCodeVe            CountryCode = "VE"
	CountryCodeVn            CountryCode = "VN"
	CountryCodeVg            CountryCode = "VG"
	CountryCodeVi            CountryCode = "VI"
	CountryCodeWf            CountryCode = "WF"
	CountryCodeEh            CountryCode = "EH"
	CountryCodeYe            CountryCode = "YE"
	CountryCodeZm            CountryCode = "ZM"
	CountryCodeZw            CountryCode = "ZW"
	CountryCodeAx            CountryCode = "AX"
	CountryCodeXa            CountryCode = "XA"
	CountryCodeXb            CountryCode = "XB"
	CountryCodeXc            CountryCode = "XC"
	CountryCodeXd            CountryCode = "XD"
	CountryCodeXe            CountryCode = "XE"
	CountryCodeXf            CountryCode = "XF"
	CountryCodeXg            CountryCode = "XG"
	CountryCodeXh            CountryCode = "XH"
	CountryCodeXi            CountryCode = "XI"
	CountryCodeXj            CountryCode = "XJ"
	CountryCodeXk            CountryCode = "XK"
	CountryCodeXl            CountryCode = "XL"
	CountryCodeXm            CountryCode = "XM"
	CountryCodeXn            CountryCode = "XN"
	CountryCodeXo            CountryCode = "XO"
	CountryCodeXp            CountryCode = "XP"
	CountryCodeXq            CountryCode = "XQ"
	CountryCodeXr            CountryCode = "XR"
	CountryCodeXs            CountryCode = "XS"
	CountryCodeXt            CountryCode = "XT"
	CountryCodeXu            CountryCode = "XU"
	CountryCodeXv            CountryCode = "XV"
	CountryCodeXw            CountryCode = "XW"
	CountryCodeXy            CountryCode = "XY"
	CountryCodeXz            CountryCode = "XZ"
	CountryCodeNotApplicable CountryCode = "N/A"
)

func NewCountryCodeFromString(s string) (CountryCode, error) {
	switch s {
	case "AF":
		return CountryCodeAf, nil
	case "AL":
		return CountryCodeAl, nil
	case "DZ":
		return CountryCodeDz, nil
	case "AS":
		return CountryCodeAs, nil
	case "AD":
		return CountryCodeAd, nil
	case "AO":
		return CountryCodeAo, nil
	case "AI":
		return CountryCodeAi, nil
	case "AQ":
		return CountryCodeAq, nil
	case "AG":
		return CountryCodeAg, nil
	case "AR":
		return CountryCodeAr, nil
	case "AM":
		return CountryCodeAm, nil
	case "AW":
		return CountryCodeAw, nil
	case "AU":
		return CountryCodeAu, nil
	case "AT":
		return CountryCodeAt, nil
	case "AZ":
		return CountryCodeAz, nil
	case "BS":
		return CountryCodeBs, nil
	case "BH":
		return CountryCodeBh, nil
	case "BD":
		return CountryCodeBd, nil
	case "BB":
		return CountryCodeBb, nil
	case "BY":
		return CountryCodeBy, nil
	case "BE":
		return CountryCodeBe, nil
	case "BZ":
		return CountryCodeBz, nil
	case "BJ":
		return CountryCodeBj, nil
	case "BM":
		return CountryCodeBm, nil
	case "BT":
		return CountryCodeBt, nil
	case "BO":
		return CountryCodeBo, nil
	case "BQ":
		return CountryCodeBq, nil
	case "BA":
		return CountryCodeBa, nil
	case "BW":
		return CountryCodeBw, nil
	case "BV":
		return CountryCodeBv, nil
	case "BR":
		return CountryCodeBr, nil
	case "IO":
		return CountryCodeIo, nil
	case "BN":
		return CountryCodeBn, nil
	case "BG":
		return CountryCodeBg, nil
	case "BF":
		return CountryCodeBf, nil
	case "BI":
		return CountryCodeBi, nil
	case "CV":
		return CountryCodeCv, nil
	case "KH":
		return CountryCodeKh, nil
	case "CM":
		return CountryCodeCm, nil
	case "CA":
		return CountryCodeCa, nil
	case "KY":
		return CountryCodeKy, nil
	case "CF":
		return CountryCodeCf, nil
	case "TD":
		return CountryCodeTd, nil
	case "CL":
		return CountryCodeCl, nil
	case "CN":
		return CountryCodeCn, nil
	case "CX":
		return CountryCodeCx, nil
	case "CC":
		return CountryCodeCc, nil
	case "CO":
		return CountryCodeCo, nil
	case "KM":
		return CountryCodeKm, nil
	case "CD":
		return CountryCodeCd, nil
	case "CG":
		return CountryCodeCg, nil
	case "CK":
		return CountryCodeCk, nil
	case "CR":
		return CountryCodeCr, nil
	case "HR":
		return CountryCodeHr, nil
	case "CU":
		return CountryCodeCu, nil
	case "CW":
		return CountryCodeCw, nil
	case "CY":
		return CountryCodeCy, nil
	case "CZ":
		return CountryCodeCz, nil
	case "CI":
		return CountryCodeCi, nil
	case "DK":
		return CountryCodeDk, nil
	case "DJ":
		return CountryCodeDj, nil
	case "DM":
		return CountryCodeDm, nil
	case "DO":
		return CountryCodeDo, nil
	case "EC":
		return CountryCodeEc, nil
	case "EG":
		return CountryCodeEg, nil
	case "SV":
		return CountryCodeSv, nil
	case "GQ":
		return CountryCodeGq, nil
	case "ER":
		return CountryCodeEr, nil
	case "EE":
		return CountryCodeEe, nil
	case "SZ":
		return CountryCodeSz, nil
	case "ET":
		return CountryCodeEt, nil
	case "FK":
		return CountryCodeFk, nil
	case "FO":
		return CountryCodeFo, nil
	case "FJ":
		return CountryCodeFj, nil
	case "FI":
		return CountryCodeFi, nil
	case "FR":
		return CountryCodeFr, nil
	case "GF":
		return CountryCodeGf, nil
	case "PF":
		return CountryCodePf, nil
	case "TF":
		return CountryCodeTf, nil
	case "GA":
		return CountryCodeGa, nil
	case "GM":
		return CountryCodeGm, nil
	case "GE":
		return CountryCodeGe, nil
	case "DE":
		return CountryCodeDe, nil
	case "GH":
		return CountryCodeGh, nil
	case "GI":
		return CountryCodeGi, nil
	case "GR":
		return CountryCodeGr, nil
	case "GL":
		return CountryCodeGl, nil
	case "GD":
		return CountryCodeGd, nil
	case "GP":
		return CountryCodeGp, nil
	case "GU":
		return CountryCodeGu, nil
	case "GT":
		return CountryCodeGt, nil
	case "GG":
		return CountryCodeGg, nil
	case "GN":
		return CountryCodeGn, nil
	case "GW":
		return CountryCodeGw, nil
	case "GY":
		return CountryCodeGy, nil
	case "HT":
		return CountryCodeHt, nil
	case "HM":
		return CountryCodeHm, nil
	case "VA":
		return CountryCodeVa, nil
	case "HN":
		return CountryCodeHn, nil
	case "HK":
		return CountryCodeHk, nil
	case "HU":
		return CountryCodeHu, nil
	case "IS":
		return CountryCodeIs, nil
	case "IN":
		return CountryCodeIn, nil
	case "ID":
		return CountryCodeId, nil
	case "IR":
		return CountryCodeIr, nil
	case "IQ":
		return CountryCodeIq, nil
	case "IE":
		return CountryCodeIe, nil
	case "IM":
		return CountryCodeIm, nil
	case "IL":
		return CountryCodeIl, nil
	case "IT":
		return CountryCodeIt, nil
	case "JM":
		return CountryCodeJm, nil
	case "JP":
		return CountryCodeJp, nil
	case "JE":
		return CountryCodeJe, nil
	case "JO":
		return CountryCodeJo, nil
	case "KZ":
		return CountryCodeKz, nil
	case "KE":
		return CountryCodeKe, nil
	case "KI":
		return CountryCodeKi, nil
	case "KP":
		return CountryCodeKp, nil
	case "KR":
		return CountryCodeKr, nil
	case "KW":
		return CountryCodeKw, nil
	case "KG":
		return CountryCodeKg, nil
	case "LA":
		return CountryCodeLa, nil
	case "LV":
		return CountryCodeLv, nil
	case "LB":
		return CountryCodeLb, nil
	case "LS":
		return CountryCodeLs, nil
	case "LR":
		return CountryCodeLr, nil
	case "LY":
		return CountryCodeLy, nil
	case "LI":
		return CountryCodeLi, nil
	case "LT":
		return CountryCodeLt, nil
	case "LU":
		return CountryCodeLu, nil
	case "MO":
		return CountryCodeMo, nil
	case "MG":
		return CountryCodeMg, nil
	case "MW":
		return CountryCodeMw, nil
	case "MY":
		return CountryCodeMy, nil
	case "MV":
		return CountryCodeMv, nil
	case "ML":
		return CountryCodeMl, nil
	case "MT":
		return CountryCodeMt, nil
	case "MH":
		return CountryCodeMh, nil
	case "MQ":
		return CountryCodeMq, nil
	case "MR":
		return CountryCodeMr, nil
	case "MU":
		return CountryCodeMu, nil
	case "YT":
		return CountryCodeYt, nil
	case "MX":
		return CountryCodeMx, nil
	case "FM":
		return CountryCodeFm, nil
	case "MD":
		return CountryCodeMd, nil
	case "MC":
		return CountryCodeMc, nil
	case "MN":
		return CountryCodeMn, nil
	case "ME":
		return CountryCodeMe, nil
	case "MS":
		return CountryCodeMs, nil
	case "MA":
		return CountryCodeMa, nil
	case "MZ":
		return CountryCodeMz, nil
	case "MM":
		return CountryCodeMm, nil
	case "NA":
		return CountryCodeNa, nil
	case "NR":
		return CountryCodeNr, nil
	case "NP":
		return CountryCodeNp, nil
	case "NL":
		return CountryCodeNl, nil
	case "NC":
		return CountryCodeNc, nil
	case "NZ":
		return CountryCodeNz, nil
	case "NI":
		return CountryCodeNi, nil
	case "NE":
		return CountryCodeNe, nil
	case "NG":
		return CountryCodeNg, nil
	case "NU":
		return CountryCodeNu, nil
	case "NF":
		return CountryCodeNf, nil
	case "MK":
		return CountryCodeMk, nil
	case "MP":
		return CountryCodeMp, nil
	case "NO":
		return CountryCodeNo, nil
	case "OM":
		return CountryCodeOm, nil
	case "PK":
		return CountryCodePk, nil
	case "PW":
		return CountryCodePw, nil
	case "PS":
		return CountryCodePs, nil
	case "PA":
		return CountryCodePa, nil
	case "PG":
		return CountryCodePg, nil
	case "PY":
		return CountryCodePy, nil
	case "PE":
		return CountryCodePe, nil
	case "PH":
		return CountryCodePh, nil
	case "PN":
		return CountryCodePn, nil
	case "PL":
		return CountryCodePl, nil
	case "PT":
		return CountryCodePt, nil
	case "PR":
		return CountryCodePr, nil
	case "QA":
		return CountryCodeQa, nil
	case "RO":
		return CountryCodeRo, nil
	case "RU":
		return CountryCodeRu, nil
	case "RW":
		return CountryCodeRw, nil
	case "RE":
		return CountryCodeRe, nil
	case "BL":
		return CountryCodeBl, nil
	case "SH":
		return CountryCodeSh, nil
	case "KN":
		return CountryCodeKn, nil
	case "LC":
		return CountryCodeLc, nil
	case "MF":
		return CountryCodeMf, nil
	case "PM":
		return CountryCodePm, nil
	case "VC":
		return CountryCodeVc, nil
	case "WS":
		return CountryCodeWs, nil
	case "SM":
		return CountryCodeSm, nil
	case "ST":
		return CountryCodeSt, nil
	case "SA":
		return CountryCodeSa, nil
	case "SN":
		return CountryCodeSn, nil
	case "RS":
		return CountryCodeRs, nil
	case "SC":
		return CountryCodeSc, nil
	case "SL":
		return CountryCodeSl, nil
	case "SG":
		return CountryCodeSg, nil
	case "SX":
		return CountryCodeSx, nil
	case "SK":
		return CountryCodeSk, nil
	case "SI":
		return CountryCodeSi, nil
	case "SB":
		return CountryCodeSb, nil
	case "SO":
		return CountryCodeSo, nil
	case "ZA":
		return CountryCodeZa, nil
	case "GS":
		return CountryCodeGs, nil
	case "SS":
		return CountryCodeSs, nil
	case "ES":
		return CountryCodeEs, nil
	case "LK":
		return CountryCodeLk, nil
	case "SD":
		return CountryCodeSd, nil
	case "SR":
		return CountryCodeSr, nil
	case "SJ":
		return CountryCodeSj, nil
	case "SE":
		return CountryCodeSe, nil
	case "CH":
		return CountryCodeCh, nil
	case "SY":
		return CountryCodeSy, nil
	case "TW":
		return CountryCodeTw, nil
	case "TJ":
		return CountryCodeTj, nil
	case "TZ":
		return CountryCodeTz, nil
	case "TH":
		return CountryCodeTh, nil
	case "TL":
		return CountryCodeTl, nil
	case "TG":
		return CountryCodeTg, nil
	case "TK":
		return CountryCodeTk, nil
	case "TO":
		return CountryCodeTo, nil
	case "TT":
		return CountryCodeTt, nil
	case "TN":
		return CountryCodeTn, nil
	case "TM":
		return CountryCodeTm, nil
	case "TC":
		return CountryCodeTc, nil
	case "TV":
		return CountryCodeTv, nil
	case "TR":
		return CountryCodeTr, nil
	case "UG":
		return CountryCodeUg, nil
	case "UA":
		return CountryCodeUa, nil
	case "AE":
		return CountryCodeAe, nil
	case "GB":
		return CountryCodeGb, nil
	case "UM":
		return CountryCodeUm, nil
	case "US":
		return CountryCodeUs, nil
	case "UY":
		return CountryCodeUy, nil
	case "UZ":
		return CountryCodeUz, nil
	case "VU":
		return CountryCodeVu, nil
	case "VE":
		return CountryCodeVe, nil
	case "VN":
		return CountryCodeVn, nil
	case "VG":
		return CountryCodeVg, nil
	case "VI":
		return CountryCodeVi, nil
	case "WF":
		return CountryCodeWf, nil
	case "EH":
		return CountryCodeEh, nil
	case "YE":
		return CountryCodeYe, nil
	case "ZM":
		return CountryCodeZm, nil
	case "ZW":
		return CountryCodeZw, nil
	case "AX":
		return CountryCodeAx, nil
	case "XA":
		return CountryCodeXa, nil
	case "XB":
		return CountryCodeXb, nil
	case "XC":
		return CountryCodeXc, nil
	case "XD":
		return CountryCodeXd, nil
	case "XE":
		return CountryCodeXe, nil
	case "XF":
		return CountryCodeXf, nil
	case "XG":
		return CountryCodeXg, nil
	case "XH":
		return CountryCodeXh, nil
	case "XI":
		return CountryCodeXi, nil
	case "XJ":
		return CountryCodeXj, nil
	case "XK":
		return CountryCodeXk, nil
	case "XL":
		return CountryCodeXl, nil
	case "XM":
		return CountryCodeXm, nil
	case "XN":
		return CountryCodeXn, nil
	case "XO":
		return CountryCodeXo, nil
	case "XP":
		return CountryCodeXp, nil
	case "XQ":
		return CountryCodeXq, nil
	case "XR":
		return CountryCodeXr, nil
	case "XS":
		return CountryCodeXs, nil
	case "XT":
		return CountryCodeXt, nil
	case "XU":
		return CountryCodeXu, nil
	case "XV":
		return CountryCodeXv, nil
	case "XW":
		return CountryCodeXw, nil
	case "XY":
		return CountryCodeXy, nil
	case "XZ":
		return CountryCodeXz, nil
	case "N/A":
		return CountryCodeNotApplicable, nil
	}
	var t CountryCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountryCode) Ptr() *CountryCode {
	return &c
}

type CurrencyCode string

const (
	CurrencyCodeOneInch CurrencyCode = "1INCH"
	CurrencyCodeAave    CurrencyCode = "AAVE"
	CurrencyCodeAbt     CurrencyCode = "ABT"
	CurrencyCodeAch     CurrencyCode = "ACH"
	CurrencyCodeAcs     CurrencyCode = "ACS"
	CurrencyCodeAda     CurrencyCode = "ADA"
	CurrencyCodeAed     CurrencyCode = "AED"
	CurrencyCodeAergo   CurrencyCode = "AERGO"
	CurrencyCodeAero    CurrencyCode = "AERO"
	CurrencyCodeAfn     CurrencyCode = "AFN"
	CurrencyCodeAgld    CurrencyCode = "AGLD"
	CurrencyCodeAioz    CurrencyCode = "AIOZ"
	CurrencyCodeAlcx    CurrencyCode = "ALCX"
	CurrencyCodeAleph   CurrencyCode = "ALEPH"
	CurrencyCodeAlgo    CurrencyCode = "ALGO"
	CurrencyCodeAlice   CurrencyCode = "ALICE"
	CurrencyCodeAll     CurrencyCode = "ALL"
	CurrencyCodeAmd     CurrencyCode = "AMD"
	CurrencyCodeAmp     CurrencyCode = "AMP"
	CurrencyCodeAng     CurrencyCode = "ANG"
	CurrencyCodeAnkr    CurrencyCode = "ANKR"
	CurrencyCodeAnt     CurrencyCode = "ANT"
	CurrencyCodeAoa     CurrencyCode = "AOA"
	CurrencyCodeApe     CurrencyCode = "APE"
	CurrencyCodeApi3    CurrencyCode = "API3"
	CurrencyCodeApt     CurrencyCode = "APT"
	CurrencyCodeArb     CurrencyCode = "ARB"
	CurrencyCodeArpa    CurrencyCode = "ARPA"
	CurrencyCodeArs     CurrencyCode = "ARS"
	CurrencyCodeAsm     CurrencyCode = "ASM"
	CurrencyCodeAst     CurrencyCode = "AST"
	CurrencyCodeAta     CurrencyCode = "ATA"
	CurrencyCodeAtom    CurrencyCode = "ATOM"
	CurrencyCodeAuction CurrencyCode = "AUCTION"
	CurrencyCodeAud     CurrencyCode = "AUD"
	CurrencyCodeAudio   CurrencyCode = "AUDIO"
	CurrencyCodeAurora  CurrencyCode = "AURORA"
	CurrencyCodeAvax    CurrencyCode = "AVAX"
	CurrencyCodeAvt     CurrencyCode = "AVT"
	CurrencyCodeAwg     CurrencyCode = "AWG"
	CurrencyCodeAxl     CurrencyCode = "AXL"
	CurrencyCodeAxs     CurrencyCode = "AXS"
	CurrencyCodeAzn     CurrencyCode = "AZN"
	CurrencyCodeBadger  CurrencyCode = "BADGER"
	CurrencyCodeBal     CurrencyCode = "BAL"
	CurrencyCodeBam     CurrencyCode = "BAM"
	CurrencyCodeBand    CurrencyCode = "BAND"
	CurrencyCodeBat     CurrencyCode = "BAT"
	CurrencyCodeBbd     CurrencyCode = "BBD"
	CurrencyCodeBch     CurrencyCode = "BCH"
	CurrencyCodeBdt     CurrencyCode = "BDT"
	CurrencyCodeBgn     CurrencyCode = "BGN"
	CurrencyCodeBhd     CurrencyCode = "BHD"
	CurrencyCodeBico    CurrencyCode = "BICO"
	CurrencyCodeBif     CurrencyCode = "BIF"
	CurrencyCodeBigtime CurrencyCode = "BIGTIME"
	CurrencyCodeBit     CurrencyCode = "BIT"
	CurrencyCodeBlur    CurrencyCode = "BLUR"
	CurrencyCodeBlz     CurrencyCode = "BLZ"
	CurrencyCodeBmd     CurrencyCode = "BMD"
	CurrencyCodeBnd     CurrencyCode = "BND"
	CurrencyCodeBnt     CurrencyCode = "BNT"
	CurrencyCodeBob     CurrencyCode = "BOB"
	CurrencyCodeBoba    CurrencyCode = "BOBA"
	CurrencyCodeBond    CurrencyCode = "BOND"
	CurrencyCodeBonk    CurrencyCode = "BONK"
	CurrencyCodeBrl     CurrencyCode = "BRL"
	CurrencyCodeBsd     CurrencyCode = "BSD"
	CurrencyCodeBsv     CurrencyCode = "BSV"
	CurrencyCodeBtc     CurrencyCode = "BTC"
	CurrencyCodeBtn     CurrencyCode = "BTN"
	CurrencyCodeBtrst   CurrencyCode = "BTRST"
	CurrencyCodeBusd    CurrencyCode = "BUSD"
	CurrencyCodeBwp     CurrencyCode = "BWP"
	CurrencyCodeByn     CurrencyCode = "BYN"
	CurrencyCodeByr     CurrencyCode = "BYR"
	CurrencyCodeBzd     CurrencyCode = "BZD"
	CurrencyCodeC98     CurrencyCode = "C98"
	CurrencyCodeCad     CurrencyCode = "CAD"
	CurrencyCodeCbeth   CurrencyCode = "CBETH"
	CurrencyCodeCdf     CurrencyCode = "CDF"
	CurrencyCodeCelr    CurrencyCode = "CELR"
	CurrencyCodeCgld    CurrencyCode = "CGLD"
	CurrencyCodeChf     CurrencyCode = "CHF"
	CurrencyCodeChz     CurrencyCode = "CHZ"
	CurrencyCodeClf     CurrencyCode = "CLF"
	CurrencyCodeClp     CurrencyCode = "CLP"
	CurrencyCodeClv     CurrencyCode = "CLV"
	CurrencyCodeCnh     CurrencyCode = "CNH"
	CurrencyCodeCny     CurrencyCode = "CNY"
	CurrencyCodeComp    CurrencyCode = "COMP"
	CurrencyCodeCop     CurrencyCode = "COP"
	CurrencyCodeCoti    CurrencyCode = "COTI"
	CurrencyCodeCoval   CurrencyCode = "COVAL"
	CurrencyCodeCrc     CurrencyCode = "CRC"
	CurrencyCodeCro     CurrencyCode = "CRO"
	CurrencyCodeCrpt    CurrencyCode = "CRPT"
	CurrencyCodeCrv     CurrencyCode = "CRV"
	CurrencyCodeCtsi    CurrencyCode = "CTSI"
	CurrencyCodeCtx     CurrencyCode = "CTX"
	CurrencyCodeCuc     CurrencyCode = "CUC"
	CurrencyCodeCup     CurrencyCode = "CUP"
	CurrencyCodeCvc     CurrencyCode = "CVC"
	CurrencyCodeCve     CurrencyCode = "CVE"
	CurrencyCodeCvx     CurrencyCode = "CVX"
	CurrencyCodeCzk     CurrencyCode = "CZK"
	CurrencyCodeDai     CurrencyCode = "DAI"
	CurrencyCodeDar     CurrencyCode = "DAR"
	CurrencyCodeDash    CurrencyCode = "DASH"
	CurrencyCodeDdx     CurrencyCode = "DDX"
	CurrencyCodeDeso    CurrencyCode = "DESO"
	CurrencyCodeDext    CurrencyCode = "DEXT"
	CurrencyCodeDia     CurrencyCode = "DIA"
	CurrencyCodeDimo    CurrencyCode = "DIMO"
	CurrencyCodeDjf     CurrencyCode = "DJF"
	CurrencyCodeDkk     CurrencyCode = "DKK"
	CurrencyCodeDnt     CurrencyCode = "DNT"
	CurrencyCodeDoge    CurrencyCode = "DOGE"
	CurrencyCodeDop     CurrencyCode = "DOP"
	CurrencyCodeDot     CurrencyCode = "DOT"
	CurrencyCodeDrep    CurrencyCode = "DREP"
	CurrencyCodeDyp     CurrencyCode = "DYP"
	CurrencyCodeDzd     CurrencyCode = "DZD"
	CurrencyCodeEek     CurrencyCode = "EEK"
	CurrencyCodeEgld    CurrencyCode = "EGLD"
	CurrencyCodeEgp     CurrencyCode = "EGP"
	CurrencyCodeEla     CurrencyCode = "ELA"
	CurrencyCodeEnj     CurrencyCode = "ENJ"
	CurrencyCodeEns     CurrencyCode = "ENS"
	CurrencyCodeEos     CurrencyCode = "EOS"
	CurrencyCodeErn     CurrencyCode = "ERN"
	CurrencyCodeEtb     CurrencyCode = "ETB"
	CurrencyCodeEtc     CurrencyCode = "ETC"
	CurrencyCodeEth     CurrencyCode = "ETH"
	CurrencyCodeEth2    CurrencyCode = "ETH2"
	CurrencyCodeEur     CurrencyCode = "EUR"
	CurrencyCodeEuroc   CurrencyCode = "EUROC"
	CurrencyCodeEthfi   CurrencyCode = "ETHFI"
	CurrencyCodeFarm    CurrencyCode = "FARM"
	CurrencyCodeFet     CurrencyCode = "FET"
	CurrencyCodeFida    CurrencyCode = "FIDA"
	CurrencyCodeFil     CurrencyCode = "FIL"
	CurrencyCodeFis     CurrencyCode = "FIS"
	CurrencyCodeFjd     CurrencyCode = "FJD"
	CurrencyCodeFkp     CurrencyCode = "FKP"
	CurrencyCodeFlow    CurrencyCode = "FLOW"
	CurrencyCodeFlr     CurrencyCode = "FLR"
	CurrencyCodeFort    CurrencyCode = "FORT"
	CurrencyCodeForth   CurrencyCode = "FORTH"
	CurrencyCodeFox     CurrencyCode = "FOX"
	CurrencyCodeFx      CurrencyCode = "FX"
	CurrencyCodeFtm     CurrencyCode = "FTM"
	CurrencyCodeGal     CurrencyCode = "GAL"
	CurrencyCodeGala    CurrencyCode = "GALA"
	CurrencyCodeGbp     CurrencyCode = "GBP"
	CurrencyCodeGel     CurrencyCode = "GEL"
	CurrencyCodeGfi     CurrencyCode = "GFI"
	CurrencyCodeGgp     CurrencyCode = "GGP"
	CurrencyCodeGhs     CurrencyCode = "GHS"
	CurrencyCodeGhst    CurrencyCode = "GHST"
	CurrencyCodeGip     CurrencyCode = "GIP"
	CurrencyCodeGlm     CurrencyCode = "GLM"
	CurrencyCodeGmd     CurrencyCode = "GMD"
	CurrencyCodeGmt     CurrencyCode = "GMT"
	CurrencyCodeGnf     CurrencyCode = "GNF"
	CurrencyCodeGno     CurrencyCode = "GNO"
	CurrencyCodeGnt     CurrencyCode = "GNT"
	CurrencyCodeGods    CurrencyCode = "GODS"
	CurrencyCodeGrt     CurrencyCode = "GRT"
	CurrencyCodeGst     CurrencyCode = "GST"
	CurrencyCodeGtc     CurrencyCode = "GTC"
	CurrencyCodeGtq     CurrencyCode = "GTQ"
	CurrencyCodeGusd    CurrencyCode = "GUSD"
	CurrencyCodeGyd     CurrencyCode = "GYD"
	CurrencyCodeGyen    CurrencyCode = "GYEN"
	CurrencyCodeHbar    CurrencyCode = "HBAR"
	CurrencyCodeHft     CurrencyCode = "HFT"
	CurrencyCodeHigh    CurrencyCode = "HIGH"
	CurrencyCodeHkd     CurrencyCode = "HKD"
	CurrencyCodeHnl     CurrencyCode = "HNL"
	CurrencyCodeHnt     CurrencyCode = "HNT"
	CurrencyCodeHoney   CurrencyCode = "HONEY"
	CurrencyCodeHopr    CurrencyCode = "HOPR"
	CurrencyCodeHrk     CurrencyCode = "HRK"
	CurrencyCodeHtg     CurrencyCode = "HTG"
	CurrencyCodeHuf     CurrencyCode = "HUF"
	CurrencyCodeIcp     CurrencyCode = "ICP"
	CurrencyCodeIdex    CurrencyCode = "IDEX"
	CurrencyCodeIdr     CurrencyCode = "IDR"
	CurrencyCodeIls     CurrencyCode = "ILS"
	CurrencyCodeIlv     CurrencyCode = "ILV"
	CurrencyCodeImp     CurrencyCode = "IMP"
	CurrencyCodeImx     CurrencyCode = "IMX"
	CurrencyCodeIndex   CurrencyCode = "INDEX"
	CurrencyCodeInj     CurrencyCode = "INJ"
	CurrencyCodeInr     CurrencyCode = "INR"
	CurrencyCodeInv     CurrencyCode = "INV"
	CurrencyCodeIotx    CurrencyCode = "IOTX"
	CurrencyCodeIqd     CurrencyCode = "IQD"
	CurrencyCodeIrr     CurrencyCode = "IRR"
	CurrencyCodeIsk     CurrencyCode = "ISK"
	CurrencyCodeJasmy   CurrencyCode = "JASMY"
	CurrencyCodeJep     CurrencyCode = "JEP"
	CurrencyCodeJmd     CurrencyCode = "JMD"
	CurrencyCodeJod     CurrencyCode = "JOD"
	CurrencyCodeJpy     CurrencyCode = "JPY"
	CurrencyCodeJto     CurrencyCode = "JTO"
	CurrencyCodeJup     CurrencyCode = "JUP"
	CurrencyCodeKava    CurrencyCode = "KAVA"
	CurrencyCodeKeep    CurrencyCode = "KEEP"
	CurrencyCodeKes     CurrencyCode = "KES"
	CurrencyCodeKgs     CurrencyCode = "KGS"
	CurrencyCodeKhr     CurrencyCode = "KHR"
	CurrencyCodeKmf     CurrencyCode = "KMF"
	CurrencyCodeKnc     CurrencyCode = "KNC"
	CurrencyCodeKpw     CurrencyCode = "KPW"
	CurrencyCodeKrl     CurrencyCode = "KRL"
	CurrencyCodeKrw     CurrencyCode = "KRW"
	CurrencyCodeKsm     CurrencyCode = "KSM"
	CurrencyCodeKwd     CurrencyCode = "KWD"
	CurrencyCodeKyd     CurrencyCode = "KYD"
	CurrencyCodeKzt     CurrencyCode = "KZT"
	CurrencyCodeLak     CurrencyCode = "LAK"
	CurrencyCodeLbp     CurrencyCode = "LBP"
	CurrencyCodeLcx     CurrencyCode = "LCX"
	CurrencyCodeLdo     CurrencyCode = "LDO"
	CurrencyCodeLink    CurrencyCode = "LINK"
	CurrencyCodeLit     CurrencyCode = "LIT"
	CurrencyCodeLkr     CurrencyCode = "LKR"
	CurrencyCodeLoka    CurrencyCode = "LOKA"
	CurrencyCodeLoom    CurrencyCode = "LOOM"
	CurrencyCodeLpt     CurrencyCode = "LPT"
	CurrencyCodeLqty    CurrencyCode = "LQTY"
	CurrencyCodeLrc     CurrencyCode = "LRC"
	CurrencyCodeLrd     CurrencyCode = "LRD"
	CurrencyCodeLseth   CurrencyCode = "LSETH"
	CurrencyCodeLsl     CurrencyCode = "LSL"
	CurrencyCodeLtc     CurrencyCode = "LTC"
	CurrencyCodeLtl     CurrencyCode = "LTL"
	CurrencyCodeLvl     CurrencyCode = "LVL"
	CurrencyCodeLyd     CurrencyCode = "LYD"
	CurrencyCodeMad     CurrencyCode = "MAD"
	CurrencyCodeMagic   CurrencyCode = "MAGIC"
	CurrencyCodeMana    CurrencyCode = "MANA"
	CurrencyCodeMask    CurrencyCode = "MASK"
	CurrencyCodeMath    CurrencyCode = "MATH"
	CurrencyCodeMatic   CurrencyCode = "MATIC"
	CurrencyCodeMco2    CurrencyCode = "MCO2"
	CurrencyCodeMdl     CurrencyCode = "MDL"
	CurrencyCodeMdt     CurrencyCode = "MDT"
	CurrencyCodeMedia   CurrencyCode = "MEDIA"
	CurrencyCodeMetis   CurrencyCode = "METIS"
	CurrencyCodeMga     CurrencyCode = "MGA"
	CurrencyCodeMina    CurrencyCode = "MINA"
	CurrencyCodeMir     CurrencyCode = "MIR"
	CurrencyCodeMkd     CurrencyCode = "MKD"
	CurrencyCodeMkr     CurrencyCode = "MKR"
	CurrencyCodeMln     CurrencyCode = "MLN"
	CurrencyCodeMmk     CurrencyCode = "MMK"
	CurrencyCodeMnde    CurrencyCode = "MNDE"
	CurrencyCodeMnt     CurrencyCode = "MNT"
	CurrencyCodeMobile  CurrencyCode = "MOBILE"
	CurrencyCodeMona    CurrencyCode = "MONA"
	CurrencyCodeMop     CurrencyCode = "MOP"
	CurrencyCodeMpl     CurrencyCode = "MPL"
	CurrencyCodeMro     CurrencyCode = "MRO"
	CurrencyCodeMru     CurrencyCode = "MRU"
	CurrencyCodeMsol    CurrencyCode = "MSOL"
	CurrencyCodeMtl     CurrencyCode = "MTL"
	CurrencyCodeMulti   CurrencyCode = "MULTI"
	CurrencyCodeMur     CurrencyCode = "MUR"
	CurrencyCodeMuse    CurrencyCode = "MUSE"
	CurrencyCodeMvr     CurrencyCode = "MVR"
	CurrencyCodeMwk     CurrencyCode = "MWK"
	CurrencyCodeMxc     CurrencyCode = "MXC"
	CurrencyCodeMxn     CurrencyCode = "MXN"
	CurrencyCodeMyr     CurrencyCode = "MYR"
	CurrencyCodeMzn     CurrencyCode = "MZN"
	CurrencyCodeNad     CurrencyCode = "NAD"
	CurrencyCodeNct     CurrencyCode = "NCT"
	CurrencyCodeNear    CurrencyCode = "NEAR"
	CurrencyCodeNest    CurrencyCode = "NEST"
	CurrencyCodeNgn     CurrencyCode = "NGN"
	CurrencyCodeNio     CurrencyCode = "NIO"
	CurrencyCodeNkn     CurrencyCode = "NKN"
	CurrencyCodeNmr     CurrencyCode = "NMR"
	CurrencyCodeNok     CurrencyCode = "NOK"
	CurrencyCodeNpr     CurrencyCode = "NPR"
	CurrencyCodeNu      CurrencyCode = "NU"
	CurrencyCodeNzd     CurrencyCode = "NZD"
	CurrencyCodeOcean   CurrencyCode = "OCEAN"
	CurrencyCodeOgn     CurrencyCode = "OGN"
	CurrencyCodeOmg     CurrencyCode = "OMG"
	CurrencyCodeOmr     CurrencyCode = "OMR"
	CurrencyCodeOndo    CurrencyCode = "ONDO"
	CurrencyCodeOoki    CurrencyCode = "OOKI"
	CurrencyCodeOp      CurrencyCode = "OP"
	CurrencyCodeOrca    CurrencyCode = "ORCA"
	CurrencyCodeOrn     CurrencyCode = "ORN"
	CurrencyCodeOsmo    CurrencyCode = "OSMO"
	CurrencyCodeOxt     CurrencyCode = "OXT"
	CurrencyCodePab     CurrencyCode = "PAB"
	CurrencyCodePax     CurrencyCode = "PAX"
	CurrencyCodePen     CurrencyCode = "PEN"
	CurrencyCodePengu   CurrencyCode = "PENGU"
	CurrencyCodePerp    CurrencyCode = "PERP"
	CurrencyCodePgk     CurrencyCode = "PGK"
	CurrencyCodePhp     CurrencyCode = "PHP"
	CurrencyCodePkr     CurrencyCode = "PKR"
	CurrencyCodePla     CurrencyCode = "PLA"
	CurrencyCodePln     CurrencyCode = "PLN"
	CurrencyCodePlu     CurrencyCode = "PLU"
	CurrencyCodePng     CurrencyCode = "PNG"
	CurrencyCodePol     CurrencyCode = "POL"
	CurrencyCodePols    CurrencyCode = "POLS"
	CurrencyCodePoly    CurrencyCode = "POLY"
	CurrencyCodePond    CurrencyCode = "POND"
	CurrencyCodePowr    CurrencyCode = "POWR"
	CurrencyCodePrime   CurrencyCode = "PRIME"
	CurrencyCodePro     CurrencyCode = "PRO"
	CurrencyCodePrq     CurrencyCode = "PRQ"
	CurrencyCodePundix  CurrencyCode = "PUNDIX"
	CurrencyCodePyg     CurrencyCode = "PYG"
	CurrencyCodePyr     CurrencyCode = "PYR"
	CurrencyCodePyusd   CurrencyCode = "PYUSD"
	CurrencyCodeQar     CurrencyCode = "QAR"
	CurrencyCodeQi      CurrencyCode = "QI"
	CurrencyCodeQnt     CurrencyCode = "QNT"
	CurrencyCodeQsp     CurrencyCode = "QSP"
	CurrencyCodeQuick   CurrencyCode = "QUICK"
	CurrencyCodeRad     CurrencyCode = "RAD"
	CurrencyCodeRai     CurrencyCode = "RAI"
	CurrencyCodeRare    CurrencyCode = "RARE"
	CurrencyCodeRari    CurrencyCode = "RARI"
	CurrencyCodeRbn     CurrencyCode = "RBN"
	CurrencyCodeRen     CurrencyCode = "REN"
	CurrencyCodeRender  CurrencyCode = "RENDER"
	CurrencyCodeRep     CurrencyCode = "REP"
	CurrencyCodeRepv2   CurrencyCode = "REPV2"
	CurrencyCodeReq     CurrencyCode = "REQ"
	CurrencyCodeRgt     CurrencyCode = "RGT"
	CurrencyCodeRlc     CurrencyCode = "RLC"
	CurrencyCodeRly     CurrencyCode = "RLY"
	CurrencyCodeRndr    CurrencyCode = "RNDR"
	CurrencyCodeRon     CurrencyCode = "RON"
	CurrencyCodeRose    CurrencyCode = "ROSE"
	CurrencyCodeRpl     CurrencyCode = "RPL"
	CurrencyCodeRsd     CurrencyCode = "RSD"
	CurrencyCodeRub     CurrencyCode = "RUB"
	CurrencyCodeRune    CurrencyCode = "RUNE"
	CurrencyCodeRwf     CurrencyCode = "RWF"
	CurrencyCodeSand    CurrencyCode = "SAND"
	CurrencyCodeSar     CurrencyCode = "SAR"
	CurrencyCodeSbd     CurrencyCode = "SBD"
	CurrencyCodeScr     CurrencyCode = "SCR"
	CurrencyCodeSdg     CurrencyCode = "SDG"
	CurrencyCodeSeam    CurrencyCode = "SEAM"
	CurrencyCodeSei     CurrencyCode = "SEI"
	CurrencyCodeSek     CurrencyCode = "SEK"
	CurrencyCodeSgd     CurrencyCode = "SGD"
	CurrencyCodeShib    CurrencyCode = "SHIB"
	CurrencyCodeShp     CurrencyCode = "SHP"
	CurrencyCodeShping  CurrencyCode = "SHPING"
	CurrencyCodeSkk     CurrencyCode = "SKK"
	CurrencyCodeSkl     CurrencyCode = "SKL"
	CurrencyCodeSll     CurrencyCode = "SLL"
	CurrencyCodeSnt     CurrencyCode = "SNT"
	CurrencyCodeSnx     CurrencyCode = "SNX"
	CurrencyCodeSol     CurrencyCode = "SOL"
	CurrencyCodeSos     CurrencyCode = "SOS"
	CurrencyCodeSpa     CurrencyCode = "SPA"
	CurrencyCodeSpell   CurrencyCode = "SPELL"
	CurrencyCodeSrd     CurrencyCode = "SRD"
	CurrencyCodeSsp     CurrencyCode = "SSP"
	CurrencyCodeStd     CurrencyCode = "STD"
	CurrencyCodeStg     CurrencyCode = "STG"
	CurrencyCodeStorj   CurrencyCode = "STORJ"
	CurrencyCodeStrk    CurrencyCode = "STRK"
	CurrencyCodeStx     CurrencyCode = "STX"
	CurrencyCodeSui     CurrencyCode = "SUI"
	CurrencyCodeSuku    CurrencyCode = "SUKU"
	CurrencyCodeSuper   CurrencyCode = "SUPER"
	CurrencyCodeSushi   CurrencyCode = "SUSHI"
	CurrencyCodeSvc     CurrencyCode = "SVC"
	CurrencyCodeSwftc   CurrencyCode = "SWFTC"
	CurrencyCodeSylo    CurrencyCode = "SYLO"
	CurrencyCodeSyn     CurrencyCode = "SYN"
	CurrencyCodeSyp     CurrencyCode = "SYP"
	CurrencyCodeSzl     CurrencyCode = "SZL"
	CurrencyCodeT       CurrencyCode = "T"
	CurrencyCodeThb     CurrencyCode = "THB"
	CurrencyCodeTheta   CurrencyCode = "THETA"
	CurrencyCodeTia     CurrencyCode = "TIA"
	CurrencyCodeTime    CurrencyCode = "TIME"
	CurrencyCodeTjs     CurrencyCode = "TJS"
	CurrencyCodeTmm     CurrencyCode = "TMM"
	CurrencyCodeTmt     CurrencyCode = "TMT"
	CurrencyCodeTnd     CurrencyCode = "TND"
	CurrencyCodeTone    CurrencyCode = "TONE"
	CurrencyCodeTop     CurrencyCode = "TOP"
	CurrencyCodeTrac    CurrencyCode = "TRAC"
	CurrencyCodeTrb     CurrencyCode = "TRB"
	CurrencyCodeTribe   CurrencyCode = "TRIBE"
	CurrencyCodeTru     CurrencyCode = "TRU"
	CurrencyCodeTry     CurrencyCode = "TRY"
	CurrencyCodeTtd     CurrencyCode = "TTD"
	CurrencyCodeTvk     CurrencyCode = "TVK"
	CurrencyCodeTwd     CurrencyCode = "TWD"
	CurrencyCodeTzs     CurrencyCode = "TZS"
	CurrencyCodeUah     CurrencyCode = "UAH"
	CurrencyCodeUgx     CurrencyCode = "UGX"
	CurrencyCodeUma     CurrencyCode = "UMA"
	CurrencyCodeUnfi    CurrencyCode = "UNFI"
	CurrencyCodeUni     CurrencyCode = "UNI"
	CurrencyCodeUpi     CurrencyCode = "UPI"
	CurrencyCodeUsd     CurrencyCode = "USD"
	CurrencyCodeUsdc    CurrencyCode = "USDC"
	CurrencyCodeUsdt    CurrencyCode = "USDT"
	CurrencyCodeUst     CurrencyCode = "UST"
	CurrencyCodeUyu     CurrencyCode = "UYU"
	CurrencyCodeUzs     CurrencyCode = "UZS"
	CurrencyCodeVara    CurrencyCode = "VARA"
	CurrencyCodeVef     CurrencyCode = "VEF"
	CurrencyCodeVelo    CurrencyCode = "VELO"
	CurrencyCodeVes     CurrencyCode = "VES"
	CurrencyCodeVet     CurrencyCode = "VET"
	CurrencyCodeVgx     CurrencyCode = "VGX"
	CurrencyCodeVnd     CurrencyCode = "VND"
	CurrencyCodeVoxel   CurrencyCode = "VOXEL"
	CurrencyCodeVtho    CurrencyCode = "VTHO"
	CurrencyCodeVuv     CurrencyCode = "VUV"
	CurrencyCodeWampl   CurrencyCode = "WAMPL"
	CurrencyCodeWaxl    CurrencyCode = "WAXL"
	CurrencyCodeWbtc    CurrencyCode = "WBTC"
	CurrencyCodeWcfg    CurrencyCode = "WCFG"
	CurrencyCodeWluna   CurrencyCode = "WLUNA"
	CurrencyCodeWst     CurrencyCode = "WST"
	CurrencyCodeXaf     CurrencyCode = "XAF"
	CurrencyCodeXag     CurrencyCode = "XAG"
	CurrencyCodeXau     CurrencyCode = "XAU"
	CurrencyCodeXcd     CurrencyCode = "XCD"
	CurrencyCodeXcn     CurrencyCode = "XCN"
	CurrencyCodeXdr     CurrencyCode = "XDR"
	CurrencyCodeXlm     CurrencyCode = "XLM"
	CurrencyCodeXmon    CurrencyCode = "XMON"
	CurrencyCodeXof     CurrencyCode = "XOF"
	CurrencyCodeXpd     CurrencyCode = "XPD"
	CurrencyCodeXpf     CurrencyCode = "XPF"
	CurrencyCodeXpt     CurrencyCode = "XPT"
	CurrencyCodeXrp     CurrencyCode = "XRP"
	CurrencyCodeXtz     CurrencyCode = "XTZ"
	CurrencyCodeXyo     CurrencyCode = "XYO"
	CurrencyCodeYer     CurrencyCode = "YER"
	CurrencyCodeYfi     CurrencyCode = "YFI"
	CurrencyCodeYfii    CurrencyCode = "YFII"
	CurrencyCodeZar     CurrencyCode = "ZAR"
	CurrencyCodeZec     CurrencyCode = "ZEC"
	CurrencyCodeZen     CurrencyCode = "ZEN"
	CurrencyCodeZeta    CurrencyCode = "ZETA"
	CurrencyCodeZmk     CurrencyCode = "ZMK"
	CurrencyCodeZmw     CurrencyCode = "ZMW"
	CurrencyCodeZrx     CurrencyCode = "ZRX"
	CurrencyCodeZwd     CurrencyCode = "ZWD"
	CurrencyCodeFdusd   CurrencyCode = "FDUSD"
	CurrencyCodeAgx     CurrencyCode = "AGX"
	CurrencyCodeAux     CurrencyCode = "AUX"
	CurrencyCodeBnb     CurrencyCode = "BNB"
	CurrencyCodeCube    CurrencyCode = "CUBE"
	CurrencyCodeEmon    CurrencyCode = "EMON"
	CurrencyCodeFdgt    CurrencyCode = "FDGT"
	CurrencyCodeKgld    CurrencyCode = "KGLD"
	CurrencyCodeLode    CurrencyCode = "LODE"
	CurrencyCodePass    CurrencyCode = "PASS"
	CurrencyCodePremia  CurrencyCode = "PREMIA"
	CurrencyCodeTab1    CurrencyCode = "TAB1"
	CurrencyCodeTdUsd   CurrencyCode = "TD-USD"
	CurrencyCodeTrx     CurrencyCode = "TRX"
	CurrencyCodeTyuga   CurrencyCode = "TYUGA"
	CurrencyCodeVic     CurrencyCode = "VIC"
	CurrencyCodeXai     CurrencyCode = "XAI"
	CurrencyCodeSle     CurrencyCode = "SLE"
)

func NewCurrencyCodeFromString(s string) (CurrencyCode, error) {
	switch s {
	case "1INCH":
		return CurrencyCodeOneInch, nil
	case "AAVE":
		return CurrencyCodeAave, nil
	case "ABT":
		return CurrencyCodeAbt, nil
	case "ACH":
		return CurrencyCodeAch, nil
	case "ACS":
		return CurrencyCodeAcs, nil
	case "ADA":
		return CurrencyCodeAda, nil
	case "AED":
		return CurrencyCodeAed, nil
	case "AERGO":
		return CurrencyCodeAergo, nil
	case "AERO":
		return CurrencyCodeAero, nil
	case "AFN":
		return CurrencyCodeAfn, nil
	case "AGLD":
		return CurrencyCodeAgld, nil
	case "AIOZ":
		return CurrencyCodeAioz, nil
	case "ALCX":
		return CurrencyCodeAlcx, nil
	case "ALEPH":
		return CurrencyCodeAleph, nil
	case "ALGO":
		return CurrencyCodeAlgo, nil
	case "ALICE":
		return CurrencyCodeAlice, nil
	case "ALL":
		return CurrencyCodeAll, nil
	case "AMD":
		return CurrencyCodeAmd, nil
	case "AMP":
		return CurrencyCodeAmp, nil
	case "ANG":
		return CurrencyCodeAng, nil
	case "ANKR":
		return CurrencyCodeAnkr, nil
	case "ANT":
		return CurrencyCodeAnt, nil
	case "AOA":
		return CurrencyCodeAoa, nil
	case "APE":
		return CurrencyCodeApe, nil
	case "API3":
		return CurrencyCodeApi3, nil
	case "APT":
		return CurrencyCodeApt, nil
	case "ARB":
		return CurrencyCodeArb, nil
	case "ARPA":
		return CurrencyCodeArpa, nil
	case "ARS":
		return CurrencyCodeArs, nil
	case "ASM":
		return CurrencyCodeAsm, nil
	case "AST":
		return CurrencyCodeAst, nil
	case "ATA":
		return CurrencyCodeAta, nil
	case "ATOM":
		return CurrencyCodeAtom, nil
	case "AUCTION":
		return CurrencyCodeAuction, nil
	case "AUD":
		return CurrencyCodeAud, nil
	case "AUDIO":
		return CurrencyCodeAudio, nil
	case "AURORA":
		return CurrencyCodeAurora, nil
	case "AVAX":
		return CurrencyCodeAvax, nil
	case "AVT":
		return CurrencyCodeAvt, nil
	case "AWG":
		return CurrencyCodeAwg, nil
	case "AXL":
		return CurrencyCodeAxl, nil
	case "AXS":
		return CurrencyCodeAxs, nil
	case "AZN":
		return CurrencyCodeAzn, nil
	case "BADGER":
		return CurrencyCodeBadger, nil
	case "BAL":
		return CurrencyCodeBal, nil
	case "BAM":
		return CurrencyCodeBam, nil
	case "BAND":
		return CurrencyCodeBand, nil
	case "BAT":
		return CurrencyCodeBat, nil
	case "BBD":
		return CurrencyCodeBbd, nil
	case "BCH":
		return CurrencyCodeBch, nil
	case "BDT":
		return CurrencyCodeBdt, nil
	case "BGN":
		return CurrencyCodeBgn, nil
	case "BHD":
		return CurrencyCodeBhd, nil
	case "BICO":
		return CurrencyCodeBico, nil
	case "BIF":
		return CurrencyCodeBif, nil
	case "BIGTIME":
		return CurrencyCodeBigtime, nil
	case "BIT":
		return CurrencyCodeBit, nil
	case "BLUR":
		return CurrencyCodeBlur, nil
	case "BLZ":
		return CurrencyCodeBlz, nil
	case "BMD":
		return CurrencyCodeBmd, nil
	case "BND":
		return CurrencyCodeBnd, nil
	case "BNT":
		return CurrencyCodeBnt, nil
	case "BOB":
		return CurrencyCodeBob, nil
	case "BOBA":
		return CurrencyCodeBoba, nil
	case "BOND":
		return CurrencyCodeBond, nil
	case "BONK":
		return CurrencyCodeBonk, nil
	case "BRL":
		return CurrencyCodeBrl, nil
	case "BSD":
		return CurrencyCodeBsd, nil
	case "BSV":
		return CurrencyCodeBsv, nil
	case "BTC":
		return CurrencyCodeBtc, nil
	case "BTN":
		return CurrencyCodeBtn, nil
	case "BTRST":
		return CurrencyCodeBtrst, nil
	case "BUSD":
		return CurrencyCodeBusd, nil
	case "BWP":
		return CurrencyCodeBwp, nil
	case "BYN":
		return CurrencyCodeByn, nil
	case "BYR":
		return CurrencyCodeByr, nil
	case "BZD":
		return CurrencyCodeBzd, nil
	case "C98":
		return CurrencyCodeC98, nil
	case "CAD":
		return CurrencyCodeCad, nil
	case "CBETH":
		return CurrencyCodeCbeth, nil
	case "CDF":
		return CurrencyCodeCdf, nil
	case "CELR":
		return CurrencyCodeCelr, nil
	case "CGLD":
		return CurrencyCodeCgld, nil
	case "CHF":
		return CurrencyCodeChf, nil
	case "CHZ":
		return CurrencyCodeChz, nil
	case "CLF":
		return CurrencyCodeClf, nil
	case "CLP":
		return CurrencyCodeClp, nil
	case "CLV":
		return CurrencyCodeClv, nil
	case "CNH":
		return CurrencyCodeCnh, nil
	case "CNY":
		return CurrencyCodeCny, nil
	case "COMP":
		return CurrencyCodeComp, nil
	case "COP":
		return CurrencyCodeCop, nil
	case "COTI":
		return CurrencyCodeCoti, nil
	case "COVAL":
		return CurrencyCodeCoval, nil
	case "CRC":
		return CurrencyCodeCrc, nil
	case "CRO":
		return CurrencyCodeCro, nil
	case "CRPT":
		return CurrencyCodeCrpt, nil
	case "CRV":
		return CurrencyCodeCrv, nil
	case "CTSI":
		return CurrencyCodeCtsi, nil
	case "CTX":
		return CurrencyCodeCtx, nil
	case "CUC":
		return CurrencyCodeCuc, nil
	case "CUP":
		return CurrencyCodeCup, nil
	case "CVC":
		return CurrencyCodeCvc, nil
	case "CVE":
		return CurrencyCodeCve, nil
	case "CVX":
		return CurrencyCodeCvx, nil
	case "CZK":
		return CurrencyCodeCzk, nil
	case "DAI":
		return CurrencyCodeDai, nil
	case "DAR":
		return CurrencyCodeDar, nil
	case "DASH":
		return CurrencyCodeDash, nil
	case "DDX":
		return CurrencyCodeDdx, nil
	case "DESO":
		return CurrencyCodeDeso, nil
	case "DEXT":
		return CurrencyCodeDext, nil
	case "DIA":
		return CurrencyCodeDia, nil
	case "DIMO":
		return CurrencyCodeDimo, nil
	case "DJF":
		return CurrencyCodeDjf, nil
	case "DKK":
		return CurrencyCodeDkk, nil
	case "DNT":
		return CurrencyCodeDnt, nil
	case "DOGE":
		return CurrencyCodeDoge, nil
	case "DOP":
		return CurrencyCodeDop, nil
	case "DOT":
		return CurrencyCodeDot, nil
	case "DREP":
		return CurrencyCodeDrep, nil
	case "DYP":
		return CurrencyCodeDyp, nil
	case "DZD":
		return CurrencyCodeDzd, nil
	case "EEK":
		return CurrencyCodeEek, nil
	case "EGLD":
		return CurrencyCodeEgld, nil
	case "EGP":
		return CurrencyCodeEgp, nil
	case "ELA":
		return CurrencyCodeEla, nil
	case "ENJ":
		return CurrencyCodeEnj, nil
	case "ENS":
		return CurrencyCodeEns, nil
	case "EOS":
		return CurrencyCodeEos, nil
	case "ERN":
		return CurrencyCodeErn, nil
	case "ETB":
		return CurrencyCodeEtb, nil
	case "ETC":
		return CurrencyCodeEtc, nil
	case "ETH":
		return CurrencyCodeEth, nil
	case "ETH2":
		return CurrencyCodeEth2, nil
	case "EUR":
		return CurrencyCodeEur, nil
	case "EUROC":
		return CurrencyCodeEuroc, nil
	case "ETHFI":
		return CurrencyCodeEthfi, nil
	case "FARM":
		return CurrencyCodeFarm, nil
	case "FET":
		return CurrencyCodeFet, nil
	case "FIDA":
		return CurrencyCodeFida, nil
	case "FIL":
		return CurrencyCodeFil, nil
	case "FIS":
		return CurrencyCodeFis, nil
	case "FJD":
		return CurrencyCodeFjd, nil
	case "FKP":
		return CurrencyCodeFkp, nil
	case "FLOW":
		return CurrencyCodeFlow, nil
	case "FLR":
		return CurrencyCodeFlr, nil
	case "FORT":
		return CurrencyCodeFort, nil
	case "FORTH":
		return CurrencyCodeForth, nil
	case "FOX":
		return CurrencyCodeFox, nil
	case "FX":
		return CurrencyCodeFx, nil
	case "FTM":
		return CurrencyCodeFtm, nil
	case "GAL":
		return CurrencyCodeGal, nil
	case "GALA":
		return CurrencyCodeGala, nil
	case "GBP":
		return CurrencyCodeGbp, nil
	case "GEL":
		return CurrencyCodeGel, nil
	case "GFI":
		return CurrencyCodeGfi, nil
	case "GGP":
		return CurrencyCodeGgp, nil
	case "GHS":
		return CurrencyCodeGhs, nil
	case "GHST":
		return CurrencyCodeGhst, nil
	case "GIP":
		return CurrencyCodeGip, nil
	case "GLM":
		return CurrencyCodeGlm, nil
	case "GMD":
		return CurrencyCodeGmd, nil
	case "GMT":
		return CurrencyCodeGmt, nil
	case "GNF":
		return CurrencyCodeGnf, nil
	case "GNO":
		return CurrencyCodeGno, nil
	case "GNT":
		return CurrencyCodeGnt, nil
	case "GODS":
		return CurrencyCodeGods, nil
	case "GRT":
		return CurrencyCodeGrt, nil
	case "GST":
		return CurrencyCodeGst, nil
	case "GTC":
		return CurrencyCodeGtc, nil
	case "GTQ":
		return CurrencyCodeGtq, nil
	case "GUSD":
		return CurrencyCodeGusd, nil
	case "GYD":
		return CurrencyCodeGyd, nil
	case "GYEN":
		return CurrencyCodeGyen, nil
	case "HBAR":
		return CurrencyCodeHbar, nil
	case "HFT":
		return CurrencyCodeHft, nil
	case "HIGH":
		return CurrencyCodeHigh, nil
	case "HKD":
		return CurrencyCodeHkd, nil
	case "HNL":
		return CurrencyCodeHnl, nil
	case "HNT":
		return CurrencyCodeHnt, nil
	case "HONEY":
		return CurrencyCodeHoney, nil
	case "HOPR":
		return CurrencyCodeHopr, nil
	case "HRK":
		return CurrencyCodeHrk, nil
	case "HTG":
		return CurrencyCodeHtg, nil
	case "HUF":
		return CurrencyCodeHuf, nil
	case "ICP":
		return CurrencyCodeIcp, nil
	case "IDEX":
		return CurrencyCodeIdex, nil
	case "IDR":
		return CurrencyCodeIdr, nil
	case "ILS":
		return CurrencyCodeIls, nil
	case "ILV":
		return CurrencyCodeIlv, nil
	case "IMP":
		return CurrencyCodeImp, nil
	case "IMX":
		return CurrencyCodeImx, nil
	case "INDEX":
		return CurrencyCodeIndex, nil
	case "INJ":
		return CurrencyCodeInj, nil
	case "INR":
		return CurrencyCodeInr, nil
	case "INV":
		return CurrencyCodeInv, nil
	case "IOTX":
		return CurrencyCodeIotx, nil
	case "IQD":
		return CurrencyCodeIqd, nil
	case "IRR":
		return CurrencyCodeIrr, nil
	case "ISK":
		return CurrencyCodeIsk, nil
	case "JASMY":
		return CurrencyCodeJasmy, nil
	case "JEP":
		return CurrencyCodeJep, nil
	case "JMD":
		return CurrencyCodeJmd, nil
	case "JOD":
		return CurrencyCodeJod, nil
	case "JPY":
		return CurrencyCodeJpy, nil
	case "JTO":
		return CurrencyCodeJto, nil
	case "JUP":
		return CurrencyCodeJup, nil
	case "KAVA":
		return CurrencyCodeKava, nil
	case "KEEP":
		return CurrencyCodeKeep, nil
	case "KES":
		return CurrencyCodeKes, nil
	case "KGS":
		return CurrencyCodeKgs, nil
	case "KHR":
		return CurrencyCodeKhr, nil
	case "KMF":
		return CurrencyCodeKmf, nil
	case "KNC":
		return CurrencyCodeKnc, nil
	case "KPW":
		return CurrencyCodeKpw, nil
	case "KRL":
		return CurrencyCodeKrl, nil
	case "KRW":
		return CurrencyCodeKrw, nil
	case "KSM":
		return CurrencyCodeKsm, nil
	case "KWD":
		return CurrencyCodeKwd, nil
	case "KYD":
		return CurrencyCodeKyd, nil
	case "KZT":
		return CurrencyCodeKzt, nil
	case "LAK":
		return CurrencyCodeLak, nil
	case "LBP":
		return CurrencyCodeLbp, nil
	case "LCX":
		return CurrencyCodeLcx, nil
	case "LDO":
		return CurrencyCodeLdo, nil
	case "LINK":
		return CurrencyCodeLink, nil
	case "LIT":
		return CurrencyCodeLit, nil
	case "LKR":
		return CurrencyCodeLkr, nil
	case "LOKA":
		return CurrencyCodeLoka, nil
	case "LOOM":
		return CurrencyCodeLoom, nil
	case "LPT":
		return CurrencyCodeLpt, nil
	case "LQTY":
		return CurrencyCodeLqty, nil
	case "LRC":
		return CurrencyCodeLrc, nil
	case "LRD":
		return CurrencyCodeLrd, nil
	case "LSETH":
		return CurrencyCodeLseth, nil
	case "LSL":
		return CurrencyCodeLsl, nil
	case "LTC":
		return CurrencyCodeLtc, nil
	case "LTL":
		return CurrencyCodeLtl, nil
	case "LVL":
		return CurrencyCodeLvl, nil
	case "LYD":
		return CurrencyCodeLyd, nil
	case "MAD":
		return CurrencyCodeMad, nil
	case "MAGIC":
		return CurrencyCodeMagic, nil
	case "MANA":
		return CurrencyCodeMana, nil
	case "MASK":
		return CurrencyCodeMask, nil
	case "MATH":
		return CurrencyCodeMath, nil
	case "MATIC":
		return CurrencyCodeMatic, nil
	case "MCO2":
		return CurrencyCodeMco2, nil
	case "MDL":
		return CurrencyCodeMdl, nil
	case "MDT":
		return CurrencyCodeMdt, nil
	case "MEDIA":
		return CurrencyCodeMedia, nil
	case "METIS":
		return CurrencyCodeMetis, nil
	case "MGA":
		return CurrencyCodeMga, nil
	case "MINA":
		return CurrencyCodeMina, nil
	case "MIR":
		return CurrencyCodeMir, nil
	case "MKD":
		return CurrencyCodeMkd, nil
	case "MKR":
		return CurrencyCodeMkr, nil
	case "MLN":
		return CurrencyCodeMln, nil
	case "MMK":
		return CurrencyCodeMmk, nil
	case "MNDE":
		return CurrencyCodeMnde, nil
	case "MNT":
		return CurrencyCodeMnt, nil
	case "MOBILE":
		return CurrencyCodeMobile, nil
	case "MONA":
		return CurrencyCodeMona, nil
	case "MOP":
		return CurrencyCodeMop, nil
	case "MPL":
		return CurrencyCodeMpl, nil
	case "MRO":
		return CurrencyCodeMro, nil
	case "MRU":
		return CurrencyCodeMru, nil
	case "MSOL":
		return CurrencyCodeMsol, nil
	case "MTL":
		return CurrencyCodeMtl, nil
	case "MULTI":
		return CurrencyCodeMulti, nil
	case "MUR":
		return CurrencyCodeMur, nil
	case "MUSE":
		return CurrencyCodeMuse, nil
	case "MVR":
		return CurrencyCodeMvr, nil
	case "MWK":
		return CurrencyCodeMwk, nil
	case "MXC":
		return CurrencyCodeMxc, nil
	case "MXN":
		return CurrencyCodeMxn, nil
	case "MYR":
		return CurrencyCodeMyr, nil
	case "MZN":
		return CurrencyCodeMzn, nil
	case "NAD":
		return CurrencyCodeNad, nil
	case "NCT":
		return CurrencyCodeNct, nil
	case "NEAR":
		return CurrencyCodeNear, nil
	case "NEST":
		return CurrencyCodeNest, nil
	case "NGN":
		return CurrencyCodeNgn, nil
	case "NIO":
		return CurrencyCodeNio, nil
	case "NKN":
		return CurrencyCodeNkn, nil
	case "NMR":
		return CurrencyCodeNmr, nil
	case "NOK":
		return CurrencyCodeNok, nil
	case "NPR":
		return CurrencyCodeNpr, nil
	case "NU":
		return CurrencyCodeNu, nil
	case "NZD":
		return CurrencyCodeNzd, nil
	case "OCEAN":
		return CurrencyCodeOcean, nil
	case "OGN":
		return CurrencyCodeOgn, nil
	case "OMG":
		return CurrencyCodeOmg, nil
	case "OMR":
		return CurrencyCodeOmr, nil
	case "ONDO":
		return CurrencyCodeOndo, nil
	case "OOKI":
		return CurrencyCodeOoki, nil
	case "OP":
		return CurrencyCodeOp, nil
	case "ORCA":
		return CurrencyCodeOrca, nil
	case "ORN":
		return CurrencyCodeOrn, nil
	case "OSMO":
		return CurrencyCodeOsmo, nil
	case "OXT":
		return CurrencyCodeOxt, nil
	case "PAB":
		return CurrencyCodePab, nil
	case "PAX":
		return CurrencyCodePax, nil
	case "PEN":
		return CurrencyCodePen, nil
	case "PENGU":
		return CurrencyCodePengu, nil
	case "PERP":
		return CurrencyCodePerp, nil
	case "PGK":
		return CurrencyCodePgk, nil
	case "PHP":
		return CurrencyCodePhp, nil
	case "PKR":
		return CurrencyCodePkr, nil
	case "PLA":
		return CurrencyCodePla, nil
	case "PLN":
		return CurrencyCodePln, nil
	case "PLU":
		return CurrencyCodePlu, nil
	case "PNG":
		return CurrencyCodePng, nil
	case "POL":
		return CurrencyCodePol, nil
	case "POLS":
		return CurrencyCodePols, nil
	case "POLY":
		return CurrencyCodePoly, nil
	case "POND":
		return CurrencyCodePond, nil
	case "POWR":
		return CurrencyCodePowr, nil
	case "PRIME":
		return CurrencyCodePrime, nil
	case "PRO":
		return CurrencyCodePro, nil
	case "PRQ":
		return CurrencyCodePrq, nil
	case "PUNDIX":
		return CurrencyCodePundix, nil
	case "PYG":
		return CurrencyCodePyg, nil
	case "PYR":
		return CurrencyCodePyr, nil
	case "PYUSD":
		return CurrencyCodePyusd, nil
	case "QAR":
		return CurrencyCodeQar, nil
	case "QI":
		return CurrencyCodeQi, nil
	case "QNT":
		return CurrencyCodeQnt, nil
	case "QSP":
		return CurrencyCodeQsp, nil
	case "QUICK":
		return CurrencyCodeQuick, nil
	case "RAD":
		return CurrencyCodeRad, nil
	case "RAI":
		return CurrencyCodeRai, nil
	case "RARE":
		return CurrencyCodeRare, nil
	case "RARI":
		return CurrencyCodeRari, nil
	case "RBN":
		return CurrencyCodeRbn, nil
	case "REN":
		return CurrencyCodeRen, nil
	case "RENDER":
		return CurrencyCodeRender, nil
	case "REP":
		return CurrencyCodeRep, nil
	case "REPV2":
		return CurrencyCodeRepv2, nil
	case "REQ":
		return CurrencyCodeReq, nil
	case "RGT":
		return CurrencyCodeRgt, nil
	case "RLC":
		return CurrencyCodeRlc, nil
	case "RLY":
		return CurrencyCodeRly, nil
	case "RNDR":
		return CurrencyCodeRndr, nil
	case "RON":
		return CurrencyCodeRon, nil
	case "ROSE":
		return CurrencyCodeRose, nil
	case "RPL":
		return CurrencyCodeRpl, nil
	case "RSD":
		return CurrencyCodeRsd, nil
	case "RUB":
		return CurrencyCodeRub, nil
	case "RUNE":
		return CurrencyCodeRune, nil
	case "RWF":
		return CurrencyCodeRwf, nil
	case "SAND":
		return CurrencyCodeSand, nil
	case "SAR":
		return CurrencyCodeSar, nil
	case "SBD":
		return CurrencyCodeSbd, nil
	case "SCR":
		return CurrencyCodeScr, nil
	case "SDG":
		return CurrencyCodeSdg, nil
	case "SEAM":
		return CurrencyCodeSeam, nil
	case "SEI":
		return CurrencyCodeSei, nil
	case "SEK":
		return CurrencyCodeSek, nil
	case "SGD":
		return CurrencyCodeSgd, nil
	case "SHIB":
		return CurrencyCodeShib, nil
	case "SHP":
		return CurrencyCodeShp, nil
	case "SHPING":
		return CurrencyCodeShping, nil
	case "SKK":
		return CurrencyCodeSkk, nil
	case "SKL":
		return CurrencyCodeSkl, nil
	case "SLL":
		return CurrencyCodeSll, nil
	case "SNT":
		return CurrencyCodeSnt, nil
	case "SNX":
		return CurrencyCodeSnx, nil
	case "SOL":
		return CurrencyCodeSol, nil
	case "SOS":
		return CurrencyCodeSos, nil
	case "SPA":
		return CurrencyCodeSpa, nil
	case "SPELL":
		return CurrencyCodeSpell, nil
	case "SRD":
		return CurrencyCodeSrd, nil
	case "SSP":
		return CurrencyCodeSsp, nil
	case "STD":
		return CurrencyCodeStd, nil
	case "STG":
		return CurrencyCodeStg, nil
	case "STORJ":
		return CurrencyCodeStorj, nil
	case "STRK":
		return CurrencyCodeStrk, nil
	case "STX":
		return CurrencyCodeStx, nil
	case "SUI":
		return CurrencyCodeSui, nil
	case "SUKU":
		return CurrencyCodeSuku, nil
	case "SUPER":
		return CurrencyCodeSuper, nil
	case "SUSHI":
		return CurrencyCodeSushi, nil
	case "SVC":
		return CurrencyCodeSvc, nil
	case "SWFTC":
		return CurrencyCodeSwftc, nil
	case "SYLO":
		return CurrencyCodeSylo, nil
	case "SYN":
		return CurrencyCodeSyn, nil
	case "SYP":
		return CurrencyCodeSyp, nil
	case "SZL":
		return CurrencyCodeSzl, nil
	case "T":
		return CurrencyCodeT, nil
	case "THB":
		return CurrencyCodeThb, nil
	case "THETA":
		return CurrencyCodeTheta, nil
	case "TIA":
		return CurrencyCodeTia, nil
	case "TIME":
		return CurrencyCodeTime, nil
	case "TJS":
		return CurrencyCodeTjs, nil
	case "TMM":
		return CurrencyCodeTmm, nil
	case "TMT":
		return CurrencyCodeTmt, nil
	case "TND":
		return CurrencyCodeTnd, nil
	case "TONE":
		return CurrencyCodeTone, nil
	case "TOP":
		return CurrencyCodeTop, nil
	case "TRAC":
		return CurrencyCodeTrac, nil
	case "TRB":
		return CurrencyCodeTrb, nil
	case "TRIBE":
		return CurrencyCodeTribe, nil
	case "TRU":
		return CurrencyCodeTru, nil
	case "TRY":
		return CurrencyCodeTry, nil
	case "TTD":
		return CurrencyCodeTtd, nil
	case "TVK":
		return CurrencyCodeTvk, nil
	case "TWD":
		return CurrencyCodeTwd, nil
	case "TZS":
		return CurrencyCodeTzs, nil
	case "UAH":
		return CurrencyCodeUah, nil
	case "UGX":
		return CurrencyCodeUgx, nil
	case "UMA":
		return CurrencyCodeUma, nil
	case "UNFI":
		return CurrencyCodeUnfi, nil
	case "UNI":
		return CurrencyCodeUni, nil
	case "UPI":
		return CurrencyCodeUpi, nil
	case "USD":
		return CurrencyCodeUsd, nil
	case "USDC":
		return CurrencyCodeUsdc, nil
	case "USDT":
		return CurrencyCodeUsdt, nil
	case "UST":
		return CurrencyCodeUst, nil
	case "UYU":
		return CurrencyCodeUyu, nil
	case "UZS":
		return CurrencyCodeUzs, nil
	case "VARA":
		return CurrencyCodeVara, nil
	case "VEF":
		return CurrencyCodeVef, nil
	case "VELO":
		return CurrencyCodeVelo, nil
	case "VES":
		return CurrencyCodeVes, nil
	case "VET":
		return CurrencyCodeVet, nil
	case "VGX":
		return CurrencyCodeVgx, nil
	case "VND":
		return CurrencyCodeVnd, nil
	case "VOXEL":
		return CurrencyCodeVoxel, nil
	case "VTHO":
		return CurrencyCodeVtho, nil
	case "VUV":
		return CurrencyCodeVuv, nil
	case "WAMPL":
		return CurrencyCodeWampl, nil
	case "WAXL":
		return CurrencyCodeWaxl, nil
	case "WBTC":
		return CurrencyCodeWbtc, nil
	case "WCFG":
		return CurrencyCodeWcfg, nil
	case "WLUNA":
		return CurrencyCodeWluna, nil
	case "WST":
		return CurrencyCodeWst, nil
	case "XAF":
		return CurrencyCodeXaf, nil
	case "XAG":
		return CurrencyCodeXag, nil
	case "XAU":
		return CurrencyCodeXau, nil
	case "XCD":
		return CurrencyCodeXcd, nil
	case "XCN":
		return CurrencyCodeXcn, nil
	case "XDR":
		return CurrencyCodeXdr, nil
	case "XLM":
		return CurrencyCodeXlm, nil
	case "XMON":
		return CurrencyCodeXmon, nil
	case "XOF":
		return CurrencyCodeXof, nil
	case "XPD":
		return CurrencyCodeXpd, nil
	case "XPF":
		return CurrencyCodeXpf, nil
	case "XPT":
		return CurrencyCodeXpt, nil
	case "XRP":
		return CurrencyCodeXrp, nil
	case "XTZ":
		return CurrencyCodeXtz, nil
	case "XYO":
		return CurrencyCodeXyo, nil
	case "YER":
		return CurrencyCodeYer, nil
	case "YFI":
		return CurrencyCodeYfi, nil
	case "YFII":
		return CurrencyCodeYfii, nil
	case "ZAR":
		return CurrencyCodeZar, nil
	case "ZEC":
		return CurrencyCodeZec, nil
	case "ZEN":
		return CurrencyCodeZen, nil
	case "ZETA":
		return CurrencyCodeZeta, nil
	case "ZMK":
		return CurrencyCodeZmk, nil
	case "ZMW":
		return CurrencyCodeZmw, nil
	case "ZRX":
		return CurrencyCodeZrx, nil
	case "ZWD":
		return CurrencyCodeZwd, nil
	case "FDUSD":
		return CurrencyCodeFdusd, nil
	case "AGX":
		return CurrencyCodeAgx, nil
	case "AUX":
		return CurrencyCodeAux, nil
	case "BNB":
		return CurrencyCodeBnb, nil
	case "CUBE":
		return CurrencyCodeCube, nil
	case "EMON":
		return CurrencyCodeEmon, nil
	case "FDGT":
		return CurrencyCodeFdgt, nil
	case "KGLD":
		return CurrencyCodeKgld, nil
	case "LODE":
		return CurrencyCodeLode, nil
	case "PASS":
		return CurrencyCodePass, nil
	case "PREMIA":
		return CurrencyCodePremia, nil
	case "TAB1":
		return CurrencyCodeTab1, nil
	case "TD-USD":
		return CurrencyCodeTdUsd, nil
	case "TRX":
		return CurrencyCodeTrx, nil
	case "TYUGA":
		return CurrencyCodeTyuga, nil
	case "VIC":
		return CurrencyCodeVic, nil
	case "XAI":
		return CurrencyCodeXai, nil
	case "SLE":
		return CurrencyCodeSle, nil
	}
	var t CurrencyCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CurrencyCode) Ptr() *CurrencyCode {
	return &c
}

type CustomColumn struct {
	Key        string     `json:"key" url:"key"`
	Type       ColumnType `json:"type" url:"type"`
	PrimaryKey *bool      `json:"primaryKey,omitempty" url:"primaryKey,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomColumn) GetKey() string {
	if c == nil {
		return ""
	}
	return c.Key
}

func (c *CustomColumn) GetType() ColumnType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CustomColumn) GetPrimaryKey() *bool {
	if c == nil {
		return nil
	}
	return c.PrimaryKey
}

func (c *CustomColumn) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomColumn) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomColumn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomColumn(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomColumn) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Model for date
type Date struct {
	// Day of date
	Day float64 `json:"day" url:"day"`
	// Month of date
	Month float64 `json:"month" url:"month"`
	// Year of date
	Year float64 `json:"year" url:"year"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Date) GetDay() float64 {
	if d == nil {
		return 0
	}
	return d.Day
}

func (d *Date) GetMonth() float64 {
	if d == nil {
		return 0
	}
	return d.Month
}

func (d *Date) GetYear() float64 {
	if d == nil {
		return 0
	}
	return d.Year
}

func (d *Date) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Date) UnmarshalJSON(data []byte) error {
	type unmarshaler Date
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Date(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Date) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Model for device data
type DeviceData struct {
	// Battery level of the device used for a transaction or event at a given timestamp
	BatteryLevel *float64 `json:"batteryLevel,omitempty" url:"batteryLevel,omitempty"`
	// Device latitude at a give timestamp for an event or transaction
	DeviceLatitude *float64 `json:"deviceLatitude,omitempty" url:"deviceLatitude,omitempty"`
	// Device longitude at a give timestamp for an event or transaction
	DeviceLongitude *float64 `json:"deviceLongitude,omitempty" url:"deviceLongitude,omitempty"`
	// IP address of the device at a given timestamp for an event or transaction
	IpAddress *string      `json:"ipAddress,omitempty" url:"ipAddress,omitempty"`
	IpCountry *CountryCode `json:"ipCountry,omitempty" url:"ipCountry,omitempty"`
	// Device identifier number
	DeviceIdentifier *string `json:"deviceIdentifier,omitempty" url:"deviceIdentifier,omitempty"`
	// Whether VPN was used at a given timestamp for an event or transaction
	VpnUsed *bool `json:"vpnUsed,omitempty" url:"vpnUsed,omitempty"`
	// Operating system of the device at a given timestamp for an event or transaction
	OperatingSystem *string `json:"operatingSystem,omitempty" url:"operatingSystem,omitempty"`
	// The maker of the device at a given timestamp for an event or transaction
	DeviceMaker *string `json:"deviceMaker,omitempty" url:"deviceMaker,omitempty"`
	// The model of the device at a given timestamp for an event or transaction
	DeviceModel *string `json:"deviceModel,omitempty" url:"deviceModel,omitempty"`
	// The year the device was manufactured at a given timestamp for an event or transaction
	DeviceYear *string `json:"deviceYear,omitempty" url:"deviceYear,omitempty"`
	// The version of the app your user is using on their device at a given timestamp for an event or transaction
	AppVersion *string `json:"appVersion,omitempty" url:"appVersion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceData) GetBatteryLevel() *float64 {
	if d == nil {
		return nil
	}
	return d.BatteryLevel
}

func (d *DeviceData) GetDeviceLatitude() *float64 {
	if d == nil {
		return nil
	}
	return d.DeviceLatitude
}

func (d *DeviceData) GetDeviceLongitude() *float64 {
	if d == nil {
		return nil
	}
	return d.DeviceLongitude
}

func (d *DeviceData) GetIpAddress() *string {
	if d == nil {
		return nil
	}
	return d.IpAddress
}

func (d *DeviceData) GetIpCountry() *CountryCode {
	if d == nil {
		return nil
	}
	return d.IpCountry
}

func (d *DeviceData) GetDeviceIdentifier() *string {
	if d == nil {
		return nil
	}
	return d.DeviceIdentifier
}

func (d *DeviceData) GetVpnUsed() *bool {
	if d == nil {
		return nil
	}
	return d.VpnUsed
}

func (d *DeviceData) GetOperatingSystem() *string {
	if d == nil {
		return nil
	}
	return d.OperatingSystem
}

func (d *DeviceData) GetDeviceMaker() *string {
	if d == nil {
		return nil
	}
	return d.DeviceMaker
}

func (d *DeviceData) GetDeviceModel() *string {
	if d == nil {
		return nil
	}
	return d.DeviceModel
}

func (d *DeviceData) GetDeviceYear() *string {
	if d == nil {
		return nil
	}
	return d.DeviceYear
}

func (d *DeviceData) GetAppVersion() *string {
	if d == nil {
		return nil
	}
	return d.AppVersion
}

func (d *DeviceData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Email ID format. Ex: baran@flagright.com
type EmailId = string

// Details of User's employment
type EmploymentDetails struct {
	// Sector of employment
	EmploymentSector *string `json:"employmentSector,omitempty" url:"employmentSector,omitempty"`
	// Name of the employer
	EmployerName *string `json:"employerName,omitempty" url:"employerName,omitempty"`
	// The industry in which the business operates for a business customer
	BusinessIndustry []string `json:"businessIndustry,omitempty" url:"businessIndustry,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmploymentDetails) GetEmploymentSector() *string {
	if e == nil {
		return nil
	}
	return e.EmploymentSector
}

func (e *EmploymentDetails) GetEmployerName() *string {
	if e == nil {
		return nil
	}
	return e.EmployerName
}

func (e *EmploymentDetails) GetBusinessIndustry() []string {
	if e == nil {
		return nil
	}
	return e.BusinessIndustry
}

func (e *EmploymentDetails) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmploymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler EmploymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmploymentDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmploymentDetails) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmploymentStatus string

const (
	EmploymentStatusUnemployed     EmploymentStatus = "UNEMPLOYED"
	EmploymentStatusEmployed       EmploymentStatus = "EMPLOYED"
	EmploymentStatusSelfEmployed   EmploymentStatus = "SELF_EMPLOYED"
	EmploymentStatusFreelancer     EmploymentStatus = "FREELANCER"
	EmploymentStatusStudent        EmploymentStatus = "STUDENT"
	EmploymentStatusFullTime       EmploymentStatus = "FULL_TIME"
	EmploymentStatusPartTime       EmploymentStatus = "PART_TIME"
	EmploymentStatusSoleProprietor EmploymentStatus = "SOLE_PROPRIETOR"
	EmploymentStatusPensioner      EmploymentStatus = "PENSIONER"
	EmploymentStatusCompanyOwner   EmploymentStatus = "COMPANY_OWNER"
	EmploymentStatusOther          EmploymentStatus = "OTHER"
	EmploymentStatusNa             EmploymentStatus = "NA"
)

func NewEmploymentStatusFromString(s string) (EmploymentStatus, error) {
	switch s {
	case "UNEMPLOYED":
		return EmploymentStatusUnemployed, nil
	case "EMPLOYED":
		return EmploymentStatusEmployed, nil
	case "SELF_EMPLOYED":
		return EmploymentStatusSelfEmployed, nil
	case "FREELANCER":
		return EmploymentStatusFreelancer, nil
	case "STUDENT":
		return EmploymentStatusStudent, nil
	case "FULL_TIME":
		return EmploymentStatusFullTime, nil
	case "PART_TIME":
		return EmploymentStatusPartTime, nil
	case "SOLE_PROPRIETOR":
		return EmploymentStatusSoleProprietor, nil
	case "PENSIONER":
		return EmploymentStatusPensioner, nil
	case "COMPANY_OWNER":
		return EmploymentStatusCompanyOwner, nil
	case "OTHER":
		return EmploymentStatusOther, nil
	case "NA":
		return EmploymentStatusNa, nil
	}
	var t EmploymentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmploymentStatus) Ptr() *EmploymentStatus {
	return &e
}

type ExecutedLogicVars struct {
	Direction *RuleHitDirection      `json:"direction,omitempty" url:"direction,omitempty"`
	Value     map[string]interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExecutedLogicVars) GetDirection() *RuleHitDirection {
	if e == nil {
		return nil
	}
	return e.Direction
}

func (e *ExecutedLogicVars) GetValue() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *ExecutedLogicVars) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExecutedLogicVars) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecutedLogicVars
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecutedLogicVars(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutedLogicVars) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Model for list of executed rules
type ExecutedRulesResult struct {
	// Unique rule identifier
	RuleId         *string `json:"ruleId,omitempty" url:"ruleId,omitempty"`
	RuleInstanceId string  `json:"ruleInstanceId" url:"ruleInstanceId"`
	// Name of the rule
	RuleName string `json:"ruleName" url:"ruleName"`
	// Description of the rule
	RuleDescription string     `json:"ruleDescription" url:"ruleDescription"`
	RuleAction      RuleAction `json:"ruleAction" url:"ruleAction"`
	RuleHit         bool       `json:"ruleHit" url:"ruleHit"`
	// Timestamp when the rule was executed
	ExecutedAt  *float64             `json:"executedAt,omitempty" url:"executedAt,omitempty"`
	RuleHitMeta *RuleHitMeta         `json:"ruleHitMeta,omitempty" url:"ruleHitMeta,omitempty"`
	Vars        []*ExecutedLogicVars `json:"vars,omitempty" url:"vars,omitempty"`
	Labels      []RuleLabels         `json:"labels,omitempty" url:"labels,omitempty"`
	Nature      *RuleNature          `json:"nature,omitempty" url:"nature,omitempty"`
	IsShadow    *bool                `json:"isShadow,omitempty" url:"isShadow,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExecutedRulesResult) GetRuleId() *string {
	if e == nil {
		return nil
	}
	return e.RuleId
}

func (e *ExecutedRulesResult) GetRuleInstanceId() string {
	if e == nil {
		return ""
	}
	return e.RuleInstanceId
}

func (e *ExecutedRulesResult) GetRuleName() string {
	if e == nil {
		return ""
	}
	return e.RuleName
}

func (e *ExecutedRulesResult) GetRuleDescription() string {
	if e == nil {
		return ""
	}
	return e.RuleDescription
}

func (e *ExecutedRulesResult) GetRuleAction() RuleAction {
	if e == nil {
		return ""
	}
	return e.RuleAction
}

func (e *ExecutedRulesResult) GetRuleHit() bool {
	if e == nil {
		return false
	}
	return e.RuleHit
}

func (e *ExecutedRulesResult) GetExecutedAt() *float64 {
	if e == nil {
		return nil
	}
	return e.ExecutedAt
}

func (e *ExecutedRulesResult) GetRuleHitMeta() *RuleHitMeta {
	if e == nil {
		return nil
	}
	return e.RuleHitMeta
}

func (e *ExecutedRulesResult) GetVars() []*ExecutedLogicVars {
	if e == nil {
		return nil
	}
	return e.Vars
}

func (e *ExecutedRulesResult) GetLabels() []RuleLabels {
	if e == nil {
		return nil
	}
	return e.Labels
}

func (e *ExecutedRulesResult) GetNature() *RuleNature {
	if e == nil {
		return nil
	}
	return e.Nature
}

func (e *ExecutedRulesResult) GetIsShadow() *bool {
	if e == nil {
		return nil
	}
	return e.IsShadow
}

func (e *ExecutedRulesResult) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExecutedRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecutedRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecutedRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutedRulesResult) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Model for expected income details
type ExpectedIncome struct {
	DailyExpectedIncome     *Amount `json:"dailyExpectedIncome,omitempty" url:"dailyExpectedIncome,omitempty"`
	WeeklyExpectedIncome    *Amount `json:"weeklyExpectedIncome,omitempty" url:"weeklyExpectedIncome,omitempty"`
	MonthlyExpectedIncome   *Amount `json:"monthlyExpectedIncome,omitempty" url:"monthlyExpectedIncome,omitempty"`
	QuarterlyExpectedIncome *Amount `json:"quarterlyExpectedIncome,omitempty" url:"quarterlyExpectedIncome,omitempty"`
	YearlyExpectedIncome    *Amount `json:"yearlyExpectedIncome,omitempty" url:"yearlyExpectedIncome,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExpectedIncome) GetDailyExpectedIncome() *Amount {
	if e == nil {
		return nil
	}
	return e.DailyExpectedIncome
}

func (e *ExpectedIncome) GetWeeklyExpectedIncome() *Amount {
	if e == nil {
		return nil
	}
	return e.WeeklyExpectedIncome
}

func (e *ExpectedIncome) GetMonthlyExpectedIncome() *Amount {
	if e == nil {
		return nil
	}
	return e.MonthlyExpectedIncome
}

func (e *ExpectedIncome) GetQuarterlyExpectedIncome() *Amount {
	if e == nil {
		return nil
	}
	return e.QuarterlyExpectedIncome
}

func (e *ExpectedIncome) GetYearlyExpectedIncome() *Amount {
	if e == nil {
		return nil
	}
	return e.YearlyExpectedIncome
}

func (e *ExpectedIncome) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExpectedIncome) UnmarshalJSON(data []byte) error {
	type unmarshaler ExpectedIncome
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExpectedIncome(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExpectedIncome) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Model for list of rules failed execution. It means rules could not be run
type FailedRulesResult struct {
	// Unique rule identifier
	RuleId string `json:"ruleId" url:"ruleId"`
	// Name of the rule
	RuleName string `json:"ruleName" url:"ruleName"`
	// Description of the rule
	RuleDescription  string                `json:"ruleDescription" url:"ruleDescription"`
	FailureException *RuleFailureException `json:"failureException,omitempty" url:"failureException,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FailedRulesResult) GetRuleId() string {
	if f == nil {
		return ""
	}
	return f.RuleId
}

func (f *FailedRulesResult) GetRuleName() string {
	if f == nil {
		return ""
	}
	return f.RuleName
}

func (f *FailedRulesResult) GetRuleDescription() string {
	if f == nil {
		return ""
	}
	return f.RuleDescription
}

func (f *FailedRulesResult) GetFailureException() *RuleFailureException {
	if f == nil {
		return nil
	}
	return f.FailureException
}

func (f *FailedRulesResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FailedRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FailedRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FailedRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FailedRulesResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FalsePositiveDetails struct {
	IsFalsePositive bool    `json:"isFalsePositive" url:"isFalsePositive"`
	ConfidenceScore float64 `json:"confidenceScore" url:"confidenceScore"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FalsePositiveDetails) GetIsFalsePositive() bool {
	if f == nil {
		return false
	}
	return f.IsFalsePositive
}

func (f *FalsePositiveDetails) GetConfidenceScore() float64 {
	if f == nil {
		return 0
	}
	return f.ConfidenceScore
}

func (f *FalsePositiveDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FalsePositiveDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FalsePositiveDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FalsePositiveDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FalsePositiveDetails) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileInfo struct {
	S3Key        string  `json:"s3Key" url:"s3Key"`
	Bucket       *string `json:"bucket,omitempty" url:"bucket,omitempty"`
	Filename     string  `json:"filename" url:"filename"`
	Size         float64 `json:"size" url:"size"`
	DownloadLink *string `json:"downloadLink,omitempty" url:"downloadLink,omitempty"`
	AiSummary    *string `json:"aiSummary,omitempty" url:"aiSummary,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileInfo) GetS3Key() string {
	if f == nil {
		return ""
	}
	return f.S3Key
}

func (f *FileInfo) GetBucket() *string {
	if f == nil {
		return nil
	}
	return f.Bucket
}

func (f *FileInfo) GetFilename() string {
	if f == nil {
		return ""
	}
	return f.Filename
}

func (f *FileInfo) GetSize() float64 {
	if f == nil {
		return 0
	}
	return f.Size
}

func (f *FileInfo) GetDownloadLink() *string {
	if f == nil {
		return nil
	}
	return f.DownloadLink
}

func (f *FileInfo) GetAiSummary() *string {
	if f == nil {
		return nil
	}
	return f.AiSummary
}

func (f *FileInfo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FileInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileInfo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Gender of the individual - Male, Female or Non-Binary
type Gender string

const (
	GenderM  Gender = "M"
	GenderF  Gender = "F"
	GenderNb Gender = "NB"
)

func NewGenderFromString(s string) (Gender, error) {
	switch s {
	case "M":
		return GenderM, nil
	case "F":
		return GenderF, nil
	case "NB":
		return GenderNb, nil
	}
	var t Gender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g Gender) Ptr() *Gender {
	return &g
}

// Classify the method of payment as "GENERIC_BANK_ACCOUNT" for GenericBankAccountDetails
type GeneralBankAccountPaymentMethod = string

// Model for any generic bank account
type GenericBankAccountDetails struct {
	// Bank account number
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// Bank account type. E.g. Checking, Savings etc.
	AccountType    *string `json:"accountType,omitempty" url:"accountType,omitempty"`
	AccountBalance *Amount `json:"accountBalance,omitempty" url:"accountBalance,omitempty"`
	// Name of the bank
	BankName *string `json:"bankName,omitempty" url:"bankName,omitempty"`
	// Unique identifier of the bank. In some countries, this can be the same as the bank's SWIFT code
	BankCode *string      `json:"bankCode,omitempty" url:"bankCode,omitempty"`
	Country  *CountryCode `json:"country,omitempty" url:"country,omitempty"`
	// Name of the account holder
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Country of nationality of the account holder
	CountryOfNationality *CountryCode `json:"countryOfNationality,omitempty" url:"countryOfNationality,omitempty"`
	// Date of birth of the account holder (YYYY-MM-DD)
	DateOfBirth *string  `json:"dateOfBirth,omitempty" url:"dateOfBirth,omitempty"`
	BankAddress *Address `json:"bankAddress,omitempty" url:"bankAddress,omitempty"`
	EmailId     *EmailId `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Special instructions to be specified if any
	SpecialInstructions *string `json:"specialInstructions,omitempty" url:"specialInstructions,omitempty"`
	PaymentChannel      *string `json:"paymentChannel,omitempty" url:"paymentChannel,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`
	// Transit number of the bank account
	TransitNumber *string `json:"transitNumber,omitempty" url:"transitNumber,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GenericBankAccountDetails) GetAccountNumber() *string {
	if g == nil {
		return nil
	}
	return g.AccountNumber
}

func (g *GenericBankAccountDetails) GetAccountType() *string {
	if g == nil {
		return nil
	}
	return g.AccountType
}

func (g *GenericBankAccountDetails) GetAccountBalance() *Amount {
	if g == nil {
		return nil
	}
	return g.AccountBalance
}

func (g *GenericBankAccountDetails) GetBankName() *string {
	if g == nil {
		return nil
	}
	return g.BankName
}

func (g *GenericBankAccountDetails) GetBankCode() *string {
	if g == nil {
		return nil
	}
	return g.BankCode
}

func (g *GenericBankAccountDetails) GetCountry() *CountryCode {
	if g == nil {
		return nil
	}
	return g.Country
}

func (g *GenericBankAccountDetails) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GenericBankAccountDetails) GetCountryOfNationality() *CountryCode {
	if g == nil {
		return nil
	}
	return g.CountryOfNationality
}

func (g *GenericBankAccountDetails) GetDateOfBirth() *string {
	if g == nil {
		return nil
	}
	return g.DateOfBirth
}

func (g *GenericBankAccountDetails) GetBankAddress() *Address {
	if g == nil {
		return nil
	}
	return g.BankAddress
}

func (g *GenericBankAccountDetails) GetEmailId() *EmailId {
	if g == nil {
		return nil
	}
	return g.EmailId
}

func (g *GenericBankAccountDetails) GetSpecialInstructions() *string {
	if g == nil {
		return nil
	}
	return g.SpecialInstructions
}

func (g *GenericBankAccountDetails) GetPaymentChannel() *string {
	if g == nil {
		return nil
	}
	return g.PaymentChannel
}

func (g *GenericBankAccountDetails) GetTags() []*Tag {
	if g == nil {
		return nil
	}
	return g.Tags
}

func (g *GenericBankAccountDetails) GetTransitNumber() *string {
	if g == nil {
		return nil
	}
	return g.TransitNumber
}

func (g *GenericBankAccountDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenericBankAccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler GenericBankAccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenericBankAccountDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenericBankAccountDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Model for list of hit rules
type HitRulesDetails struct {
	// Unique rule identifier
	RuleId         *string `json:"ruleId,omitempty" url:"ruleId,omitempty"`
	RuleInstanceId string  `json:"ruleInstanceId" url:"ruleInstanceId"`
	// Name of the rule
	RuleName string `json:"ruleName" url:"ruleName"`
	// Description of the rule
	RuleDescription string `json:"ruleDescription" url:"ruleDescription"`
	// Timestamp when the rule was hit
	ExecutedAt  *float64     `json:"executedAt,omitempty" url:"executedAt,omitempty"`
	RuleAction  RuleAction   `json:"ruleAction" url:"ruleAction"`
	RuleHitMeta *RuleHitMeta `json:"ruleHitMeta,omitempty" url:"ruleHitMeta,omitempty"`
	Labels      []RuleLabels `json:"labels,omitempty" url:"labels,omitempty"`
	Nature      *RuleNature  `json:"nature,omitempty" url:"nature,omitempty"`
	IsShadow    *bool        `json:"isShadow,omitempty" url:"isShadow,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HitRulesDetails) GetRuleId() *string {
	if h == nil {
		return nil
	}
	return h.RuleId
}

func (h *HitRulesDetails) GetRuleInstanceId() string {
	if h == nil {
		return ""
	}
	return h.RuleInstanceId
}

func (h *HitRulesDetails) GetRuleName() string {
	if h == nil {
		return ""
	}
	return h.RuleName
}

func (h *HitRulesDetails) GetRuleDescription() string {
	if h == nil {
		return ""
	}
	return h.RuleDescription
}

func (h *HitRulesDetails) GetExecutedAt() *float64 {
	if h == nil {
		return nil
	}
	return h.ExecutedAt
}

func (h *HitRulesDetails) GetRuleAction() RuleAction {
	if h == nil {
		return ""
	}
	return h.RuleAction
}

func (h *HitRulesDetails) GetRuleHitMeta() *RuleHitMeta {
	if h == nil {
		return nil
	}
	return h.RuleHitMeta
}

func (h *HitRulesDetails) GetLabels() []RuleLabels {
	if h == nil {
		return nil
	}
	return h.Labels
}

func (h *HitRulesDetails) GetNature() *RuleNature {
	if h == nil {
		return nil
	}
	return h.Nature
}

func (h *HitRulesDetails) GetIsShadow() *bool {
	if h == nil {
		return nil
	}
	return h.IsShadow
}

func (h *HitRulesDetails) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HitRulesDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler HitRulesDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HitRulesDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HitRulesDetails) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HitRulesResults struct {
	// Uniquue transaction identifier
	HitRules []*HitRulesDetails `json:"hitRules,omitempty" url:"hitRules,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HitRulesResults) GetHitRules() []*HitRulesDetails {
	if h == nil {
		return nil
	}
	return h.HitRules
}

func (h *HitRulesResults) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HitRulesResults) UnmarshalJSON(data []byte) error {
	type unmarshaler HitRulesResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HitRulesResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HitRulesResults) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Standardized model for Bank Details
type IbanDetails struct {
	// Identifier for the bank. Can be routing number, BIK number, SWIFT code, BIC number etc.
	Bic *string `json:"BIC,omitempty" url:"BIC,omitempty"`
	// Name of the bank
	BankName    *string      `json:"bankName,omitempty" url:"bankName,omitempty"`
	BankAddress *Address     `json:"bankAddress,omitempty" url:"bankAddress,omitempty"`
	Country     *CountryCode `json:"country,omitempty" url:"country,omitempty"`
	// Account number of the user. Can be account number, IBAN number etc.
	Iban           *string `json:"IBAN,omitempty" url:"IBAN,omitempty"`
	AccountBalance *Amount `json:"accountBalance,omitempty" url:"accountBalance,omitempty"`
	// Name of the bank account holder
	Name    *string  `json:"name,omitempty" url:"name,omitempty"`
	EmailId *EmailId `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Branch code of the bank. In some countries, this can be the same as the bank's SWIFT code
	BankBranchCode *string `json:"bankBranchCode,omitempty" url:"bankBranchCode,omitempty"`
	PaymentChannel *string `json:"paymentChannel,omitempty" url:"paymentChannel,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IbanDetails) GetBic() *string {
	if i == nil {
		return nil
	}
	return i.Bic
}

func (i *IbanDetails) GetBankName() *string {
	if i == nil {
		return nil
	}
	return i.BankName
}

func (i *IbanDetails) GetBankAddress() *Address {
	if i == nil {
		return nil
	}
	return i.BankAddress
}

func (i *IbanDetails) GetCountry() *CountryCode {
	if i == nil {
		return nil
	}
	return i.Country
}

func (i *IbanDetails) GetIban() *string {
	if i == nil {
		return nil
	}
	return i.Iban
}

func (i *IbanDetails) GetAccountBalance() *Amount {
	if i == nil {
		return nil
	}
	return i.AccountBalance
}

func (i *IbanDetails) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *IbanDetails) GetEmailId() *EmailId {
	if i == nil {
		return nil
	}
	return i.EmailId
}

func (i *IbanDetails) GetBankBranchCode() *string {
	if i == nil {
		return nil
	}
	return i.BankBranchCode
}

func (i *IbanDetails) GetPaymentChannel() *string {
	if i == nil {
		return nil
	}
	return i.PaymentChannel
}

func (i *IbanDetails) GetTags() []*Tag {
	if i == nil {
		return nil
	}
	return i.Tags
}

func (i *IbanDetails) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IbanDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler IbanDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IbanDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IbanDetails) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Classify the method of payment as "IBAN" for IBANDetails
type IbanPaymentMethod = string

type KycStatus string

const (
	KycStatusSuccessful    KycStatus = "SUCCESSFUL"
	KycStatusFailed        KycStatus = "FAILED"
	KycStatusNotStarted    KycStatus = "NOT_STARTED"
	KycStatusInProgress    KycStatus = "IN_PROGRESS"
	KycStatusExpired       KycStatus = "EXPIRED"
	KycStatusNew           KycStatus = "NEW"
	KycStatusCancelled     KycStatus = "CANCELLED"
	KycStatusManualReview  KycStatus = "MANUAL_REVIEW"
	KycStatusEddInProgress KycStatus = "EDD_IN_PROGRESS"
)

func NewKycStatusFromString(s string) (KycStatus, error) {
	switch s {
	case "SUCCESSFUL":
		return KycStatusSuccessful, nil
	case "FAILED":
		return KycStatusFailed, nil
	case "NOT_STARTED":
		return KycStatusNotStarted, nil
	case "IN_PROGRESS":
		return KycStatusInProgress, nil
	case "EXPIRED":
		return KycStatusExpired, nil
	case "NEW":
		return KycStatusNew, nil
	case "CANCELLED":
		return KycStatusCancelled, nil
	case "MANUAL_REVIEW":
		return KycStatusManualReview, nil
	case "EDD_IN_PROGRESS":
		return KycStatusEddInProgress, nil
	}
	var t KycStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KycStatus) Ptr() *KycStatus {
	return &k
}

type KycStatusDetails struct {
	Reason *string    `json:"reason,omitempty" url:"reason,omitempty"`
	Status *KycStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KycStatusDetails) GetReason() *string {
	if k == nil {
		return nil
	}
	return k.Reason
}

func (k *KycStatusDetails) GetStatus() *KycStatus {
	if k == nil {
		return nil
	}
	return k.Status
}

func (k *KycStatusDetails) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KycStatusDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler KycStatusDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KycStatusDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KycStatusDetails) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// LegalDocument model generalizes User's identity document type (ex: Passport)
type LegalDocument struct {
	// User's identity document type such as passport, national ID etc.
	DocumentType string `json:"documentType" url:"documentType"`
	// User's unique identity document number such as passport number
	DocumentNumber string `json:"documentNumber" url:"documentNumber"`
	// User's identity document issuance date (UNIX timestamp in milliseconds)
	DocumentIssuedDate *float64 `json:"documentIssuedDate,omitempty" url:"documentIssuedDate,omitempty"`
	// User's identity document expiration date (UNIX timestamp in milliseconds)
	DocumentExpirationDate *float64    `json:"documentExpirationDate,omitempty" url:"documentExpirationDate,omitempty"`
	DocumentIssuedCountry  CountryCode `json:"documentIssuedCountry" url:"documentIssuedCountry"`
	// Additional information that can be added via tags
	Tags           []*Tag        `json:"tags,omitempty" url:"tags,omitempty"`
	NameOnDocument *ConsumerName `json:"nameOnDocument,omitempty" url:"nameOnDocument,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LegalDocument) GetDocumentType() string {
	if l == nil {
		return ""
	}
	return l.DocumentType
}

func (l *LegalDocument) GetDocumentNumber() string {
	if l == nil {
		return ""
	}
	return l.DocumentNumber
}

func (l *LegalDocument) GetDocumentIssuedDate() *float64 {
	if l == nil {
		return nil
	}
	return l.DocumentIssuedDate
}

func (l *LegalDocument) GetDocumentExpirationDate() *float64 {
	if l == nil {
		return nil
	}
	return l.DocumentExpirationDate
}

func (l *LegalDocument) GetDocumentIssuedCountry() CountryCode {
	if l == nil {
		return ""
	}
	return l.DocumentIssuedCountry
}

func (l *LegalDocument) GetTags() []*Tag {
	if l == nil {
		return nil
	}
	return l.Tags
}

func (l *LegalDocument) GetNameOnDocument() *ConsumerName {
	if l == nil {
		return nil
	}
	return l.NameOnDocument
}

func (l *LegalDocument) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LegalDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler LegalDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LegalDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LegalDocument) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Model for business user legal entity details
type LegalEntity struct {
	CompanyGeneralDetails      *CompanyGeneralDetails      `json:"companyGeneralDetails,omitempty" url:"companyGeneralDetails,omitempty"`
	CompanyFinancialDetails    *CompanyFinancialDetails    `json:"companyFinancialDetails,omitempty" url:"companyFinancialDetails,omitempty"`
	CompanyRegistrationDetails *CompanyRegistrationDetails `json:"companyRegistrationDetails,omitempty" url:"companyRegistrationDetails,omitempty"`
	ReasonForAccountOpening    []string                    `json:"reasonForAccountOpening,omitempty" url:"reasonForAccountOpening,omitempty"`
	SourceOfFunds              []SourceOfFunds             `json:"sourceOfFunds,omitempty" url:"sourceOfFunds,omitempty"`
	ContactDetails             *ContactDetails             `json:"contactDetails,omitempty" url:"contactDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LegalEntity) GetCompanyGeneralDetails() *CompanyGeneralDetails {
	if l == nil {
		return nil
	}
	return l.CompanyGeneralDetails
}

func (l *LegalEntity) GetCompanyFinancialDetails() *CompanyFinancialDetails {
	if l == nil {
		return nil
	}
	return l.CompanyFinancialDetails
}

func (l *LegalEntity) GetCompanyRegistrationDetails() *CompanyRegistrationDetails {
	if l == nil {
		return nil
	}
	return l.CompanyRegistrationDetails
}

func (l *LegalEntity) GetReasonForAccountOpening() []string {
	if l == nil {
		return nil
	}
	return l.ReasonForAccountOpening
}

func (l *LegalEntity) GetSourceOfFunds() []SourceOfFunds {
	if l == nil {
		return nil
	}
	return l.SourceOfFunds
}

func (l *LegalEntity) GetContactDetails() *ContactDetails {
	if l == nil {
		return nil
	}
	return l.ContactDetails
}

func (l *LegalEntity) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LegalEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler LegalEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LegalEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LegalEntity) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Payload of a list, new or existed
type ListData struct {
	Metadata *ListMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// List items
	Items []*ListItem `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListData) GetMetadata() *ListMetadata {
	if l == nil {
		return nil
	}
	return l.Metadata
}

func (l *ListData) GetItems() []*ListItem {
	if l == nil {
		return nil
	}
	return l.Items
}

func (l *ListData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListData) UnmarshalJSON(data []byte) error {
	type unmarshaler ListData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// List with ID and header
type ListExisted struct {
	ListId string      `json:"listId" url:"listId"`
	Header *ListHeader `json:"header,omitempty" url:"header,omitempty"`
	// List items
	Items []*ListItem `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListExisted) GetListId() string {
	if l == nil {
		return ""
	}
	return l.ListId
}

func (l *ListExisted) GetHeader() *ListHeader {
	if l == nil {
		return nil
	}
	return l.Header
}

func (l *ListExisted) GetItems() []*ListItem {
	if l == nil {
		return nil
	}
	return l.Items
}

func (l *ListExisted) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListExisted) UnmarshalJSON(data []byte) error {
	type unmarshaler ListExisted
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListExisted(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListExisted) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListHeader struct {
	ListId           string        `json:"listId" url:"listId"`
	ListType         ListType      `json:"listType" url:"listType"`
	Subtype          ListSubtype   `json:"subtype" url:"subtype"`
	Metadata         *ListMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedTimestamp float64       `json:"createdTimestamp" url:"createdTimestamp"`
	Size             *float64      `json:"size,omitempty" url:"size,omitempty"`
	Version          *float64      `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListHeader) GetListId() string {
	if l == nil {
		return ""
	}
	return l.ListId
}

func (l *ListHeader) GetListType() ListType {
	if l == nil {
		return ""
	}
	return l.ListType
}

func (l *ListHeader) GetSubtype() ListSubtype {
	if l == nil {
		return ""
	}
	return l.Subtype
}

func (l *ListHeader) GetMetadata() *ListMetadata {
	if l == nil {
		return nil
	}
	return l.Metadata
}

func (l *ListHeader) GetCreatedTimestamp() float64 {
	if l == nil {
		return 0
	}
	return l.CreatedTimestamp
}

func (l *ListHeader) GetSize() *float64 {
	if l == nil {
		return nil
	}
	return l.Size
}

func (l *ListHeader) GetVersion() *float64 {
	if l == nil {
		return nil
	}
	return l.Version
}

func (l *ListHeader) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler ListHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListHeader(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListHeader) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListItem struct {
	Key      string           `json:"key" url:"key"`
	Metadata *ListKeyMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	Ttl      *float64         `json:"ttl,omitempty" url:"ttl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListItem) GetKey() string {
	if l == nil {
		return ""
	}
	return l.Key
}

func (l *ListItem) GetMetadata() *ListKeyMetadata {
	if l == nil {
		return nil
	}
	return l.Metadata
}

func (l *ListItem) GetTtl() *float64 {
	if l == nil {
		return nil
	}
	return l.Ttl
}

func (l *ListItem) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ListItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListItem) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListKeyMetadata = map[string]interface{}

type ListMetadata struct {
	// List name
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// List description
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Status      *bool            `json:"status,omitempty" url:"status,omitempty"`
	Checksum    *string          `json:"checksum,omitempty" url:"checksum,omitempty"`
	Columns     []*CustomColumn  `json:"columns,omitempty" url:"columns,omitempty"`
	Ttl         *ListMetadataTtl `json:"ttl,omitempty" url:"ttl,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *ListMetadata) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *ListMetadata) GetDescription() *string {
	if l == nil {
		return nil
	}
	return l.Description
}

func (l *ListMetadata) GetStatus() *bool {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *ListMetadata) GetChecksum() *string {
	if l == nil {
		return nil
	}
	return l.Checksum
}

func (l *ListMetadata) GetColumns() []*CustomColumn {
	if l == nil {
		return nil
	}
	return l.Columns
}

func (l *ListMetadata) GetTtl() *ListMetadataTtl {
	if l == nil {
		return nil
	}
	return l.Ttl
}

func (l *ListMetadata) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *ListMetadata) UnmarshalJSON(data []byte) error {
	type embed ListMetadata
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = ListMetadata(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMetadata) MarshalJSON() ([]byte, error) {
	type embed ListMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *ListMetadata) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListMetadataTtl struct {
	Unit  ListMetadataTtlUnit `json:"unit" url:"unit"`
	Value float64             `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListMetadataTtl) GetUnit() ListMetadataTtlUnit {
	if l == nil {
		return ""
	}
	return l.Unit
}

func (l *ListMetadataTtl) GetValue() float64 {
	if l == nil {
		return 0
	}
	return l.Value
}

func (l *ListMetadataTtl) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMetadataTtl) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMetadataTtl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMetadataTtl(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMetadataTtl) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListMetadataTtlUnit string

const (
	ListMetadataTtlUnitHour ListMetadataTtlUnit = "HOUR"
	ListMetadataTtlUnitDay  ListMetadataTtlUnit = "DAY"
)

func NewListMetadataTtlUnitFromString(s string) (ListMetadataTtlUnit, error) {
	switch s {
	case "HOUR":
		return ListMetadataTtlUnitHour, nil
	case "DAY":
		return ListMetadataTtlUnitDay, nil
	}
	var t ListMetadataTtlUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListMetadataTtlUnit) Ptr() *ListMetadataTtlUnit {
	return &l
}

type ListSubtype string

const (
	ListSubtypeUserId                ListSubtype = "USER_ID"
	ListSubtypeCardFingerprintNumber ListSubtype = "CARD_FINGERPRINT_NUMBER"
	ListSubtypeIbanNumber            ListSubtype = "IBAN_NUMBER"
	ListSubtypeBankAccountNumber     ListSubtype = "BANK_ACCOUNT_NUMBER"
	ListSubtypeAchAccountNumber      ListSubtype = "ACH_ACCOUNT_NUMBER"
	ListSubtypeSwiftAccountNumber    ListSubtype = "SWIFT_ACCOUNT_NUMBER"
	ListSubtypeBic                   ListSubtype = "BIC"
	ListSubtypeBankSwiftCode         ListSubtype = "BANK_SWIFT_CODE"
	ListSubtypeUpiIdentifyingNumber  ListSubtype = "UPI_IDENTIFYING_NUMBER"
	ListSubtypeIpAddress             ListSubtype = "IP_ADDRESS"
	ListSubtypeDeviceIdentifier      ListSubtype = "DEVICE_IDENTIFIER"
	ListSubtypeString                ListSubtype = "STRING"
	ListSubtypeCountry               ListSubtype = "COUNTRY"
	ListSubtypeCustom                ListSubtype = "CUSTOM"
)

func NewListSubtypeFromString(s string) (ListSubtype, error) {
	switch s {
	case "USER_ID":
		return ListSubtypeUserId, nil
	case "CARD_FINGERPRINT_NUMBER":
		return ListSubtypeCardFingerprintNumber, nil
	case "IBAN_NUMBER":
		return ListSubtypeIbanNumber, nil
	case "BANK_ACCOUNT_NUMBER":
		return ListSubtypeBankAccountNumber, nil
	case "ACH_ACCOUNT_NUMBER":
		return ListSubtypeAchAccountNumber, nil
	case "SWIFT_ACCOUNT_NUMBER":
		return ListSubtypeSwiftAccountNumber, nil
	case "BIC":
		return ListSubtypeBic, nil
	case "BANK_SWIFT_CODE":
		return ListSubtypeBankSwiftCode, nil
	case "UPI_IDENTIFYING_NUMBER":
		return ListSubtypeUpiIdentifyingNumber, nil
	case "IP_ADDRESS":
		return ListSubtypeIpAddress, nil
	case "DEVICE_IDENTIFIER":
		return ListSubtypeDeviceIdentifier, nil
	case "STRING":
		return ListSubtypeString, nil
	case "COUNTRY":
		return ListSubtypeCountry, nil
	case "CUSTOM":
		return ListSubtypeCustom, nil
	}
	var t ListSubtype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListSubtype) Ptr() *ListSubtype {
	return &l
}

type ListType string

const (
	ListTypeWhitelist        ListType = "WHITELIST"
	ListTypeBlacklist        ListType = "BLACKLIST"
	ListTypeFlagrightLibrary ListType = "FLAGRIGHT_LIBRARY"
)

func NewListTypeFromString(s string) (ListType, error) {
	switch s {
	case "WHITELIST":
		return ListTypeWhitelist, nil
	case "BLACKLIST":
		return ListTypeBlacklist, nil
	case "FLAGRIGHT_LIBRARY":
		return ListTypeFlagrightLibrary, nil
	}
	var t ListType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListType) Ptr() *ListType {
	return &l
}

type ListUpdatedDetails struct {
	ListId string                   `json:"listId" url:"listId"`
	Action ListUpdatedDetailsAction `json:"action" url:"action"`
	Items  []*ListItem              `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListUpdatedDetails) GetListId() string {
	if l == nil {
		return ""
	}
	return l.ListId
}

func (l *ListUpdatedDetails) GetAction() ListUpdatedDetailsAction {
	if l == nil {
		return ""
	}
	return l.Action
}

func (l *ListUpdatedDetails) GetItems() []*ListItem {
	if l == nil {
		return nil
	}
	return l.Items
}

func (l *ListUpdatedDetails) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListUpdatedDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ListUpdatedDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListUpdatedDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListUpdatedDetails) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListUpdatedDetailsAction string

const (
	ListUpdatedDetailsActionSet   ListUpdatedDetailsAction = "SET"
	ListUpdatedDetailsActionUnset ListUpdatedDetailsAction = "UNSET"
	ListUpdatedDetailsActionClear ListUpdatedDetailsAction = "CLEAR"
)

func NewListUpdatedDetailsActionFromString(s string) (ListUpdatedDetailsAction, error) {
	switch s {
	case "SET":
		return ListUpdatedDetailsActionSet, nil
	case "UNSET":
		return ListUpdatedDetailsActionUnset, nil
	case "CLEAR":
		return ListUpdatedDetailsActionClear, nil
	}
	var t ListUpdatedDetailsAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListUpdatedDetailsAction) Ptr() *ListUpdatedDetailsAction {
	return &l
}

type MccDetails struct {
	// Merchant code
	Code float64 `json:"code" url:"code"`
	// Merchant Description
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MccDetails) GetCode() float64 {
	if m == nil {
		return 0
	}
	return m.Code
}

func (m *MccDetails) GetDescription() *string {
	if m == nil {
		return nil
	}
	return m.Description
}

func (m *MccDetails) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MccDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler MccDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MccDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MccDetails) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Marital status of the individual
type MaritalStatus string

const (
	MaritalStatusDivorced MaritalStatus = "DIVORCED"
	MaritalStatusMarried  MaritalStatus = "MARRIED"
	MaritalStatusSingle   MaritalStatus = "SINGLE"
	MaritalStatusWidowed  MaritalStatus = "WIDOWED"
	MaritalStatusNa       MaritalStatus = "NA"
)

func NewMaritalStatusFromString(s string) (MaritalStatus, error) {
	switch s {
	case "DIVORCED":
		return MaritalStatusDivorced, nil
	case "MARRIED":
		return MaritalStatusMarried, nil
	case "SINGLE":
		return MaritalStatusSingle, nil
	case "WIDOWED":
		return MaritalStatusWidowed, nil
	case "NA":
		return MaritalStatusNa, nil
	}
	var t MaritalStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MaritalStatus) Ptr() *MaritalStatus {
	return &m
}

// Model for Mpesa payment method
type MpesaDetails struct {
	// Business code
	BusinessShortCode string               `json:"businessShortCode" url:"businessShortCode"`
	TransactionType   MpesaTransactionType `json:"transactionType" url:"transactionType"`
	// Contact Number of the account holder
	PhoneNumber string   `json:"phoneNumber" url:"phoneNumber"`
	EmailId     *EmailId `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MpesaDetails) GetBusinessShortCode() string {
	if m == nil {
		return ""
	}
	return m.BusinessShortCode
}

func (m *MpesaDetails) GetTransactionType() MpesaTransactionType {
	if m == nil {
		return ""
	}
	return m.TransactionType
}

func (m *MpesaDetails) GetPhoneNumber() string {
	if m == nil {
		return ""
	}
	return m.PhoneNumber
}

func (m *MpesaDetails) GetEmailId() *EmailId {
	if m == nil {
		return nil
	}
	return m.EmailId
}

func (m *MpesaDetails) GetTags() []*Tag {
	if m == nil {
		return nil
	}
	return m.Tags
}

func (m *MpesaDetails) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MpesaDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler MpesaDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MpesaDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MpesaDetails) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Classify the method of payment as "Mpesa" for MpesaDetails
type MpesaPaymentMethod = string

// Type of transaction
type MpesaTransactionType string

const (
	MpesaTransactionTypeCustomerPayBillOnline  MpesaTransactionType = "CustomerPayBillOnline"
	MpesaTransactionTypeCustomerBuyGoodsOnline MpesaTransactionType = "CustomerBuyGoodsOnline"
	MpesaTransactionTypeSalaryPayment          MpesaTransactionType = "SalaryPayment"
	MpesaTransactionTypeBusinessPayment        MpesaTransactionType = "BusinessPayment"
	MpesaTransactionTypePromotionPayment       MpesaTransactionType = "PromotionPayment"
)

func NewMpesaTransactionTypeFromString(s string) (MpesaTransactionType, error) {
	switch s {
	case "CustomerPayBillOnline":
		return MpesaTransactionTypeCustomerPayBillOnline, nil
	case "CustomerBuyGoodsOnline":
		return MpesaTransactionTypeCustomerBuyGoodsOnline, nil
	case "SalaryPayment":
		return MpesaTransactionTypeSalaryPayment, nil
	case "BusinessPayment":
		return MpesaTransactionTypeBusinessPayment, nil
	case "PromotionPayment":
		return MpesaTransactionTypePromotionPayment, nil
	}
	var t MpesaTransactionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MpesaTransactionType) Ptr() *MpesaTransactionType {
	return &m
}

// New Payment Platform Details for Australia
type NppDetails struct {
	// Account number
	AccountNumber *string       `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	Name          *ConsumerName `json:"name,omitempty" url:"name,omitempty"`
	EmailId       *EmailId      `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Contact number
	ContactNumber *string `json:"contactNumber,omitempty" url:"contactNumber,omitempty"`
	// BSB number
	Bsb *string `json:"bsb,omitempty" url:"bsb,omitempty"`
	// PayID
	PayId string `json:"payId" url:"payId"`
	// End to End ID
	EndToEndId string `json:"endToEndId" url:"endToEndId"`
	// OSKO reference
	OskoReference *string `json:"oskoReference,omitempty" url:"oskoReference,omitempty"`
	// PayID reference
	PayIdReference *string `json:"payIdReference,omitempty" url:"payIdReference,omitempty"`
	// Whether the payment is instant
	IsInstant *bool `json:"isInstant,omitempty" url:"isInstant,omitempty"`
	// Remittance information
	RemittanceInformation *string `json:"remittanceInformation,omitempty" url:"remittanceInformation,omitempty"`
	// Remittance advice
	RemittanceAdvice *string `json:"remittanceAdvice,omitempty" url:"remittanceAdvice,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`
	// Timestamp of the event
	ProcessingDate *float64 `json:"processingDate,omitempty" url:"processingDate,omitempty"`
	// Timestamp of the event
	SettlementDate *float64 `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Unique reference number for transaction reconciliation
	ReferenceNumber *string `json:"referenceNumber,omitempty" url:"referenceNumber,omitempty"`
	// Trace number for tracking the payment through the NPP system
	TraceNumber *string `json:"traceNumber,omitempty" url:"traceNumber,omitempty"`
	// Format of the NPP message (e.g., JSON, XML)
	MessageFormat *string `json:"messageFormat,omitempty" url:"messageFormat,omitempty"`
	// Name of the bank associated with the account
	BankName *string  `json:"bankName,omitempty" url:"bankName,omitempty"`
	Address  *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NppDetails) GetAccountNumber() *string {
	if n == nil {
		return nil
	}
	return n.AccountNumber
}

func (n *NppDetails) GetName() *ConsumerName {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NppDetails) GetEmailId() *EmailId {
	if n == nil {
		return nil
	}
	return n.EmailId
}

func (n *NppDetails) GetContactNumber() *string {
	if n == nil {
		return nil
	}
	return n.ContactNumber
}

func (n *NppDetails) GetBsb() *string {
	if n == nil {
		return nil
	}
	return n.Bsb
}

func (n *NppDetails) GetPayId() string {
	if n == nil {
		return ""
	}
	return n.PayId
}

func (n *NppDetails) GetEndToEndId() string {
	if n == nil {
		return ""
	}
	return n.EndToEndId
}

func (n *NppDetails) GetOskoReference() *string {
	if n == nil {
		return nil
	}
	return n.OskoReference
}

func (n *NppDetails) GetPayIdReference() *string {
	if n == nil {
		return nil
	}
	return n.PayIdReference
}

func (n *NppDetails) GetIsInstant() *bool {
	if n == nil {
		return nil
	}
	return n.IsInstant
}

func (n *NppDetails) GetRemittanceInformation() *string {
	if n == nil {
		return nil
	}
	return n.RemittanceInformation
}

func (n *NppDetails) GetRemittanceAdvice() *string {
	if n == nil {
		return nil
	}
	return n.RemittanceAdvice
}

func (n *NppDetails) GetTags() []*Tag {
	if n == nil {
		return nil
	}
	return n.Tags
}

func (n *NppDetails) GetProcessingDate() *float64 {
	if n == nil {
		return nil
	}
	return n.ProcessingDate
}

func (n *NppDetails) GetSettlementDate() *float64 {
	if n == nil {
		return nil
	}
	return n.SettlementDate
}

func (n *NppDetails) GetReferenceNumber() *string {
	if n == nil {
		return nil
	}
	return n.ReferenceNumber
}

func (n *NppDetails) GetTraceNumber() *string {
	if n == nil {
		return nil
	}
	return n.TraceNumber
}

func (n *NppDetails) GetMessageFormat() *string {
	if n == nil {
		return nil
	}
	return n.MessageFormat
}

func (n *NppDetails) GetBankName() *string {
	if n == nil {
		return nil
	}
	return n.BankName
}

func (n *NppDetails) GetAddress() *Address {
	if n == nil {
		return nil
	}
	return n.Address
}

func (n *NppDetails) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NppDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler NppDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NppDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NppDetails) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Classify the method of payment as "NPP" for NPPDetails (New Payment Platform Details for Australia)
type NppPaymentMethod = string

// Model for origin funds information
type OriginFundsInfo struct {
	// Source of funds for the transaction
	SourceOfFunds *string `json:"sourceOfFunds,omitempty" url:"sourceOfFunds,omitempty"`
	// Source of wealth
	SourceOfWealth *string `json:"sourceOfWealth,omitempty" url:"sourceOfWealth,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OriginFundsInfo) GetSourceOfFunds() *string {
	if o == nil {
		return nil
	}
	return o.SourceOfFunds
}

func (o *OriginFundsInfo) GetSourceOfWealth() *string {
	if o == nil {
		return nil
	}
	return o.SourceOfWealth
}

func (o *OriginFundsInfo) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OriginFundsInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler OriginFundsInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OriginFundsInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OriginFundsInfo) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PepStatus struct {
	IsPepHit   bool         `json:"isPepHit" url:"isPepHit"`
	PepCountry *CountryCode `json:"pepCountry,omitempty" url:"pepCountry,omitempty"`
	PepRank    *PepRank     `json:"pepRank,omitempty" url:"pepRank,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PepStatus) GetIsPepHit() bool {
	if p == nil {
		return false
	}
	return p.IsPepHit
}

func (p *PepStatus) GetPepCountry() *CountryCode {
	if p == nil {
		return nil
	}
	return p.PepCountry
}

func (p *PepStatus) GetPepRank() *PepRank {
	if p == nil {
		return nil
	}
	return p.PepRank
}

func (p *PepStatus) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PepStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler PepStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PepStatus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PepStatus) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PosDetails struct {
	EntryMode *PosEntryMode `json:"entryMode,omitempty" url:"entryMode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PosDetails) GetEntryMode() *PosEntryMode {
	if p == nil {
		return nil
	}
	return p.EntryMode
}

func (p *PosDetails) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PosDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PosDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PosDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PosDetails) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PosEntryMode string

const (
	PosEntryModeZero        PosEntryMode = "0"
	PosEntryModeOne         PosEntryMode = "1"
	PosEntryModeTwo         PosEntryMode = "2"
	PosEntryModeThree       PosEntryMode = "3"
	PosEntryModeFour        PosEntryMode = "4"
	PosEntryModeFive        PosEntryMode = "5"
	PosEntryModeSix         PosEntryMode = "6"
	PosEntryModeSeven       PosEntryMode = "7"
	PosEntryModeEight       PosEntryMode = "8"
	PosEntryModeNine        PosEntryMode = "9"
	PosEntryModeTen         PosEntryMode = "10"
	PosEntryModeSeventyNine PosEntryMode = "79"
	PosEntryModeEighty      PosEntryMode = "80"
	PosEntryModeEightyOne   PosEntryMode = "81"
	PosEntryModeEightyTwo   PosEntryMode = "82"
	PosEntryModeEightyFive  PosEntryMode = "85"
	PosEntryModeNinety      PosEntryMode = "90"
	PosEntryModeNinetyOne   PosEntryMode = "91"
	PosEntryModeNinetyFive  PosEntryMode = "95"
	PosEntryModeNinetySeven PosEntryMode = "97"
)

func NewPosEntryModeFromString(s string) (PosEntryMode, error) {
	switch s {
	case "0":
		return PosEntryModeZero, nil
	case "1":
		return PosEntryModeOne, nil
	case "2":
		return PosEntryModeTwo, nil
	case "3":
		return PosEntryModeThree, nil
	case "4":
		return PosEntryModeFour, nil
	case "5":
		return PosEntryModeFive, nil
	case "6":
		return PosEntryModeSix, nil
	case "7":
		return PosEntryModeSeven, nil
	case "8":
		return PosEntryModeEight, nil
	case "9":
		return PosEntryModeNine, nil
	case "10":
		return PosEntryModeTen, nil
	case "79":
		return PosEntryModeSeventyNine, nil
	case "80":
		return PosEntryModeEighty, nil
	case "81":
		return PosEntryModeEightyOne, nil
	case "82":
		return PosEntryModeEightyTwo, nil
	case "85":
		return PosEntryModeEightyFive, nil
	case "90":
		return PosEntryModeNinety, nil
	case "91":
		return PosEntryModeNinetyOne, nil
	case "95":
		return PosEntryModeNinetyFive, nil
	case "97":
		return PosEntryModeNinetySeven, nil
	}
	var t PosEntryMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PosEntryMode) Ptr() *PosEntryMode {
	return &p
}

type PaymentMethod string

const (
	PaymentMethodAch                PaymentMethod = "ACH"
	PaymentMethodCard               PaymentMethod = "CARD"
	PaymentMethodIban               PaymentMethod = "IBAN"
	PaymentMethodUpi                PaymentMethod = "UPI"
	PaymentMethodGenericBankAccount PaymentMethod = "GENERIC_BANK_ACCOUNT"
	PaymentMethodMpesa              PaymentMethod = "MPESA"
	PaymentMethodSwift              PaymentMethod = "SWIFT"
	PaymentMethodWallet             PaymentMethod = "WALLET"
	PaymentMethodCheck              PaymentMethod = "CHECK"
	PaymentMethodCash               PaymentMethod = "CASH"
	PaymentMethodNpp                PaymentMethod = "NPP"
)

func NewPaymentMethodFromString(s string) (PaymentMethod, error) {
	switch s {
	case "ACH":
		return PaymentMethodAch, nil
	case "CARD":
		return PaymentMethodCard, nil
	case "IBAN":
		return PaymentMethodIban, nil
	case "UPI":
		return PaymentMethodUpi, nil
	case "GENERIC_BANK_ACCOUNT":
		return PaymentMethodGenericBankAccount, nil
	case "MPESA":
		return PaymentMethodMpesa, nil
	case "SWIFT":
		return PaymentMethodSwift, nil
	case "WALLET":
		return PaymentMethodWallet, nil
	case "CHECK":
		return PaymentMethodCheck, nil
	case "CASH":
		return PaymentMethodCash, nil
	case "NPP":
		return PaymentMethodNpp, nil
	}
	var t PaymentMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentMethod) Ptr() *PaymentMethod {
	return &p
}

// PEP rank
type PepRank string

const (
	PepRankLevel1 PepRank = "LEVEL_1"
	PepRankLevel2 PepRank = "LEVEL_2"
	PepRankLevel3 PepRank = "LEVEL_3"
)

func NewPepRankFromString(s string) (PepRank, error) {
	switch s {
	case "LEVEL_1":
		return PepRankLevel1, nil
	case "LEVEL_2":
		return PepRankLevel2, nil
	case "LEVEL_3":
		return PepRankLevel3, nil
	}
	var t PepRank
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PepRank) Ptr() *PepRank {
	return &p
}

// Model for a generic individual - different from User model by not having userId field
type Person struct {
	// Unique user ID for the person
	UserId         *string      `json:"userId,omitempty" url:"userId,omitempty"`
	GeneralDetails *UserDetails `json:"generalDetails,omitempty" url:"generalDetails,omitempty"`
	// User's legal identity documents - See Document Model for details
	LegalDocuments []*LegalDocument `json:"legalDocuments,omitempty" url:"legalDocuments,omitempty"`
	ContactDetails *ContactDetails  `json:"contactDetails,omitempty" url:"contactDetails,omitempty"`
	PepStatus      []*PepStatus     `json:"pepStatus,omitempty" url:"pepStatus,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`
	// User's attachments uploaded by business user
	Attachments []*PersonAttachment `json:"attachments,omitempty" url:"attachments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Person) GetUserId() *string {
	if p == nil {
		return nil
	}
	return p.UserId
}

func (p *Person) GetGeneralDetails() *UserDetails {
	if p == nil {
		return nil
	}
	return p.GeneralDetails
}

func (p *Person) GetLegalDocuments() []*LegalDocument {
	if p == nil {
		return nil
	}
	return p.LegalDocuments
}

func (p *Person) GetContactDetails() *ContactDetails {
	if p == nil {
		return nil
	}
	return p.ContactDetails
}

func (p *Person) GetPepStatus() []*PepStatus {
	if p == nil {
		return nil
	}
	return p.PepStatus
}

func (p *Person) GetTags() []*Tag {
	if p == nil {
		return nil
	}
	return p.Tags
}

func (p *Person) GetAttachments() []*PersonAttachment {
	if p == nil {
		return nil
	}
	return p.Attachments
}

func (p *Person) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Person) UnmarshalJSON(data []byte) error {
	type unmarshaler Person
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Person(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Person) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// PersonAttachment model generalizes User's uploaded attachments
type PersonAttachment struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// User's comment on the attached file.
	Comment   *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Files     []*FileInfo `json:"files,omitempty" url:"files,omitempty"`
	UserId    string      `json:"userId" url:"userId"`
	CreatedAt *float64    `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	DeletedAt *float64    `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PersonAttachment) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PersonAttachment) GetComment() *string {
	if p == nil {
		return nil
	}
	return p.Comment
}

func (p *PersonAttachment) GetFiles() []*FileInfo {
	if p == nil {
		return nil
	}
	return p.Files
}

func (p *PersonAttachment) GetUserId() string {
	if p == nil {
		return ""
	}
	return p.UserId
}

func (p *PersonAttachment) GetCreatedAt() *float64 {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PersonAttachment) GetDeletedAt() *float64 {
	if p == nil {
		return nil
	}
	return p.DeletedAt
}

func (p *PersonAttachment) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PersonAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler PersonAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PersonAttachment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PersonAttachment) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Place of birth of the individual
type PlaceOfBirth struct {
	City    *string     `json:"city,omitempty" url:"city,omitempty"`
	State   *string     `json:"state,omitempty" url:"state,omitempty"`
	Country CountryCode `json:"country" url:"country"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlaceOfBirth) GetCity() *string {
	if p == nil {
		return nil
	}
	return p.City
}

func (p *PlaceOfBirth) GetState() *string {
	if p == nil {
		return nil
	}
	return p.State
}

func (p *PlaceOfBirth) GetCountry() CountryCode {
	if p == nil {
		return ""
	}
	return p.Country
}

func (p *PlaceOfBirth) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlaceOfBirth) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaceOfBirth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaceOfBirth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaceOfBirth) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RiskLevel string

const (
	RiskLevelVeryHigh RiskLevel = "VERY_HIGH"
	RiskLevelHigh     RiskLevel = "HIGH"
	RiskLevelMedium   RiskLevel = "MEDIUM"
	RiskLevelLow      RiskLevel = "LOW"
	RiskLevelVeryLow  RiskLevel = "VERY_LOW"
)

func NewRiskLevelFromString(s string) (RiskLevel, error) {
	switch s {
	case "VERY_HIGH":
		return RiskLevelVeryHigh, nil
	case "HIGH":
		return RiskLevelHigh, nil
	case "MEDIUM":
		return RiskLevelMedium, nil
	case "LOW":
		return RiskLevelLow, nil
	case "VERY_LOW":
		return RiskLevelVeryLow, nil
	}
	var t RiskLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RiskLevel) Ptr() *RiskLevel {
	return &r
}

// Model for rule action if a rule is hit. This is returned in the API response and can be configured on Console by operational accounts like a Compliance Analyst
type RuleAction string

const (
	RuleActionAllow   RuleAction = "ALLOW"
	RuleActionFlag    RuleAction = "FLAG"
	RuleActionBlock   RuleAction = "BLOCK"
	RuleActionSuspend RuleAction = "SUSPEND"
)

func NewRuleActionFromString(s string) (RuleAction, error) {
	switch s {
	case "ALLOW":
		return RuleActionAllow, nil
	case "FLAG":
		return RuleActionFlag, nil
	case "BLOCK":
		return RuleActionBlock, nil
	case "SUSPEND":
		return RuleActionSuspend, nil
	}
	var t RuleAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleAction) Ptr() *RuleAction {
	return &r
}

type RuleFailureException struct {
	// Unique rule identifier
	ExceptionName string `json:"exceptionName" url:"exceptionName"`
	// Name of the rule
	ExceptionDescription string `json:"exceptionDescription" url:"exceptionDescription"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleFailureException) GetExceptionName() string {
	if r == nil {
		return ""
	}
	return r.ExceptionName
}

func (r *RuleFailureException) GetExceptionDescription() string {
	if r == nil {
		return ""
	}
	return r.ExceptionDescription
}

func (r *RuleFailureException) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleFailureException) UnmarshalJSON(data []byte) error {
	type unmarshaler RuleFailureException
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RuleFailureException(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleFailureException) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RuleHitDirection string

const (
	RuleHitDirectionOrigin      RuleHitDirection = "ORIGIN"
	RuleHitDirectionDestination RuleHitDirection = "DESTINATION"
)

func NewRuleHitDirectionFromString(s string) (RuleHitDirection, error) {
	switch s {
	case "ORIGIN":
		return RuleHitDirectionOrigin, nil
	case "DESTINATION":
		return RuleHitDirectionDestination, nil
	}
	var t RuleHitDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleHitDirection) Ptr() *RuleHitDirection {
	return &r
}

// Details of rule execution, for internal purposes only
type RuleHitMeta struct {
	HitDirections         []RuleHitDirection    `json:"hitDirections,omitempty" url:"hitDirections,omitempty"`
	FalsePositiveDetails  *FalsePositiveDetails `json:"falsePositiveDetails,omitempty" url:"falsePositiveDetails,omitempty"`
	SanctionsDetails      []*SanctionsDetails   `json:"sanctionsDetails,omitempty" url:"sanctionsDetails,omitempty"`
	IsOngoingScreeningHit *bool                 `json:"isOngoingScreeningHit,omitempty" url:"isOngoingScreeningHit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleHitMeta) GetHitDirections() []RuleHitDirection {
	if r == nil {
		return nil
	}
	return r.HitDirections
}

func (r *RuleHitMeta) GetFalsePositiveDetails() *FalsePositiveDetails {
	if r == nil {
		return nil
	}
	return r.FalsePositiveDetails
}

func (r *RuleHitMeta) GetSanctionsDetails() []*SanctionsDetails {
	if r == nil {
		return nil
	}
	return r.SanctionsDetails
}

func (r *RuleHitMeta) GetIsOngoingScreeningHit() *bool {
	if r == nil {
		return nil
	}
	return r.IsOngoingScreeningHit
}

func (r *RuleHitMeta) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleHitMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler RuleHitMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RuleHitMeta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleHitMeta) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RuleLabels string

const (
	RuleLabelsUnexpectedBehavior       RuleLabels = "UNEXPECTED_BEHAVIOR"
	RuleLabelsIllicitGainsCheck        RuleLabels = "ILLICIT_GAINS_CHECK"
	RuleLabelsRfiTrigger               RuleLabels = "RFI_TRIGGER"
	RuleLabelsEddTrigger               RuleLabels = "EDD_TRIGGER"
	RuleLabelsKycTrigger               RuleLabels = "KYC_TRIGGER"
	RuleLabelsScam                     RuleLabels = "SCAM"
	RuleLabelsAbuse                    RuleLabels = "ABUSE"
	RuleLabelsAccountTakeover          RuleLabels = "ACCOUNT_TAKEOVER"
	RuleLabelsDispute                  RuleLabels = "DISPUTE"
	RuleLabelsSanctions                RuleLabels = "SANCTIONS"
	RuleLabelsSanctionsPep             RuleLabels = "SANCTIONS_PEP"
	RuleLabelsSanctionsPepAdverseMedia RuleLabels = "SANCTIONS_PEP_ADVERSE_MEDIA"
	RuleLabelsSanctionsManualReview    RuleLabels = "SANCTIONS_MANUAL_REVIEW"
)

func NewRuleLabelsFromString(s string) (RuleLabels, error) {
	switch s {
	case "UNEXPECTED_BEHAVIOR":
		return RuleLabelsUnexpectedBehavior, nil
	case "ILLICIT_GAINS_CHECK":
		return RuleLabelsIllicitGainsCheck, nil
	case "RFI_TRIGGER":
		return RuleLabelsRfiTrigger, nil
	case "EDD_TRIGGER":
		return RuleLabelsEddTrigger, nil
	case "KYC_TRIGGER":
		return RuleLabelsKycTrigger, nil
	case "SCAM":
		return RuleLabelsScam, nil
	case "ABUSE":
		return RuleLabelsAbuse, nil
	case "ACCOUNT_TAKEOVER":
		return RuleLabelsAccountTakeover, nil
	case "DISPUTE":
		return RuleLabelsDispute, nil
	case "SANCTIONS":
		return RuleLabelsSanctions, nil
	case "SANCTIONS_PEP":
		return RuleLabelsSanctionsPep, nil
	case "SANCTIONS_PEP_ADVERSE_MEDIA":
		return RuleLabelsSanctionsPepAdverseMedia, nil
	case "SANCTIONS_MANUAL_REVIEW":
		return RuleLabelsSanctionsManualReview, nil
	}
	var t RuleLabels
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleLabels) Ptr() *RuleLabels {
	return &r
}

type RuleNature string

const (
	RuleNatureAml       RuleNature = "AML"
	RuleNatureFraud     RuleNature = "FRAUD"
	RuleNatureCtf       RuleNature = "CTF"
	RuleNatureScreening RuleNature = "SCREENING"
)

func NewRuleNatureFromString(s string) (RuleNature, error) {
	switch s {
	case "AML":
		return RuleNatureAml, nil
	case "FRAUD":
		return RuleNatureFraud, nil
	case "CTF":
		return RuleNatureCtf, nil
	case "SCREENING":
		return RuleNatureScreening, nil
	}
	var t RuleNature
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleNature) Ptr() *RuleNature {
	return &r
}

type RulesResults struct {
	// Unique transaction identifier
	ExecutedRules []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	// Unique transaction identifier
	HitRules []*HitRulesDetails `json:"hitRules,omitempty" url:"hitRules,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RulesResults) GetExecutedRules() []*ExecutedRulesResult {
	if r == nil {
		return nil
	}
	return r.ExecutedRules
}

func (r *RulesResults) GetHitRules() []*HitRulesDetails {
	if r == nil {
		return nil
	}
	return r.HitRules
}

func (r *RulesResults) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RulesResults) UnmarshalJSON(data []byte) error {
	type unmarshaler RulesResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RulesResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RulesResults) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Model for SWIFT payment method
type SwiftDetails struct {
	// SWIFT code of the financial institution
	SwiftCode *string `json:"swiftCode,omitempty" url:"swiftCode,omitempty"`
	// Account number
	AccountNumber  *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	AccountBalance *Amount `json:"accountBalance,omitempty" url:"accountBalance,omitempty"`
	// Account type. E.g. Checking, Savings etc.
	AccountType *string `json:"accountType,omitempty" url:"accountType,omitempty"`
	// Name of the bank
	BankName *string `json:"bankName,omitempty" url:"bankName,omitempty"`
	// Name of the account holder
	Name        *string  `json:"name,omitempty" url:"name,omitempty"`
	BankAddress *Address `json:"bankAddress,omitempty" url:"bankAddress,omitempty"`
	EmailId     *EmailId `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Special instructions if any
	SpecialInstructions *string `json:"specialInstructions,omitempty" url:"specialInstructions,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SwiftDetails) GetSwiftCode() *string {
	if s == nil {
		return nil
	}
	return s.SwiftCode
}

func (s *SwiftDetails) GetAccountNumber() *string {
	if s == nil {
		return nil
	}
	return s.AccountNumber
}

func (s *SwiftDetails) GetAccountBalance() *Amount {
	if s == nil {
		return nil
	}
	return s.AccountBalance
}

func (s *SwiftDetails) GetAccountType() *string {
	if s == nil {
		return nil
	}
	return s.AccountType
}

func (s *SwiftDetails) GetBankName() *string {
	if s == nil {
		return nil
	}
	return s.BankName
}

func (s *SwiftDetails) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SwiftDetails) GetBankAddress() *Address {
	if s == nil {
		return nil
	}
	return s.BankAddress
}

func (s *SwiftDetails) GetEmailId() *EmailId {
	if s == nil {
		return nil
	}
	return s.EmailId
}

func (s *SwiftDetails) GetSpecialInstructions() *string {
	if s == nil {
		return nil
	}
	return s.SpecialInstructions
}

func (s *SwiftDetails) GetTags() []*Tag {
	if s == nil {
		return nil
	}
	return s.Tags
}

func (s *SwiftDetails) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SwiftDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler SwiftDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SwiftDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SwiftDetails) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Classify the method of payment as "SWIFT" for SWIFTDetails
type SwiftPaymentMethod = string

type SanctionsDetails struct {
	Name           string                      `json:"name" url:"name"`
	SearchId       string                      `json:"searchId" url:"searchId"`
	Iban           *string                     `json:"iban,omitempty" url:"iban,omitempty"`
	EntityType     *SanctionsDetailsEntityType `json:"entityType,omitempty" url:"entityType,omitempty"`
	SanctionHitIds []string                    `json:"sanctionHitIds,omitempty" url:"sanctionHitIds,omitempty"`
	HitContext     *SanctionsHitContext        `json:"hitContext,omitempty" url:"hitContext,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SanctionsDetails) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SanctionsDetails) GetSearchId() string {
	if s == nil {
		return ""
	}
	return s.SearchId
}

func (s *SanctionsDetails) GetIban() *string {
	if s == nil {
		return nil
	}
	return s.Iban
}

func (s *SanctionsDetails) GetEntityType() *SanctionsDetailsEntityType {
	if s == nil {
		return nil
	}
	return s.EntityType
}

func (s *SanctionsDetails) GetSanctionHitIds() []string {
	if s == nil {
		return nil
	}
	return s.SanctionHitIds
}

func (s *SanctionsDetails) GetHitContext() *SanctionsHitContext {
	if s == nil {
		return nil
	}
	return s.HitContext
}

func (s *SanctionsDetails) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SanctionsDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler SanctionsDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SanctionsDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SanctionsDetails) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SanctionsDetailsEntityType string

const (
	SanctionsDetailsEntityTypeConsumerName           SanctionsDetailsEntityType = "CONSUMER_NAME"
	SanctionsDetailsEntityTypeLegalName              SanctionsDetailsEntityType = "LEGAL_NAME"
	SanctionsDetailsEntityTypeShareholder            SanctionsDetailsEntityType = "SHAREHOLDER"
	SanctionsDetailsEntityTypeDirector               SanctionsDetailsEntityType = "DIRECTOR"
	SanctionsDetailsEntityTypeNameOnCard             SanctionsDetailsEntityType = "NAME_ON_CARD"
	SanctionsDetailsEntityTypePaymentName            SanctionsDetailsEntityType = "PAYMENT_NAME"
	SanctionsDetailsEntityTypePaymentBeneficiaryName SanctionsDetailsEntityType = "PAYMENT_BENEFICIARY_NAME"
	SanctionsDetailsEntityTypeBankName               SanctionsDetailsEntityType = "BANK_NAME"
	SanctionsDetailsEntityTypeBankAccountHolderName  SanctionsDetailsEntityType = "BANK_ACCOUNT_HOLDER_NAME"
)

func NewSanctionsDetailsEntityTypeFromString(s string) (SanctionsDetailsEntityType, error) {
	switch s {
	case "CONSUMER_NAME":
		return SanctionsDetailsEntityTypeConsumerName, nil
	case "LEGAL_NAME":
		return SanctionsDetailsEntityTypeLegalName, nil
	case "SHAREHOLDER":
		return SanctionsDetailsEntityTypeShareholder, nil
	case "DIRECTOR":
		return SanctionsDetailsEntityTypeDirector, nil
	case "NAME_ON_CARD":
		return SanctionsDetailsEntityTypeNameOnCard, nil
	case "PAYMENT_NAME":
		return SanctionsDetailsEntityTypePaymentName, nil
	case "PAYMENT_BENEFICIARY_NAME":
		return SanctionsDetailsEntityTypePaymentBeneficiaryName, nil
	case "BANK_NAME":
		return SanctionsDetailsEntityTypeBankName, nil
	case "BANK_ACCOUNT_HOLDER_NAME":
		return SanctionsDetailsEntityTypeBankAccountHolderName, nil
	}
	var t SanctionsDetailsEntityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SanctionsDetailsEntityType) Ptr() *SanctionsDetailsEntityType {
	return &s
}

type SanctionsHitContext struct {
	Entity          SanctionsScreeningEntity    `json:"entity" url:"entity"`
	EntityType      *SanctionsDetailsEntityType `json:"entityType,omitempty" url:"entityType,omitempty"`
	UserId          *string                     `json:"userId,omitempty" url:"userId,omitempty"`
	TransactionId   *string                     `json:"transactionId,omitempty" url:"transactionId,omitempty"`
	RuleInstanceId  *string                     `json:"ruleInstanceId,omitempty" url:"ruleInstanceId,omitempty"`
	RuleId          *string                     `json:"ruleId,omitempty" url:"ruleId,omitempty"`
	Iban            *string                     `json:"iban,omitempty" url:"iban,omitempty"`
	YearOfBirth     *float64                    `json:"yearOfBirth,omitempty" url:"yearOfBirth,omitempty"`
	SearchTerm      *string                     `json:"searchTerm,omitempty" url:"searchTerm,omitempty"`
	PaymentMethodId *string                     `json:"paymentMethodId,omitempty" url:"paymentMethodId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SanctionsHitContext) GetEntity() SanctionsScreeningEntity {
	if s == nil {
		return ""
	}
	return s.Entity
}

func (s *SanctionsHitContext) GetEntityType() *SanctionsDetailsEntityType {
	if s == nil {
		return nil
	}
	return s.EntityType
}

func (s *SanctionsHitContext) GetUserId() *string {
	if s == nil {
		return nil
	}
	return s.UserId
}

func (s *SanctionsHitContext) GetTransactionId() *string {
	if s == nil {
		return nil
	}
	return s.TransactionId
}

func (s *SanctionsHitContext) GetRuleInstanceId() *string {
	if s == nil {
		return nil
	}
	return s.RuleInstanceId
}

func (s *SanctionsHitContext) GetRuleId() *string {
	if s == nil {
		return nil
	}
	return s.RuleId
}

func (s *SanctionsHitContext) GetIban() *string {
	if s == nil {
		return nil
	}
	return s.Iban
}

func (s *SanctionsHitContext) GetYearOfBirth() *float64 {
	if s == nil {
		return nil
	}
	return s.YearOfBirth
}

func (s *SanctionsHitContext) GetSearchTerm() *string {
	if s == nil {
		return nil
	}
	return s.SearchTerm
}

func (s *SanctionsHitContext) GetPaymentMethodId() *string {
	if s == nil {
		return nil
	}
	return s.PaymentMethodId
}

func (s *SanctionsHitContext) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SanctionsHitContext) UnmarshalJSON(data []byte) error {
	type unmarshaler SanctionsHitContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SanctionsHitContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SanctionsHitContext) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SanctionsScreeningEntity string

const (
	SanctionsScreeningEntityUser         SanctionsScreeningEntity = "USER"
	SanctionsScreeningEntityBank         SanctionsScreeningEntity = "BANK"
	SanctionsScreeningEntityIban         SanctionsScreeningEntity = "IBAN"
	SanctionsScreeningEntityExternalUser SanctionsScreeningEntity = "EXTERNAL_USER"
)

func NewSanctionsScreeningEntityFromString(s string) (SanctionsScreeningEntity, error) {
	switch s {
	case "USER":
		return SanctionsScreeningEntityUser, nil
	case "BANK":
		return SanctionsScreeningEntityBank, nil
	case "IBAN":
		return SanctionsScreeningEntityIban, nil
	case "EXTERNAL_USER":
		return SanctionsScreeningEntityExternalUser, nil
	}
	var t SanctionsScreeningEntity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SanctionsScreeningEntity) Ptr() *SanctionsScreeningEntity {
	return &s
}

type SanctionsStatus = bool

type SourceOfFunds string

const (
	SourceOfFundsEarnings            SourceOfFunds = "Earnings"
	SourceOfFundsSavings             SourceOfFunds = "Savings"
	SourceOfFundsInvestmentsDeposits SourceOfFunds = "Investments/Deposits"
	SourceOfFundsWealth              SourceOfFunds = "Wealth"
	SourceOfFundsGift                SourceOfFunds = "Gift"
	SourceOfFundsPension             SourceOfFunds = "Pension"
	SourceOfFundsInheritance         SourceOfFunds = "Inheritance"
	SourceOfFundsGambling            SourceOfFunds = "Gambling"
	SourceOfFundsBenefits            SourceOfFunds = "Benefits"
	SourceOfFundsPassive             SourceOfFunds = "Passive"
	SourceOfFundsFamily              SourceOfFunds = "Family"
	SourceOfFundsInsurance           SourceOfFunds = "Insurance"
	SourceOfFundsLegal               SourceOfFunds = "Legal"
	SourceOfFundsSales               SourceOfFunds = "Sales"
	SourceOfFundsRollover            SourceOfFunds = "Rollover"
	SourceOfFundsEquity              SourceOfFunds = "Equity"
	SourceOfFundsCrypto              SourceOfFunds = "Crypto"
	SourceOfFundsBusiness            SourceOfFunds = "Business"
	SourceOfFundsEmployment          SourceOfFunds = "Employment"
	SourceOfFundsSalary              SourceOfFunds = "Salary"
	SourceOfFundsRealEstateSale      SourceOfFunds = "Real Estate Sale"
	SourceOfFundsRealEstateRental    SourceOfFunds = "Real Estate Rental"
	SourceOfFundsCompanyExit         SourceOfFunds = "Company Exit"
)

func NewSourceOfFundsFromString(s string) (SourceOfFunds, error) {
	switch s {
	case "Earnings":
		return SourceOfFundsEarnings, nil
	case "Savings":
		return SourceOfFundsSavings, nil
	case "Investments/Deposits":
		return SourceOfFundsInvestmentsDeposits, nil
	case "Wealth":
		return SourceOfFundsWealth, nil
	case "Gift":
		return SourceOfFundsGift, nil
	case "Pension":
		return SourceOfFundsPension, nil
	case "Inheritance":
		return SourceOfFundsInheritance, nil
	case "Gambling":
		return SourceOfFundsGambling, nil
	case "Benefits":
		return SourceOfFundsBenefits, nil
	case "Passive":
		return SourceOfFundsPassive, nil
	case "Family":
		return SourceOfFundsFamily, nil
	case "Insurance":
		return SourceOfFundsInsurance, nil
	case "Legal":
		return SourceOfFundsLegal, nil
	case "Sales":
		return SourceOfFundsSales, nil
	case "Rollover":
		return SourceOfFundsRollover, nil
	case "Equity":
		return SourceOfFundsEquity, nil
	case "Crypto":
		return SourceOfFundsCrypto, nil
	case "Business":
		return SourceOfFundsBusiness, nil
	case "Employment":
		return SourceOfFundsEmployment, nil
	case "Salary":
		return SourceOfFundsSalary, nil
	case "Real Estate Sale":
		return SourceOfFundsRealEstateSale, nil
	case "Real Estate Rental":
		return SourceOfFundsRealEstateRental, nil
	case "Company Exit":
		return SourceOfFundsCompanyExit, nil
	}
	var t SourceOfFunds
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceOfFunds) Ptr() *SourceOfFunds {
	return &s
}

// Generic key-value pair model to append a custom variable being sent to Flagright API
type Tag struct {
	// Key value when you are creating a custom variable
	Key string `json:"key" url:"key"`
	// Value for a given key when you are creating a custom variable
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tag) GetKey() string {
	if t == nil {
		return ""
	}
	return t.Key
}

func (t *Tag) GetValue() string {
	if t == nil {
		return ""
	}
	return t.Value
}

func (t *Tag) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tag) UnmarshalJSON(data []byte) error {
	type unmarshaler Tag
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tag(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tag) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Transaction struct {
	// Type of transaction (ex: DEPOSIT, WITHDRAWAL, TRANSFER, EXTERNAL_PAYMENT, REFUND, OTHER)
	Type string `json:"type" url:"type"`
	// Unique transaction identifier
	TransactionId string `json:"transactionId" url:"transactionId"`
	// Timestamp of when transaction took place
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// UserId for where the transaction originates from
	OriginUserId *string `json:"originUserId,omitempty" url:"originUserId,omitempty"`
	// UserId for transaction's destination. In other words, where the value is being transferred to.
	DestinationUserId        *string                   `json:"destinationUserId,omitempty" url:"destinationUserId,omitempty"`
	TransactionState         *TransactionState         `json:"transactionState,omitempty" url:"transactionState,omitempty"`
	OriginAmountDetails      *TransactionAmountDetails `json:"originAmountDetails,omitempty" url:"originAmountDetails,omitempty"`
	DestinationAmountDetails *TransactionAmountDetails `json:"destinationAmountDetails,omitempty" url:"destinationAmountDetails,omitempty"`
	// Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.
	OriginPaymentDetails      *TransactionOriginPaymentDetails      `json:"originPaymentDetails,omitempty" url:"originPaymentDetails,omitempty"`
	DestinationPaymentDetails *TransactionDestinationPaymentDetails `json:"destinationPaymentDetails,omitempty" url:"destinationPaymentDetails,omitempty"`
	OriginFundsInfo           *OriginFundsInfo                      `json:"originFundsInfo,omitempty" url:"originFundsInfo,omitempty"`
	// IDs of transactions related to this transaction. Ex: refund, split bills
	RelatedTransactionIds []string `json:"relatedTransactionIds,omitempty" url:"relatedTransactionIds,omitempty"`
	// Type of produce being used by the consumer (ex wallets, payments etc)
	ProductType *string `json:"productType,omitempty" url:"productType,omitempty"`
	// Whether a promotion code was used or not the transaction
	PromotionCodeUsed *bool `json:"promotionCodeUsed,omitempty" url:"promotionCodeUsed,omitempty"`
	// Reference field for the transaction indicating the purpose of the transaction etc.
	Reference             *string     `json:"reference,omitempty" url:"reference,omitempty"`
	OriginDeviceData      *DeviceData `json:"originDeviceData,omitempty" url:"originDeviceData,omitempty"`
	DestinationDeviceData *DeviceData `json:"destinationDeviceData,omitempty" url:"destinationDeviceData,omitempty"`
	// Additional information that can be added via tags
	Tags        []*Tag   `json:"tags,omitempty" url:"tags,omitempty"`
	UpdateCount *float64 `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Transaction) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Transaction) GetTransactionId() string {
	if t == nil {
		return ""
	}
	return t.TransactionId
}

func (t *Transaction) GetTimestamp() float64 {
	if t == nil {
		return 0
	}
	return t.Timestamp
}

func (t *Transaction) GetOriginUserId() *string {
	if t == nil {
		return nil
	}
	return t.OriginUserId
}

func (t *Transaction) GetDestinationUserId() *string {
	if t == nil {
		return nil
	}
	return t.DestinationUserId
}

func (t *Transaction) GetTransactionState() *TransactionState {
	if t == nil {
		return nil
	}
	return t.TransactionState
}

func (t *Transaction) GetOriginAmountDetails() *TransactionAmountDetails {
	if t == nil {
		return nil
	}
	return t.OriginAmountDetails
}

func (t *Transaction) GetDestinationAmountDetails() *TransactionAmountDetails {
	if t == nil {
		return nil
	}
	return t.DestinationAmountDetails
}

func (t *Transaction) GetOriginPaymentDetails() *TransactionOriginPaymentDetails {
	if t == nil {
		return nil
	}
	return t.OriginPaymentDetails
}

func (t *Transaction) GetDestinationPaymentDetails() *TransactionDestinationPaymentDetails {
	if t == nil {
		return nil
	}
	return t.DestinationPaymentDetails
}

func (t *Transaction) GetOriginFundsInfo() *OriginFundsInfo {
	if t == nil {
		return nil
	}
	return t.OriginFundsInfo
}

func (t *Transaction) GetRelatedTransactionIds() []string {
	if t == nil {
		return nil
	}
	return t.RelatedTransactionIds
}

func (t *Transaction) GetProductType() *string {
	if t == nil {
		return nil
	}
	return t.ProductType
}

func (t *Transaction) GetPromotionCodeUsed() *bool {
	if t == nil {
		return nil
	}
	return t.PromotionCodeUsed
}

func (t *Transaction) GetReference() *string {
	if t == nil {
		return nil
	}
	return t.Reference
}

func (t *Transaction) GetOriginDeviceData() *DeviceData {
	if t == nil {
		return nil
	}
	return t.OriginDeviceData
}

func (t *Transaction) GetDestinationDeviceData() *DeviceData {
	if t == nil {
		return nil
	}
	return t.DestinationDeviceData
}

func (t *Transaction) GetTags() []*Tag {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *Transaction) GetUpdateCount() *float64 {
	if t == nil {
		return nil
	}
	return t.UpdateCount
}

func (t *Transaction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Transaction) UnmarshalJSON(data []byte) error {
	type unmarshaler Transaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Transaction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transaction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Model for transaction amount details
type TransactionAmountDetails struct {
	// Amount of the transaction
	TransactionAmount   float64      `json:"transactionAmount" url:"transactionAmount"`
	TransactionCurrency CurrencyCode `json:"transactionCurrency" url:"transactionCurrency"`
	Country             *CountryCode `json:"country,omitempty" url:"country,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionAmountDetails) GetTransactionAmount() float64 {
	if t == nil {
		return 0
	}
	return t.TransactionAmount
}

func (t *TransactionAmountDetails) GetTransactionCurrency() CurrencyCode {
	if t == nil {
		return ""
	}
	return t.TransactionCurrency
}

func (t *TransactionAmountDetails) GetCountry() *CountryCode {
	if t == nil {
		return nil
	}
	return t.Country
}

func (t *TransactionAmountDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionAmountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionAmountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionAmountDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionAmountDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionAmountLimit struct {
	Day   *Amount `json:"day,omitempty" url:"day,omitempty"`
	Week  *Amount `json:"week,omitempty" url:"week,omitempty"`
	Month *Amount `json:"month,omitempty" url:"month,omitempty"`
	Year  *Amount `json:"year,omitempty" url:"year,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionAmountLimit) GetDay() *Amount {
	if t == nil {
		return nil
	}
	return t.Day
}

func (t *TransactionAmountLimit) GetWeek() *Amount {
	if t == nil {
		return nil
	}
	return t.Week
}

func (t *TransactionAmountLimit) GetMonth() *Amount {
	if t == nil {
		return nil
	}
	return t.Month
}

func (t *TransactionAmountLimit) GetYear() *Amount {
	if t == nil {
		return nil
	}
	return t.Year
}

func (t *TransactionAmountLimit) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionAmountLimit) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionAmountLimit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionAmountLimit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionAmountLimit) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Model for transaction base Payload
type TransactionBase struct {
	// Type of transaction (ex: DEPOSIT, WITHDRAWAL, TRANSFER, EXTERNAL_PAYMENT, REFUND, OTHER)
	Type string `json:"type" url:"type"`
	// Unique transaction identifier
	TransactionId string `json:"transactionId" url:"transactionId"`
	// Timestamp of when transaction took place
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// UserId for where the transaction originates from
	OriginUserId *string `json:"originUserId,omitempty" url:"originUserId,omitempty"`
	// UserId for transaction's destination. In other words, where the value is being transferred to.
	DestinationUserId *string `json:"destinationUserId,omitempty" url:"destinationUserId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionBase) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TransactionBase) GetTransactionId() string {
	if t == nil {
		return ""
	}
	return t.TransactionId
}

func (t *TransactionBase) GetTimestamp() float64 {
	if t == nil {
		return 0
	}
	return t.Timestamp
}

func (t *TransactionBase) GetOriginUserId() *string {
	if t == nil {
		return nil
	}
	return t.OriginUserId
}

func (t *TransactionBase) GetDestinationUserId() *string {
	if t == nil {
		return nil
	}
	return t.DestinationUserId
}

func (t *TransactionBase) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionBase) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionBase) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionCountLimit struct {
	Day   *float64 `json:"day,omitempty" url:"day,omitempty"`
	Week  *float64 `json:"week,omitempty" url:"week,omitempty"`
	Month *float64 `json:"month,omitempty" url:"month,omitempty"`
	Year  *float64 `json:"year,omitempty" url:"year,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionCountLimit) GetDay() *float64 {
	if t == nil {
		return nil
	}
	return t.Day
}

func (t *TransactionCountLimit) GetWeek() *float64 {
	if t == nil {
		return nil
	}
	return t.Week
}

func (t *TransactionCountLimit) GetMonth() *float64 {
	if t == nil {
		return nil
	}
	return t.Month
}

func (t *TransactionCountLimit) GetYear() *float64 {
	if t == nil {
		return nil
	}
	return t.Year
}

func (t *TransactionCountLimit) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionCountLimit) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionCountLimit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionCountLimit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionCountLimit) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionDestinationPaymentDetails struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewTransactionDestinationPaymentDetailsFromCard(value *CardDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "CARD", Card: value}
}

func NewTransactionDestinationPaymentDetailsFromGenericBankAccount(value *GenericBankAccountDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewTransactionDestinationPaymentDetailsFromIban(value *IbanDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "IBAN", Iban: value}
}

func NewTransactionDestinationPaymentDetailsFromAch(value *AchDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "ACH", Ach: value}
}

func NewTransactionDestinationPaymentDetailsFromUpi(value *UpiDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "UPI", Upi: value}
}

func NewTransactionDestinationPaymentDetailsFromWallet(value *WalletDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "WALLET", Wallet: value}
}

func NewTransactionDestinationPaymentDetailsFromSwift(value *SwiftDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "SWIFT", Swift: value}
}

func NewTransactionDestinationPaymentDetailsFromMpesa(value *MpesaDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "MPESA", Mpesa: value}
}

func NewTransactionDestinationPaymentDetailsFromCheck(value *CheckDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "CHECK", Check: value}
}

func NewTransactionDestinationPaymentDetailsFromCash(value *CashDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "CASH", Cash: value}
}

func NewTransactionDestinationPaymentDetailsFromNpp(value *NppDetails) *TransactionDestinationPaymentDetails {
	return &TransactionDestinationPaymentDetails{Method: "NPP", Npp: value}
}

func (t *TransactionDestinationPaymentDetails) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TransactionDestinationPaymentDetails) GetCard() *CardDetails {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TransactionDestinationPaymentDetails) GetGenericBankAccount() *GenericBankAccountDetails {
	if t == nil {
		return nil
	}
	return t.GenericBankAccount
}

func (t *TransactionDestinationPaymentDetails) GetIban() *IbanDetails {
	if t == nil {
		return nil
	}
	return t.Iban
}

func (t *TransactionDestinationPaymentDetails) GetAch() *AchDetails {
	if t == nil {
		return nil
	}
	return t.Ach
}

func (t *TransactionDestinationPaymentDetails) GetUpi() *UpiDetails {
	if t == nil {
		return nil
	}
	return t.Upi
}

func (t *TransactionDestinationPaymentDetails) GetWallet() *WalletDetails {
	if t == nil {
		return nil
	}
	return t.Wallet
}

func (t *TransactionDestinationPaymentDetails) GetSwift() *SwiftDetails {
	if t == nil {
		return nil
	}
	return t.Swift
}

func (t *TransactionDestinationPaymentDetails) GetMpesa() *MpesaDetails {
	if t == nil {
		return nil
	}
	return t.Mpesa
}

func (t *TransactionDestinationPaymentDetails) GetCheck() *CheckDetails {
	if t == nil {
		return nil
	}
	return t.Check
}

func (t *TransactionDestinationPaymentDetails) GetCash() *CashDetails {
	if t == nil {
		return nil
	}
	return t.Cash
}

func (t *TransactionDestinationPaymentDetails) GetNpp() *NppDetails {
	if t == nil {
		return nil
	}
	return t.Npp
}

func (t *TransactionDestinationPaymentDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", t)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Ach = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Wallet = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Mpesa = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Npp = value
	}
	return nil
}

func (t TransactionDestinationPaymentDetails) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(t.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(t.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(t.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(t.Ach, "method", "ACH")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(t.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(t.Wallet, "method", "WALLET")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(t.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(t.Mpesa, "method", "MPESA")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(t.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(t.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(t.Npp, "method", "NPP")
	}
}

type TransactionDestinationPaymentDetailsVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (t *TransactionDestinationPaymentDetails) Accept(visitor TransactionDestinationPaymentDetailsVisitor) error {
	switch t.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return visitor.VisitCard(t.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(t.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(t.Iban)
	case "ACH":
		return visitor.VisitAch(t.Ach)
	case "UPI":
		return visitor.VisitUpi(t.Upi)
	case "WALLET":
		return visitor.VisitWallet(t.Wallet)
	case "SWIFT":
		return visitor.VisitSwift(t.Swift)
	case "MPESA":
		return visitor.VisitMpesa(t.Mpesa)
	case "CHECK":
		return visitor.VisitCheck(t.Check)
	case "CASH":
		return visitor.VisitCash(t.Cash)
	case "NPP":
		return visitor.VisitNpp(t.Npp)
	}
}

func (t *TransactionDestinationPaymentDetails) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Card != nil {
		fields = append(fields, "CARD")
	}
	if t.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if t.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if t.Ach != nil {
		fields = append(fields, "ACH")
	}
	if t.Upi != nil {
		fields = append(fields, "UPI")
	}
	if t.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if t.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if t.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if t.Check != nil {
		fields = append(fields, "CHECK")
	}
	if t.Cash != nil {
		fields = append(fields, "CASH")
	}
	if t.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if t.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Method)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Method != "" {
		field := fields[0]
		if t.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Method,
				t,
			)
		}
	}
	return nil
}

// Model for transaction-related events
type TransactionEvent struct {
	TransactionState TransactionState `json:"transactionState" url:"transactionState"`
	// Timestamp of the event
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// Transaction ID the event pertains to
	TransactionId string `json:"transactionId" url:"transactionId"`
	// Unique event ID
	EventId *string `json:"eventId,omitempty" url:"eventId,omitempty"`
	// Reason for the event or a state change
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// Event description
	EventDescription             *string               `json:"eventDescription,omitempty" url:"eventDescription,omitempty"`
	UpdatedTransactionAttributes *TransactionUpdatable `json:"updatedTransactionAttributes,omitempty" url:"updatedTransactionAttributes,omitempty"`
	MetaData                     *DeviceData           `json:"metaData,omitempty" url:"metaData,omitempty"`
	UpdateCount                  *float64              `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionEvent) GetTransactionState() TransactionState {
	if t == nil {
		return ""
	}
	return t.TransactionState
}

func (t *TransactionEvent) GetTimestamp() float64 {
	if t == nil {
		return 0
	}
	return t.Timestamp
}

func (t *TransactionEvent) GetTransactionId() string {
	if t == nil {
		return ""
	}
	return t.TransactionId
}

func (t *TransactionEvent) GetEventId() *string {
	if t == nil {
		return nil
	}
	return t.EventId
}

func (t *TransactionEvent) GetReason() *string {
	if t == nil {
		return nil
	}
	return t.Reason
}

func (t *TransactionEvent) GetEventDescription() *string {
	if t == nil {
		return nil
	}
	return t.EventDescription
}

func (t *TransactionEvent) GetUpdatedTransactionAttributes() *TransactionUpdatable {
	if t == nil {
		return nil
	}
	return t.UpdatedTransactionAttributes
}

func (t *TransactionEvent) GetMetaData() *DeviceData {
	if t == nil {
		return nil
	}
	return t.MetaData
}

func (t *TransactionEvent) GetUpdateCount() *float64 {
	if t == nil {
		return nil
	}
	return t.UpdateCount
}

func (t *TransactionEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionLimit struct {
	TransactionCountLimit         *TransactionCountLimit  `json:"transactionCountLimit,omitempty" url:"transactionCountLimit,omitempty"`
	TransactionAmountLimit        *TransactionAmountLimit `json:"transactionAmountLimit,omitempty" url:"transactionAmountLimit,omitempty"`
	AverageTransactionAmountLimit *TransactionAmountLimit `json:"averageTransactionAmountLimit,omitempty" url:"averageTransactionAmountLimit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionLimit) GetTransactionCountLimit() *TransactionCountLimit {
	if t == nil {
		return nil
	}
	return t.TransactionCountLimit
}

func (t *TransactionLimit) GetTransactionAmountLimit() *TransactionAmountLimit {
	if t == nil {
		return nil
	}
	return t.TransactionAmountLimit
}

func (t *TransactionLimit) GetAverageTransactionAmountLimit() *TransactionAmountLimit {
	if t == nil {
		return nil
	}
	return t.AverageTransactionAmountLimit
}

func (t *TransactionLimit) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionLimit) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionLimit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionLimit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionLimit) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Model for transaction limits for a given user
type TransactionLimits struct {
	MaximumDailyTransactionLimit     *Amount                               `json:"maximumDailyTransactionLimit,omitempty" url:"maximumDailyTransactionLimit,omitempty"`
	MaximumWeeklyTransactionLimit    *Amount                               `json:"maximumWeeklyTransactionLimit,omitempty" url:"maximumWeeklyTransactionLimit,omitempty"`
	MaximumMonthlyTransactionLimit   *Amount                               `json:"maximumMonthlyTransactionLimit,omitempty" url:"maximumMonthlyTransactionLimit,omitempty"`
	MaximumQuarterlyTransactionLimit *Amount                               `json:"maximumQuarterlyTransactionLimit,omitempty" url:"maximumQuarterlyTransactionLimit,omitempty"`
	MaximumTransactionLimit          *Amount                               `json:"maximumTransactionLimit,omitempty" url:"maximumTransactionLimit,omitempty"`
	MaximumYearlyTransactionLimit    *Amount                               `json:"maximumYearlyTransactionLimit,omitempty" url:"maximumYearlyTransactionLimit,omitempty"`
	PaymentMethodLimits              *TransactionLimitsPaymentMethodLimits `json:"paymentMethodLimits,omitempty" url:"paymentMethodLimits,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionLimits) GetMaximumDailyTransactionLimit() *Amount {
	if t == nil {
		return nil
	}
	return t.MaximumDailyTransactionLimit
}

func (t *TransactionLimits) GetMaximumWeeklyTransactionLimit() *Amount {
	if t == nil {
		return nil
	}
	return t.MaximumWeeklyTransactionLimit
}

func (t *TransactionLimits) GetMaximumMonthlyTransactionLimit() *Amount {
	if t == nil {
		return nil
	}
	return t.MaximumMonthlyTransactionLimit
}

func (t *TransactionLimits) GetMaximumQuarterlyTransactionLimit() *Amount {
	if t == nil {
		return nil
	}
	return t.MaximumQuarterlyTransactionLimit
}

func (t *TransactionLimits) GetMaximumTransactionLimit() *Amount {
	if t == nil {
		return nil
	}
	return t.MaximumTransactionLimit
}

func (t *TransactionLimits) GetMaximumYearlyTransactionLimit() *Amount {
	if t == nil {
		return nil
	}
	return t.MaximumYearlyTransactionLimit
}

func (t *TransactionLimits) GetPaymentMethodLimits() *TransactionLimitsPaymentMethodLimits {
	if t == nil {
		return nil
	}
	return t.PaymentMethodLimits
}

func (t *TransactionLimits) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionLimits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionLimits) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionLimitsPaymentMethodLimits struct {
	Ach                *TransactionLimit `json:"ACH,omitempty" url:"ACH,omitempty"`
	Card               *TransactionLimit `json:"CARD,omitempty" url:"CARD,omitempty"`
	Iban               *TransactionLimit `json:"IBAN,omitempty" url:"IBAN,omitempty"`
	Upi                *TransactionLimit `json:"UPI,omitempty" url:"UPI,omitempty"`
	GenericBankAccount *TransactionLimit `json:"GENERIC_BANK_ACCOUNT,omitempty" url:"GENERIC_BANK_ACCOUNT,omitempty"`
	Mpesa              *TransactionLimit `json:"MPESA,omitempty" url:"MPESA,omitempty"`
	Swift              *TransactionLimit `json:"SWIFT,omitempty" url:"SWIFT,omitempty"`
	Wallet             *TransactionLimit `json:"WALLET,omitempty" url:"WALLET,omitempty"`
	Check              *TransactionLimit `json:"CHECK,omitempty" url:"CHECK,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionLimitsPaymentMethodLimits) GetAch() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Ach
}

func (t *TransactionLimitsPaymentMethodLimits) GetCard() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TransactionLimitsPaymentMethodLimits) GetIban() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Iban
}

func (t *TransactionLimitsPaymentMethodLimits) GetUpi() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Upi
}

func (t *TransactionLimitsPaymentMethodLimits) GetGenericBankAccount() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.GenericBankAccount
}

func (t *TransactionLimitsPaymentMethodLimits) GetMpesa() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Mpesa
}

func (t *TransactionLimitsPaymentMethodLimits) GetSwift() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Swift
}

func (t *TransactionLimitsPaymentMethodLimits) GetWallet() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Wallet
}

func (t *TransactionLimitsPaymentMethodLimits) GetCheck() *TransactionLimit {
	if t == nil {
		return nil
	}
	return t.Check
}

func (t *TransactionLimitsPaymentMethodLimits) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionLimitsPaymentMethodLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionLimitsPaymentMethodLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionLimitsPaymentMethodLimits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionLimitsPaymentMethodLimits) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.
type TransactionOriginPaymentDetails struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewTransactionOriginPaymentDetailsFromCard(value *CardDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "CARD", Card: value}
}

func NewTransactionOriginPaymentDetailsFromGenericBankAccount(value *GenericBankAccountDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewTransactionOriginPaymentDetailsFromIban(value *IbanDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "IBAN", Iban: value}
}

func NewTransactionOriginPaymentDetailsFromAch(value *AchDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "ACH", Ach: value}
}

func NewTransactionOriginPaymentDetailsFromSwift(value *SwiftDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "SWIFT", Swift: value}
}

func NewTransactionOriginPaymentDetailsFromMpesa(value *MpesaDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "MPESA", Mpesa: value}
}

func NewTransactionOriginPaymentDetailsFromUpi(value *UpiDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "UPI", Upi: value}
}

func NewTransactionOriginPaymentDetailsFromWallet(value *WalletDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "WALLET", Wallet: value}
}

func NewTransactionOriginPaymentDetailsFromCheck(value *CheckDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "CHECK", Check: value}
}

func NewTransactionOriginPaymentDetailsFromCash(value *CashDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "CASH", Cash: value}
}

func NewTransactionOriginPaymentDetailsFromNpp(value *NppDetails) *TransactionOriginPaymentDetails {
	return &TransactionOriginPaymentDetails{Method: "NPP", Npp: value}
}

func (t *TransactionOriginPaymentDetails) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TransactionOriginPaymentDetails) GetCard() *CardDetails {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TransactionOriginPaymentDetails) GetGenericBankAccount() *GenericBankAccountDetails {
	if t == nil {
		return nil
	}
	return t.GenericBankAccount
}

func (t *TransactionOriginPaymentDetails) GetIban() *IbanDetails {
	if t == nil {
		return nil
	}
	return t.Iban
}

func (t *TransactionOriginPaymentDetails) GetAch() *AchDetails {
	if t == nil {
		return nil
	}
	return t.Ach
}

func (t *TransactionOriginPaymentDetails) GetSwift() *SwiftDetails {
	if t == nil {
		return nil
	}
	return t.Swift
}

func (t *TransactionOriginPaymentDetails) GetMpesa() *MpesaDetails {
	if t == nil {
		return nil
	}
	return t.Mpesa
}

func (t *TransactionOriginPaymentDetails) GetUpi() *UpiDetails {
	if t == nil {
		return nil
	}
	return t.Upi
}

func (t *TransactionOriginPaymentDetails) GetWallet() *WalletDetails {
	if t == nil {
		return nil
	}
	return t.Wallet
}

func (t *TransactionOriginPaymentDetails) GetCheck() *CheckDetails {
	if t == nil {
		return nil
	}
	return t.Check
}

func (t *TransactionOriginPaymentDetails) GetCash() *CashDetails {
	if t == nil {
		return nil
	}
	return t.Cash
}

func (t *TransactionOriginPaymentDetails) GetNpp() *NppDetails {
	if t == nil {
		return nil
	}
	return t.Npp
}

func (t *TransactionOriginPaymentDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", t)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Npp = value
	}
	return nil
}

func (t TransactionOriginPaymentDetails) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(t.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(t.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(t.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(t.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(t.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(t.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(t.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(t.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(t.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(t.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(t.Npp, "method", "NPP")
	}
}

type TransactionOriginPaymentDetailsVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (t *TransactionOriginPaymentDetails) Accept(visitor TransactionOriginPaymentDetailsVisitor) error {
	switch t.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return visitor.VisitCard(t.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(t.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(t.Iban)
	case "ACH":
		return visitor.VisitAch(t.Ach)
	case "SWIFT":
		return visitor.VisitSwift(t.Swift)
	case "MPESA":
		return visitor.VisitMpesa(t.Mpesa)
	case "UPI":
		return visitor.VisitUpi(t.Upi)
	case "WALLET":
		return visitor.VisitWallet(t.Wallet)
	case "CHECK":
		return visitor.VisitCheck(t.Check)
	case "CASH":
		return visitor.VisitCash(t.Cash)
	case "NPP":
		return visitor.VisitNpp(t.Npp)
	}
}

func (t *TransactionOriginPaymentDetails) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Card != nil {
		fields = append(fields, "CARD")
	}
	if t.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if t.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if t.Ach != nil {
		fields = append(fields, "ACH")
	}
	if t.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if t.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if t.Upi != nil {
		fields = append(fields, "UPI")
	}
	if t.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if t.Check != nil {
		fields = append(fields, "CHECK")
	}
	if t.Cash != nil {
		fields = append(fields, "CASH")
	}
	if t.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if t.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Method)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Method != "" {
		field := fields[0]
		if t.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Method,
				t,
			)
		}
	}
	return nil
}

type TransactionRiskScoringResult struct {
	// Transaction risk scoring score
	TrsScore     float64   `json:"trsScore" url:"trsScore"`
	TrsRiskLevel RiskLevel `json:"trsRiskLevel" url:"trsRiskLevel"`
	// Origin user's CRA risk score
	OriginUserCraRiskScore *float64 `json:"originUserCraRiskScore,omitempty" url:"originUserCraRiskScore,omitempty"`
	// Destination user's CRA risk score
	DestinationUserCraRiskScore *float64   `json:"destinationUserCraRiskScore,omitempty" url:"destinationUserCraRiskScore,omitempty"`
	OriginUserCraRiskLevel      *RiskLevel `json:"originUserCraRiskLevel,omitempty" url:"originUserCraRiskLevel,omitempty"`
	DestinationUserCraRiskLevel *RiskLevel `json:"destinationUserCraRiskLevel,omitempty" url:"destinationUserCraRiskLevel,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionRiskScoringResult) GetTrsScore() float64 {
	if t == nil {
		return 0
	}
	return t.TrsScore
}

func (t *TransactionRiskScoringResult) GetTrsRiskLevel() RiskLevel {
	if t == nil {
		return ""
	}
	return t.TrsRiskLevel
}

func (t *TransactionRiskScoringResult) GetOriginUserCraRiskScore() *float64 {
	if t == nil {
		return nil
	}
	return t.OriginUserCraRiskScore
}

func (t *TransactionRiskScoringResult) GetDestinationUserCraRiskScore() *float64 {
	if t == nil {
		return nil
	}
	return t.DestinationUserCraRiskScore
}

func (t *TransactionRiskScoringResult) GetOriginUserCraRiskLevel() *RiskLevel {
	if t == nil {
		return nil
	}
	return t.OriginUserCraRiskLevel
}

func (t *TransactionRiskScoringResult) GetDestinationUserCraRiskLevel() *RiskLevel {
	if t == nil {
		return nil
	}
	return t.DestinationUserCraRiskLevel
}

func (t *TransactionRiskScoringResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionRiskScoringResult) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionRiskScoringResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionRiskScoringResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionRiskScoringResult) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Model for transaction states. E.g. Processing, Refunded, Successful etc.
type TransactionState string

const (
	TransactionStateCreated    TransactionState = "CREATED"
	TransactionStateProcessing TransactionState = "PROCESSING"
	TransactionStateSent       TransactionState = "SENT"
	TransactionStateExpired    TransactionState = "EXPIRED"
	TransactionStateDeclined   TransactionState = "DECLINED"
	TransactionStateSuspended  TransactionState = "SUSPENDED"
	TransactionStateRefunded   TransactionState = "REFUNDED"
	TransactionStateSuccessful TransactionState = "SUCCESSFUL"
	TransactionStateReversed   TransactionState = "REVERSED"
)

func NewTransactionStateFromString(s string) (TransactionState, error) {
	switch s {
	case "CREATED":
		return TransactionStateCreated, nil
	case "PROCESSING":
		return TransactionStateProcessing, nil
	case "SENT":
		return TransactionStateSent, nil
	case "EXPIRED":
		return TransactionStateExpired, nil
	case "DECLINED":
		return TransactionStateDeclined, nil
	case "SUSPENDED":
		return TransactionStateSuspended, nil
	case "REFUNDED":
		return TransactionStateRefunded, nil
	case "SUCCESSFUL":
		return TransactionStateSuccessful, nil
	case "REVERSED":
		return TransactionStateReversed, nil
	}
	var t TransactionState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionState) Ptr() *TransactionState {
	return &t
}

type TransactionStatusDetails struct {
	TransactionId string     `json:"transactionId" url:"transactionId"`
	Reasons       []string   `json:"reasons,omitempty" url:"reasons,omitempty"`
	Status        RuleAction `json:"status" url:"status"`
	Comment       *string    `json:"comment,omitempty" url:"comment,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionStatusDetails) GetTransactionId() string {
	if t == nil {
		return ""
	}
	return t.TransactionId
}

func (t *TransactionStatusDetails) GetReasons() []string {
	if t == nil {
		return nil
	}
	return t.Reasons
}

func (t *TransactionStatusDetails) GetStatus() RuleAction {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionStatusDetails) GetComment() *string {
	if t == nil {
		return nil
	}
	return t.Comment
}

func (t *TransactionStatusDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionStatusDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionStatusDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionStatusDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionStatusDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Model for transaction additional payload
type TransactionUpdatable struct {
	TransactionState         *TransactionState         `json:"transactionState,omitempty" url:"transactionState,omitempty"`
	OriginAmountDetails      *TransactionAmountDetails `json:"originAmountDetails,omitempty" url:"originAmountDetails,omitempty"`
	DestinationAmountDetails *TransactionAmountDetails `json:"destinationAmountDetails,omitempty" url:"destinationAmountDetails,omitempty"`
	// Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.
	OriginPaymentDetails      *TransactionUpdatableOriginPaymentDetails      `json:"originPaymentDetails,omitempty" url:"originPaymentDetails,omitempty"`
	DestinationPaymentDetails *TransactionUpdatableDestinationPaymentDetails `json:"destinationPaymentDetails,omitempty" url:"destinationPaymentDetails,omitempty"`
	OriginFundsInfo           *OriginFundsInfo                               `json:"originFundsInfo,omitempty" url:"originFundsInfo,omitempty"`
	// IDs of transactions related to this transaction. Ex: refund, split bills
	RelatedTransactionIds []string `json:"relatedTransactionIds,omitempty" url:"relatedTransactionIds,omitempty"`
	// Type of produce being used by the consumer (ex wallets, payments etc)
	ProductType *string `json:"productType,omitempty" url:"productType,omitempty"`
	// Whether a promotion code was used or not the transaction
	PromotionCodeUsed *bool `json:"promotionCodeUsed,omitempty" url:"promotionCodeUsed,omitempty"`
	// Reference field for the transaction indicating the purpose of the transaction etc.
	Reference             *string     `json:"reference,omitempty" url:"reference,omitempty"`
	OriginDeviceData      *DeviceData `json:"originDeviceData,omitempty" url:"originDeviceData,omitempty"`
	DestinationDeviceData *DeviceData `json:"destinationDeviceData,omitempty" url:"destinationDeviceData,omitempty"`
	// Additional information that can be added via tags
	Tags        []*Tag   `json:"tags,omitempty" url:"tags,omitempty"`
	UpdateCount *float64 `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionUpdatable) GetTransactionState() *TransactionState {
	if t == nil {
		return nil
	}
	return t.TransactionState
}

func (t *TransactionUpdatable) GetOriginAmountDetails() *TransactionAmountDetails {
	if t == nil {
		return nil
	}
	return t.OriginAmountDetails
}

func (t *TransactionUpdatable) GetDestinationAmountDetails() *TransactionAmountDetails {
	if t == nil {
		return nil
	}
	return t.DestinationAmountDetails
}

func (t *TransactionUpdatable) GetOriginPaymentDetails() *TransactionUpdatableOriginPaymentDetails {
	if t == nil {
		return nil
	}
	return t.OriginPaymentDetails
}

func (t *TransactionUpdatable) GetDestinationPaymentDetails() *TransactionUpdatableDestinationPaymentDetails {
	if t == nil {
		return nil
	}
	return t.DestinationPaymentDetails
}

func (t *TransactionUpdatable) GetOriginFundsInfo() *OriginFundsInfo {
	if t == nil {
		return nil
	}
	return t.OriginFundsInfo
}

func (t *TransactionUpdatable) GetRelatedTransactionIds() []string {
	if t == nil {
		return nil
	}
	return t.RelatedTransactionIds
}

func (t *TransactionUpdatable) GetProductType() *string {
	if t == nil {
		return nil
	}
	return t.ProductType
}

func (t *TransactionUpdatable) GetPromotionCodeUsed() *bool {
	if t == nil {
		return nil
	}
	return t.PromotionCodeUsed
}

func (t *TransactionUpdatable) GetReference() *string {
	if t == nil {
		return nil
	}
	return t.Reference
}

func (t *TransactionUpdatable) GetOriginDeviceData() *DeviceData {
	if t == nil {
		return nil
	}
	return t.OriginDeviceData
}

func (t *TransactionUpdatable) GetDestinationDeviceData() *DeviceData {
	if t == nil {
		return nil
	}
	return t.DestinationDeviceData
}

func (t *TransactionUpdatable) GetTags() []*Tag {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *TransactionUpdatable) GetUpdateCount() *float64 {
	if t == nil {
		return nil
	}
	return t.UpdateCount
}

func (t *TransactionUpdatable) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionUpdatable) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionUpdatable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionUpdatable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionUpdatable) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionUpdatableDestinationPaymentDetails struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewTransactionUpdatableDestinationPaymentDetailsFromCard(value *CardDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "CARD", Card: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromGenericBankAccount(value *GenericBankAccountDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromIban(value *IbanDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "IBAN", Iban: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromAch(value *AchDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "ACH", Ach: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromUpi(value *UpiDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "UPI", Upi: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromWallet(value *WalletDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "WALLET", Wallet: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromSwift(value *SwiftDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "SWIFT", Swift: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromMpesa(value *MpesaDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "MPESA", Mpesa: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromCheck(value *CheckDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "CHECK", Check: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromCash(value *CashDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "CASH", Cash: value}
}

func NewTransactionUpdatableDestinationPaymentDetailsFromNpp(value *NppDetails) *TransactionUpdatableDestinationPaymentDetails {
	return &TransactionUpdatableDestinationPaymentDetails{Method: "NPP", Npp: value}
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetCard() *CardDetails {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetGenericBankAccount() *GenericBankAccountDetails {
	if t == nil {
		return nil
	}
	return t.GenericBankAccount
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetIban() *IbanDetails {
	if t == nil {
		return nil
	}
	return t.Iban
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetAch() *AchDetails {
	if t == nil {
		return nil
	}
	return t.Ach
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetUpi() *UpiDetails {
	if t == nil {
		return nil
	}
	return t.Upi
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetWallet() *WalletDetails {
	if t == nil {
		return nil
	}
	return t.Wallet
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetSwift() *SwiftDetails {
	if t == nil {
		return nil
	}
	return t.Swift
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetMpesa() *MpesaDetails {
	if t == nil {
		return nil
	}
	return t.Mpesa
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetCheck() *CheckDetails {
	if t == nil {
		return nil
	}
	return t.Check
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetCash() *CashDetails {
	if t == nil {
		return nil
	}
	return t.Cash
}

func (t *TransactionUpdatableDestinationPaymentDetails) GetNpp() *NppDetails {
	if t == nil {
		return nil
	}
	return t.Npp
}

func (t *TransactionUpdatableDestinationPaymentDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", t)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Ach = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Wallet = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Mpesa = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Npp = value
	}
	return nil
}

func (t TransactionUpdatableDestinationPaymentDetails) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(t.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(t.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(t.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(t.Ach, "method", "ACH")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(t.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(t.Wallet, "method", "WALLET")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(t.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(t.Mpesa, "method", "MPESA")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(t.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(t.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(t.Npp, "method", "NPP")
	}
}

type TransactionUpdatableDestinationPaymentDetailsVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (t *TransactionUpdatableDestinationPaymentDetails) Accept(visitor TransactionUpdatableDestinationPaymentDetailsVisitor) error {
	switch t.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return visitor.VisitCard(t.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(t.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(t.Iban)
	case "ACH":
		return visitor.VisitAch(t.Ach)
	case "UPI":
		return visitor.VisitUpi(t.Upi)
	case "WALLET":
		return visitor.VisitWallet(t.Wallet)
	case "SWIFT":
		return visitor.VisitSwift(t.Swift)
	case "MPESA":
		return visitor.VisitMpesa(t.Mpesa)
	case "CHECK":
		return visitor.VisitCheck(t.Check)
	case "CASH":
		return visitor.VisitCash(t.Cash)
	case "NPP":
		return visitor.VisitNpp(t.Npp)
	}
}

func (t *TransactionUpdatableDestinationPaymentDetails) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Card != nil {
		fields = append(fields, "CARD")
	}
	if t.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if t.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if t.Ach != nil {
		fields = append(fields, "ACH")
	}
	if t.Upi != nil {
		fields = append(fields, "UPI")
	}
	if t.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if t.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if t.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if t.Check != nil {
		fields = append(fields, "CHECK")
	}
	if t.Cash != nil {
		fields = append(fields, "CASH")
	}
	if t.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if t.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Method)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Method != "" {
		field := fields[0]
		if t.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Method,
				t,
			)
		}
	}
	return nil
}

// Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.
type TransactionUpdatableOriginPaymentDetails struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewTransactionUpdatableOriginPaymentDetailsFromCard(value *CardDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "CARD", Card: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromGenericBankAccount(value *GenericBankAccountDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromIban(value *IbanDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "IBAN", Iban: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromAch(value *AchDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "ACH", Ach: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromSwift(value *SwiftDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "SWIFT", Swift: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromMpesa(value *MpesaDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "MPESA", Mpesa: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromUpi(value *UpiDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "UPI", Upi: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromWallet(value *WalletDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "WALLET", Wallet: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromCheck(value *CheckDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "CHECK", Check: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromCash(value *CashDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "CASH", Cash: value}
}

func NewTransactionUpdatableOriginPaymentDetailsFromNpp(value *NppDetails) *TransactionUpdatableOriginPaymentDetails {
	return &TransactionUpdatableOriginPaymentDetails{Method: "NPP", Npp: value}
}

func (t *TransactionUpdatableOriginPaymentDetails) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TransactionUpdatableOriginPaymentDetails) GetCard() *CardDetails {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TransactionUpdatableOriginPaymentDetails) GetGenericBankAccount() *GenericBankAccountDetails {
	if t == nil {
		return nil
	}
	return t.GenericBankAccount
}

func (t *TransactionUpdatableOriginPaymentDetails) GetIban() *IbanDetails {
	if t == nil {
		return nil
	}
	return t.Iban
}

func (t *TransactionUpdatableOriginPaymentDetails) GetAch() *AchDetails {
	if t == nil {
		return nil
	}
	return t.Ach
}

func (t *TransactionUpdatableOriginPaymentDetails) GetSwift() *SwiftDetails {
	if t == nil {
		return nil
	}
	return t.Swift
}

func (t *TransactionUpdatableOriginPaymentDetails) GetMpesa() *MpesaDetails {
	if t == nil {
		return nil
	}
	return t.Mpesa
}

func (t *TransactionUpdatableOriginPaymentDetails) GetUpi() *UpiDetails {
	if t == nil {
		return nil
	}
	return t.Upi
}

func (t *TransactionUpdatableOriginPaymentDetails) GetWallet() *WalletDetails {
	if t == nil {
		return nil
	}
	return t.Wallet
}

func (t *TransactionUpdatableOriginPaymentDetails) GetCheck() *CheckDetails {
	if t == nil {
		return nil
	}
	return t.Check
}

func (t *TransactionUpdatableOriginPaymentDetails) GetCash() *CashDetails {
	if t == nil {
		return nil
	}
	return t.Cash
}

func (t *TransactionUpdatableOriginPaymentDetails) GetNpp() *NppDetails {
	if t == nil {
		return nil
	}
	return t.Npp
}

func (t *TransactionUpdatableOriginPaymentDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", t)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Npp = value
	}
	return nil
}

func (t TransactionUpdatableOriginPaymentDetails) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(t.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(t.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(t.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(t.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(t.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(t.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(t.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(t.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(t.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(t.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(t.Npp, "method", "NPP")
	}
}

type TransactionUpdatableOriginPaymentDetailsVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (t *TransactionUpdatableOriginPaymentDetails) Accept(visitor TransactionUpdatableOriginPaymentDetailsVisitor) error {
	switch t.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return visitor.VisitCard(t.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(t.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(t.Iban)
	case "ACH":
		return visitor.VisitAch(t.Ach)
	case "SWIFT":
		return visitor.VisitSwift(t.Swift)
	case "MPESA":
		return visitor.VisitMpesa(t.Mpesa)
	case "UPI":
		return visitor.VisitUpi(t.Upi)
	case "WALLET":
		return visitor.VisitWallet(t.Wallet)
	case "CHECK":
		return visitor.VisitCheck(t.Check)
	case "CASH":
		return visitor.VisitCash(t.Cash)
	case "NPP":
		return visitor.VisitNpp(t.Npp)
	}
}

func (t *TransactionUpdatableOriginPaymentDetails) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Card != nil {
		fields = append(fields, "CARD")
	}
	if t.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if t.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if t.Ach != nil {
		fields = append(fields, "ACH")
	}
	if t.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if t.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if t.Upi != nil {
		fields = append(fields, "UPI")
	}
	if t.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if t.Check != nil {
		fields = append(fields, "CHECK")
	}
	if t.Cash != nil {
		fields = append(fields, "CASH")
	}
	if t.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if t.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Method)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Method != "" {
		field := fields[0]
		if t.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Method,
				t,
			)
		}
	}
	return nil
}

// Model for UPI payment method
type UpiDetails struct {
	// UPI Id number
	UpiId string `json:"upiID" url:"upiID"`
	// Bank provider name
	BankProvider *string `json:"bankProvider,omitempty" url:"bankProvider,omitempty"`
	// Interface provider name
	InterfaceProvider *string `json:"interfaceProvider,omitempty" url:"interfaceProvider,omitempty"`
	// Name of the account holder
	Name    *string  `json:"name,omitempty" url:"name,omitempty"`
	EmailId *EmailId `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpiDetails) GetUpiId() string {
	if u == nil {
		return ""
	}
	return u.UpiId
}

func (u *UpiDetails) GetBankProvider() *string {
	if u == nil {
		return nil
	}
	return u.BankProvider
}

func (u *UpiDetails) GetInterfaceProvider() *string {
	if u == nil {
		return nil
	}
	return u.InterfaceProvider
}

func (u *UpiDetails) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpiDetails) GetEmailId() *EmailId {
	if u == nil {
		return nil
	}
	return u.EmailId
}

func (u *UpiDetails) GetTags() []*Tag {
	if u == nil {
		return nil
	}
	return u.Tags
}

func (u *UpiDetails) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpiDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler UpiDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpiDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpiDetails) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Classify the method of payment as "UPI" for UPIDetails
type UpiPaymentMethod = string

type User struct {
	// Unique user ID
	UserId string `json:"userId" url:"userId"`
	// Timestamp when userId is created
	CreatedTimestamp float64 `json:"createdTimestamp" url:"createdTimestamp"`
	// Timestamp when user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserDetails        *UserDetails      `json:"userDetails,omitempty" url:"userDetails,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	EoddDate           *float64          `json:"eoddDate,omitempty" url:"eoddDate,omitempty"`
	EmploymentStatus   *EmploymentStatus `json:"employmentStatus,omitempty" url:"employmentStatus,omitempty"`
	Occupation         *string           `json:"occupation,omitempty" url:"occupation,omitempty"`
	// User's legal identity documents - See Document Model for details
	LegalDocuments          []*LegalDocument     `json:"legalDocuments,omitempty" url:"legalDocuments,omitempty"`
	ContactDetails          *ContactDetails      `json:"contactDetails,omitempty" url:"contactDetails,omitempty"`
	EmploymentDetails       *EmploymentDetails   `json:"employmentDetails,omitempty" url:"employmentDetails,omitempty"`
	TransactionLimits       *TransactionLimits   `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	ExpectedIncome          *ExpectedIncome      `json:"expectedIncome,omitempty" url:"expectedIncome,omitempty"`
	RiskLevel               *RiskLevel           `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel            *RiskLevel           `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AcquisitionChannel      *AcquisitionChannel  `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	ReasonForAccountOpening []string             `json:"reasonForAccountOpening,omitempty" url:"reasonForAccountOpening,omitempty"`
	SourceOfFunds           []SourceOfFunds      `json:"sourceOfFunds,omitempty" url:"sourceOfFunds,omitempty"`
	UserSegment             *ConsumerUserSegment `json:"userSegment,omitempty" url:"userSegment,omitempty"`
	PepStatus               []*PepStatus         `json:"pepStatus,omitempty" url:"pepStatus,omitempty"`
	SanctionsStatus         *SanctionsStatus     `json:"sanctionsStatus,omitempty" url:"sanctionsStatus,omitempty"`
	AdverseMediaStatus      *AdverseMediaStatus  `json:"adverseMediaStatus,omitempty" url:"adverseMediaStatus,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                       `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	SavedPaymentDetails      []*UserSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// Uploaded user's attachment
	Attachments []*PersonAttachment `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount *float64            `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetUserId() string {
	if u == nil {
		return ""
	}
	return u.UserId
}

func (u *User) GetCreatedTimestamp() float64 {
	if u == nil {
		return 0
	}
	return u.CreatedTimestamp
}

func (u *User) GetActivatedTimestamp() *float64 {
	if u == nil {
		return nil
	}
	return u.ActivatedTimestamp
}

func (u *User) GetUserDetails() *UserDetails {
	if u == nil {
		return nil
	}
	return u.UserDetails
}

func (u *User) GetUserStateDetails() *UserStateDetails {
	if u == nil {
		return nil
	}
	return u.UserStateDetails
}

func (u *User) GetKycStatusDetails() *KycStatusDetails {
	if u == nil {
		return nil
	}
	return u.KycStatusDetails
}

func (u *User) GetEoddDate() *float64 {
	if u == nil {
		return nil
	}
	return u.EoddDate
}

func (u *User) GetEmploymentStatus() *EmploymentStatus {
	if u == nil {
		return nil
	}
	return u.EmploymentStatus
}

func (u *User) GetOccupation() *string {
	if u == nil {
		return nil
	}
	return u.Occupation
}

func (u *User) GetLegalDocuments() []*LegalDocument {
	if u == nil {
		return nil
	}
	return u.LegalDocuments
}

func (u *User) GetContactDetails() *ContactDetails {
	if u == nil {
		return nil
	}
	return u.ContactDetails
}

func (u *User) GetEmploymentDetails() *EmploymentDetails {
	if u == nil {
		return nil
	}
	return u.EmploymentDetails
}

func (u *User) GetTransactionLimits() *TransactionLimits {
	if u == nil {
		return nil
	}
	return u.TransactionLimits
}

func (u *User) GetExpectedIncome() *ExpectedIncome {
	if u == nil {
		return nil
	}
	return u.ExpectedIncome
}

func (u *User) GetRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.RiskLevel
}

func (u *User) GetKycRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.KycRiskLevel
}

func (u *User) GetAcquisitionChannel() *AcquisitionChannel {
	if u == nil {
		return nil
	}
	return u.AcquisitionChannel
}

func (u *User) GetReasonForAccountOpening() []string {
	if u == nil {
		return nil
	}
	return u.ReasonForAccountOpening
}

func (u *User) GetSourceOfFunds() []SourceOfFunds {
	if u == nil {
		return nil
	}
	return u.SourceOfFunds
}

func (u *User) GetUserSegment() *ConsumerUserSegment {
	if u == nil {
		return nil
	}
	return u.UserSegment
}

func (u *User) GetPepStatus() []*PepStatus {
	if u == nil {
		return nil
	}
	return u.PepStatus
}

func (u *User) GetSanctionsStatus() *SanctionsStatus {
	if u == nil {
		return nil
	}
	return u.SanctionsStatus
}

func (u *User) GetAdverseMediaStatus() *AdverseMediaStatus {
	if u == nil {
		return nil
	}
	return u.AdverseMediaStatus
}

func (u *User) GetLastTransactionTimestamp() *float64 {
	if u == nil {
		return nil
	}
	return u.LastTransactionTimestamp
}

func (u *User) GetLinkedEntities() *UserEntityLink {
	if u == nil {
		return nil
	}
	return u.LinkedEntities
}

func (u *User) GetSavedPaymentDetails() []*UserSavedPaymentDetailsItem {
	if u == nil {
		return nil
	}
	return u.SavedPaymentDetails
}

func (u *User) GetTags() []*UserTag {
	if u == nil {
		return nil
	}
	return u.Tags
}

func (u *User) GetAttachments() []*PersonAttachment {
	if u == nil {
		return nil
	}
	return u.Attachments
}

func (u *User) GetUpdateCount() *float64 {
	if u == nil {
		return nil
	}
	return u.UpdateCount
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Model for User details
type UserBase struct {
	// Unique user ID
	UserId string `json:"userId" url:"userId"`
	// Timestamp when userId is created
	CreatedTimestamp float64 `json:"createdTimestamp" url:"createdTimestamp"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserBase) GetUserId() string {
	if u == nil {
		return ""
	}
	return u.UserId
}

func (u *UserBase) GetCreatedTimestamp() float64 {
	if u == nil {
		return 0
	}
	return u.CreatedTimestamp
}

func (u *UserBase) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserBase) UnmarshalJSON(data []byte) error {
	type unmarshaler UserBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserBase) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Model for consumer user personal details
type UserDetails struct {
	Name *ConsumerName `json:"name,omitempty" url:"name,omitempty"`
	// Date of birth of the user (YYYY-MM-DD)
	DateOfBirth *string `json:"dateOfBirth,omitempty" url:"dateOfBirth,omitempty"`
	// Internal category of the user
	UserCategory          *string        `json:"userCategory,omitempty" url:"userCategory,omitempty"`
	CountryOfResidence    *CountryCode   `json:"countryOfResidence,omitempty" url:"countryOfResidence,omitempty"`
	CountryOfTaxResidence *CountryCode   `json:"countryOfTaxResidence,omitempty" url:"countryOfTaxResidence,omitempty"`
	CountryOfNationality  *CountryCode   `json:"countryOfNationality,omitempty" url:"countryOfNationality,omitempty"`
	Gender                *Gender        `json:"gender,omitempty" url:"gender,omitempty"`
	MaritalStatus         *MaritalStatus `json:"maritalStatus,omitempty" url:"maritalStatus,omitempty"`
	PlaceOfBirth          *PlaceOfBirth  `json:"placeOfBirth,omitempty" url:"placeOfBirth,omitempty"`
	// Alias names of the user
	Alias []string `json:"alias,omitempty" url:"alias,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserDetails) GetName() *ConsumerName {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UserDetails) GetDateOfBirth() *string {
	if u == nil {
		return nil
	}
	return u.DateOfBirth
}

func (u *UserDetails) GetUserCategory() *string {
	if u == nil {
		return nil
	}
	return u.UserCategory
}

func (u *UserDetails) GetCountryOfResidence() *CountryCode {
	if u == nil {
		return nil
	}
	return u.CountryOfResidence
}

func (u *UserDetails) GetCountryOfTaxResidence() *CountryCode {
	if u == nil {
		return nil
	}
	return u.CountryOfTaxResidence
}

func (u *UserDetails) GetCountryOfNationality() *CountryCode {
	if u == nil {
		return nil
	}
	return u.CountryOfNationality
}

func (u *UserDetails) GetGender() *Gender {
	if u == nil {
		return nil
	}
	return u.Gender
}

func (u *UserDetails) GetMaritalStatus() *MaritalStatus {
	if u == nil {
		return nil
	}
	return u.MaritalStatus
}

func (u *UserDetails) GetPlaceOfBirth() *PlaceOfBirth {
	if u == nil {
		return nil
	}
	return u.PlaceOfBirth
}

func (u *UserDetails) GetAlias() []string {
	if u == nil {
		return nil
	}
	return u.Alias
}

func (u *UserDetails) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler UserDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserDetails) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserEntityLink struct {
	ParentUserId *string `json:"parentUserId,omitempty" url:"parentUserId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserEntityLink) GetParentUserId() *string {
	if u == nil {
		return nil
	}
	return u.ParentUserId
}

func (u *UserEntityLink) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserEntityLink) UnmarshalJSON(data []byte) error {
	type unmarshaler UserEntityLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserEntityLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserEntityLink) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Model for User details
type UserOptional struct {
	// Timestamp when user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserDetails        *UserDetails      `json:"userDetails,omitempty" url:"userDetails,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	EoddDate           *float64          `json:"eoddDate,omitempty" url:"eoddDate,omitempty"`
	EmploymentStatus   *EmploymentStatus `json:"employmentStatus,omitempty" url:"employmentStatus,omitempty"`
	Occupation         *string           `json:"occupation,omitempty" url:"occupation,omitempty"`
	// User's legal identity documents - See Document Model for details
	LegalDocuments          []*LegalDocument     `json:"legalDocuments,omitempty" url:"legalDocuments,omitempty"`
	ContactDetails          *ContactDetails      `json:"contactDetails,omitempty" url:"contactDetails,omitempty"`
	EmploymentDetails       *EmploymentDetails   `json:"employmentDetails,omitempty" url:"employmentDetails,omitempty"`
	TransactionLimits       *TransactionLimits   `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	ExpectedIncome          *ExpectedIncome      `json:"expectedIncome,omitempty" url:"expectedIncome,omitempty"`
	RiskLevel               *RiskLevel           `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel            *RiskLevel           `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AcquisitionChannel      *AcquisitionChannel  `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	ReasonForAccountOpening []string             `json:"reasonForAccountOpening,omitempty" url:"reasonForAccountOpening,omitempty"`
	SourceOfFunds           []SourceOfFunds      `json:"sourceOfFunds,omitempty" url:"sourceOfFunds,omitempty"`
	UserSegment             *ConsumerUserSegment `json:"userSegment,omitempty" url:"userSegment,omitempty"`
	PepStatus               []*PepStatus         `json:"pepStatus,omitempty" url:"pepStatus,omitempty"`
	SanctionsStatus         *SanctionsStatus     `json:"sanctionsStatus,omitempty" url:"sanctionsStatus,omitempty"`
	AdverseMediaStatus      *AdverseMediaStatus  `json:"adverseMediaStatus,omitempty" url:"adverseMediaStatus,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                               `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                        `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	SavedPaymentDetails      []*UserOptionalSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// Uploaded user's attachment
	Attachments []*PersonAttachment `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount *float64            `json:"updateCount,omitempty" url:"updateCount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserOptional) GetActivatedTimestamp() *float64 {
	if u == nil {
		return nil
	}
	return u.ActivatedTimestamp
}

func (u *UserOptional) GetUserDetails() *UserDetails {
	if u == nil {
		return nil
	}
	return u.UserDetails
}

func (u *UserOptional) GetUserStateDetails() *UserStateDetails {
	if u == nil {
		return nil
	}
	return u.UserStateDetails
}

func (u *UserOptional) GetKycStatusDetails() *KycStatusDetails {
	if u == nil {
		return nil
	}
	return u.KycStatusDetails
}

func (u *UserOptional) GetEoddDate() *float64 {
	if u == nil {
		return nil
	}
	return u.EoddDate
}

func (u *UserOptional) GetEmploymentStatus() *EmploymentStatus {
	if u == nil {
		return nil
	}
	return u.EmploymentStatus
}

func (u *UserOptional) GetOccupation() *string {
	if u == nil {
		return nil
	}
	return u.Occupation
}

func (u *UserOptional) GetLegalDocuments() []*LegalDocument {
	if u == nil {
		return nil
	}
	return u.LegalDocuments
}

func (u *UserOptional) GetContactDetails() *ContactDetails {
	if u == nil {
		return nil
	}
	return u.ContactDetails
}

func (u *UserOptional) GetEmploymentDetails() *EmploymentDetails {
	if u == nil {
		return nil
	}
	return u.EmploymentDetails
}

func (u *UserOptional) GetTransactionLimits() *TransactionLimits {
	if u == nil {
		return nil
	}
	return u.TransactionLimits
}

func (u *UserOptional) GetExpectedIncome() *ExpectedIncome {
	if u == nil {
		return nil
	}
	return u.ExpectedIncome
}

func (u *UserOptional) GetRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.RiskLevel
}

func (u *UserOptional) GetKycRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.KycRiskLevel
}

func (u *UserOptional) GetAcquisitionChannel() *AcquisitionChannel {
	if u == nil {
		return nil
	}
	return u.AcquisitionChannel
}

func (u *UserOptional) GetReasonForAccountOpening() []string {
	if u == nil {
		return nil
	}
	return u.ReasonForAccountOpening
}

func (u *UserOptional) GetSourceOfFunds() []SourceOfFunds {
	if u == nil {
		return nil
	}
	return u.SourceOfFunds
}

func (u *UserOptional) GetUserSegment() *ConsumerUserSegment {
	if u == nil {
		return nil
	}
	return u.UserSegment
}

func (u *UserOptional) GetPepStatus() []*PepStatus {
	if u == nil {
		return nil
	}
	return u.PepStatus
}

func (u *UserOptional) GetSanctionsStatus() *SanctionsStatus {
	if u == nil {
		return nil
	}
	return u.SanctionsStatus
}

func (u *UserOptional) GetAdverseMediaStatus() *AdverseMediaStatus {
	if u == nil {
		return nil
	}
	return u.AdverseMediaStatus
}

func (u *UserOptional) GetLastTransactionTimestamp() *float64 {
	if u == nil {
		return nil
	}
	return u.LastTransactionTimestamp
}

func (u *UserOptional) GetLinkedEntities() *UserEntityLink {
	if u == nil {
		return nil
	}
	return u.LinkedEntities
}

func (u *UserOptional) GetSavedPaymentDetails() []*UserOptionalSavedPaymentDetailsItem {
	if u == nil {
		return nil
	}
	return u.SavedPaymentDetails
}

func (u *UserOptional) GetTags() []*UserTag {
	if u == nil {
		return nil
	}
	return u.Tags
}

func (u *UserOptional) GetAttachments() []*PersonAttachment {
	if u == nil {
		return nil
	}
	return u.Attachments
}

func (u *UserOptional) GetUpdateCount() *float64 {
	if u == nil {
		return nil
	}
	return u.UpdateCount
}

func (u *UserOptional) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserOptional) UnmarshalJSON(data []byte) error {
	type unmarshaler UserOptional
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserOptional(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserOptional) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserOptionalSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewUserOptionalSavedPaymentDetailsItemFromCard(value *CardDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromIban(value *IbanDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromAch(value *AchDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromUpi(value *UpiDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromWallet(value *WalletDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromCheck(value *CheckDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromCash(value *CashDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewUserOptionalSavedPaymentDetailsItemFromNpp(value *NppDetails) *UserOptionalSavedPaymentDetailsItem {
	return &UserOptionalSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (u *UserOptionalSavedPaymentDetailsItem) GetMethod() string {
	if u == nil {
		return ""
	}
	return u.Method
}

func (u *UserOptionalSavedPaymentDetailsItem) GetCard() *CardDetails {
	if u == nil {
		return nil
	}
	return u.Card
}

func (u *UserOptionalSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if u == nil {
		return nil
	}
	return u.GenericBankAccount
}

func (u *UserOptionalSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if u == nil {
		return nil
	}
	return u.Iban
}

func (u *UserOptionalSavedPaymentDetailsItem) GetAch() *AchDetails {
	if u == nil {
		return nil
	}
	return u.Ach
}

func (u *UserOptionalSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if u == nil {
		return nil
	}
	return u.Swift
}

func (u *UserOptionalSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if u == nil {
		return nil
	}
	return u.Mpesa
}

func (u *UserOptionalSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if u == nil {
		return nil
	}
	return u.Upi
}

func (u *UserOptionalSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if u == nil {
		return nil
	}
	return u.Wallet
}

func (u *UserOptionalSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if u == nil {
		return nil
	}
	return u.Check
}

func (u *UserOptionalSavedPaymentDetailsItem) GetCash() *CashDetails {
	if u == nil {
		return nil
	}
	return u.Cash
}

func (u *UserOptionalSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if u == nil {
		return nil
	}
	return u.Npp
}

func (u *UserOptionalSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", u)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Npp = value
	}
	return nil
}

func (u UserOptionalSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Method, u)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(u.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(u.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(u.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(u.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(u.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(u.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(u.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(u.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(u.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(u.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(u.Npp, "method", "NPP")
	}
}

type UserOptionalSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (u *UserOptionalSavedPaymentDetailsItem) Accept(visitor UserOptionalSavedPaymentDetailsItemVisitor) error {
	switch u.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Method, u)
	case "CARD":
		return visitor.VisitCard(u.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(u.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(u.Iban)
	case "ACH":
		return visitor.VisitAch(u.Ach)
	case "SWIFT":
		return visitor.VisitSwift(u.Swift)
	case "MPESA":
		return visitor.VisitMpesa(u.Mpesa)
	case "UPI":
		return visitor.VisitUpi(u.Upi)
	case "WALLET":
		return visitor.VisitWallet(u.Wallet)
	case "CHECK":
		return visitor.VisitCheck(u.Check)
	case "CASH":
		return visitor.VisitCash(u.Cash)
	case "NPP":
		return visitor.VisitNpp(u.Npp)
	}
}

func (u *UserOptionalSavedPaymentDetailsItem) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Card != nil {
		fields = append(fields, "CARD")
	}
	if u.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if u.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if u.Ach != nil {
		fields = append(fields, "ACH")
	}
	if u.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if u.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if u.Upi != nil {
		fields = append(fields, "UPI")
	}
	if u.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if u.Check != nil {
		fields = append(fields, "CHECK")
	}
	if u.Cash != nil {
		fields = append(fields, "CASH")
	}
	if u.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if u.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Method)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Method != "" {
		field := fields[0]
		if u.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Method,
				u,
			)
		}
	}
	return nil
}

type UserRegistrationStatus string

const (
	UserRegistrationStatusRegistered   UserRegistrationStatus = "REGISTERED"
	UserRegistrationStatusUnregistered UserRegistrationStatus = "UNREGISTERED"
)

func NewUserRegistrationStatusFromString(s string) (UserRegistrationStatus, error) {
	switch s {
	case "REGISTERED":
		return UserRegistrationStatusRegistered, nil
	case "UNREGISTERED":
		return UserRegistrationStatusUnregistered, nil
	}
	var t UserRegistrationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserRegistrationStatus) Ptr() *UserRegistrationStatus {
	return &u
}

type UserRiskScoreDetails struct {
	KycRiskScore *float64   `json:"kycRiskScore,omitempty" url:"kycRiskScore,omitempty"`
	CraRiskScore *float64   `json:"craRiskScore,omitempty" url:"craRiskScore,omitempty"`
	KycRiskLevel *RiskLevel `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	CraRiskLevel *RiskLevel `json:"craRiskLevel,omitempty" url:"craRiskLevel,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserRiskScoreDetails) GetKycRiskScore() *float64 {
	if u == nil {
		return nil
	}
	return u.KycRiskScore
}

func (u *UserRiskScoreDetails) GetCraRiskScore() *float64 {
	if u == nil {
		return nil
	}
	return u.CraRiskScore
}

func (u *UserRiskScoreDetails) GetKycRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.KycRiskLevel
}

func (u *UserRiskScoreDetails) GetCraRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.CraRiskLevel
}

func (u *UserRiskScoreDetails) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserRiskScoreDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRiskScoreDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRiskScoreDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRiskScoreDetails) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRulesResult struct {
	ExecutedRules    []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	HitRules         []*HitRulesDetails     `json:"hitRules,omitempty" url:"hitRules,omitempty"`
	RiskScoreDetails *UserRiskScoreDetails  `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if u == nil {
		return nil
	}
	return u.ExecutedRules
}

func (u *UserRulesResult) GetHitRules() []*HitRulesDetails {
	if u == nil {
		return nil
	}
	return u.HitRules
}

func (u *UserRulesResult) GetRiskScoreDetails() *UserRiskScoreDetails {
	if u == nil {
		return nil
	}
	return u.RiskScoreDetails
}

func (u *UserRulesResult) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRulesResult) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewUserSavedPaymentDetailsItemFromCard(value *CardDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewUserSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewUserSavedPaymentDetailsItemFromIban(value *IbanDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewUserSavedPaymentDetailsItemFromAch(value *AchDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewUserSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewUserSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewUserSavedPaymentDetailsItemFromUpi(value *UpiDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewUserSavedPaymentDetailsItemFromWallet(value *WalletDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewUserSavedPaymentDetailsItemFromCheck(value *CheckDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewUserSavedPaymentDetailsItemFromCash(value *CashDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewUserSavedPaymentDetailsItemFromNpp(value *NppDetails) *UserSavedPaymentDetailsItem {
	return &UserSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (u *UserSavedPaymentDetailsItem) GetMethod() string {
	if u == nil {
		return ""
	}
	return u.Method
}

func (u *UserSavedPaymentDetailsItem) GetCard() *CardDetails {
	if u == nil {
		return nil
	}
	return u.Card
}

func (u *UserSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if u == nil {
		return nil
	}
	return u.GenericBankAccount
}

func (u *UserSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if u == nil {
		return nil
	}
	return u.Iban
}

func (u *UserSavedPaymentDetailsItem) GetAch() *AchDetails {
	if u == nil {
		return nil
	}
	return u.Ach
}

func (u *UserSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if u == nil {
		return nil
	}
	return u.Swift
}

func (u *UserSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if u == nil {
		return nil
	}
	return u.Mpesa
}

func (u *UserSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if u == nil {
		return nil
	}
	return u.Upi
}

func (u *UserSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if u == nil {
		return nil
	}
	return u.Wallet
}

func (u *UserSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if u == nil {
		return nil
	}
	return u.Check
}

func (u *UserSavedPaymentDetailsItem) GetCash() *CashDetails {
	if u == nil {
		return nil
	}
	return u.Cash
}

func (u *UserSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if u == nil {
		return nil
	}
	return u.Npp
}

func (u *UserSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", u)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Npp = value
	}
	return nil
}

func (u UserSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Method, u)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(u.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(u.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(u.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(u.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(u.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(u.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(u.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(u.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(u.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(u.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(u.Npp, "method", "NPP")
	}
}

type UserSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (u *UserSavedPaymentDetailsItem) Accept(visitor UserSavedPaymentDetailsItemVisitor) error {
	switch u.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Method, u)
	case "CARD":
		return visitor.VisitCard(u.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(u.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(u.Iban)
	case "ACH":
		return visitor.VisitAch(u.Ach)
	case "SWIFT":
		return visitor.VisitSwift(u.Swift)
	case "MPESA":
		return visitor.VisitMpesa(u.Mpesa)
	case "UPI":
		return visitor.VisitUpi(u.Upi)
	case "WALLET":
		return visitor.VisitWallet(u.Wallet)
	case "CHECK":
		return visitor.VisitCheck(u.Check)
	case "CASH":
		return visitor.VisitCash(u.Cash)
	case "NPP":
		return visitor.VisitNpp(u.Npp)
	}
}

func (u *UserSavedPaymentDetailsItem) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Card != nil {
		fields = append(fields, "CARD")
	}
	if u.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if u.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if u.Ach != nil {
		fields = append(fields, "ACH")
	}
	if u.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if u.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if u.Upi != nil {
		fields = append(fields, "UPI")
	}
	if u.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if u.Check != nil {
		fields = append(fields, "CHECK")
	}
	if u.Cash != nil {
		fields = append(fields, "CASH")
	}
	if u.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if u.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Method)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Method != "" {
		field := fields[0]
		if u.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Method,
				u,
			)
		}
	}
	return nil
}

type UserState string

const (
	UserStateUnacceptable UserState = "UNACCEPTABLE"
	UserStateTerminated   UserState = "TERMINATED"
	UserStateActive       UserState = "ACTIVE"
	UserStateDormant      UserState = "DORMANT"
	UserStateCreated      UserState = "CREATED"
	UserStateSuspended    UserState = "SUSPENDED"
	UserStateBlocked      UserState = "BLOCKED"
)

func NewUserStateFromString(s string) (UserState, error) {
	switch s {
	case "UNACCEPTABLE":
		return UserStateUnacceptable, nil
	case "TERMINATED":
		return UserStateTerminated, nil
	case "ACTIVE":
		return UserStateActive, nil
	case "DORMANT":
		return UserStateDormant, nil
	case "CREATED":
		return UserStateCreated, nil
	case "SUSPENDED":
		return UserStateSuspended, nil
	case "BLOCKED":
		return UserStateBlocked, nil
	}
	var t UserState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserState) Ptr() *UserState {
	return &u
}

type UserStateDetails struct {
	Reason *string   `json:"reason,omitempty" url:"reason,omitempty"`
	State  UserState `json:"state" url:"state"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserStateDetails) GetReason() *string {
	if u == nil {
		return nil
	}
	return u.Reason
}

func (u *UserStateDetails) GetState() UserState {
	if u == nil {
		return ""
	}
	return u.State
}

func (u *UserStateDetails) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserStateDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler UserStateDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserStateDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserStateDetails) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserTag struct {
	// Key value when you are creating a custom variable
	Key string `json:"key" url:"key"`
	// Value for a given key when you are creating a custom variable
	Value string `json:"value" url:"value"`
	// Flag to indicate if the tag is editable over the console
	IsEditable *bool `json:"isEditable,omitempty" url:"isEditable,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserTag) GetKey() string {
	if u == nil {
		return ""
	}
	return u.Key
}

func (u *UserTag) GetValue() string {
	if u == nil {
		return ""
	}
	return u.Value
}

func (u *UserTag) GetIsEditable() *bool {
	if u == nil {
		return nil
	}
	return u.IsEditable
}

func (u *UserTag) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserTag) UnmarshalJSON(data []byte) error {
	type unmarshaler UserTag
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserTag(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserTag) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserTagsUpdate struct {
	UserId *string    `json:"userId,omitempty" url:"userId,omitempty"`
	Tags   []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserTagsUpdate) GetUserId() *string {
	if u == nil {
		return nil
	}
	return u.UserId
}

func (u *UserTagsUpdate) GetTags() []*UserTag {
	if u == nil {
		return nil
	}
	return u.Tags
}

func (u *UserTagsUpdate) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserTagsUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler UserTagsUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserTagsUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserTagsUpdate) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserWithRulesResult struct {
	// Unique user ID
	UserId string `json:"userId" url:"userId"`
	// Timestamp when userId is created
	CreatedTimestamp float64 `json:"createdTimestamp" url:"createdTimestamp"`
	// Timestamp when user was activated
	ActivatedTimestamp *float64          `json:"activatedTimestamp,omitempty" url:"activatedTimestamp,omitempty"`
	UserDetails        *UserDetails      `json:"userDetails,omitempty" url:"userDetails,omitempty"`
	UserStateDetails   *UserStateDetails `json:"userStateDetails,omitempty" url:"userStateDetails,omitempty"`
	KycStatusDetails   *KycStatusDetails `json:"kycStatusDetails,omitempty" url:"kycStatusDetails,omitempty"`
	EoddDate           *float64          `json:"eoddDate,omitempty" url:"eoddDate,omitempty"`
	EmploymentStatus   *EmploymentStatus `json:"employmentStatus,omitempty" url:"employmentStatus,omitempty"`
	Occupation         *string           `json:"occupation,omitempty" url:"occupation,omitempty"`
	// User's legal identity documents - See Document Model for details
	LegalDocuments          []*LegalDocument     `json:"legalDocuments,omitempty" url:"legalDocuments,omitempty"`
	ContactDetails          *ContactDetails      `json:"contactDetails,omitempty" url:"contactDetails,omitempty"`
	EmploymentDetails       *EmploymentDetails   `json:"employmentDetails,omitempty" url:"employmentDetails,omitempty"`
	TransactionLimits       *TransactionLimits   `json:"transactionLimits,omitempty" url:"transactionLimits,omitempty"`
	ExpectedIncome          *ExpectedIncome      `json:"expectedIncome,omitempty" url:"expectedIncome,omitempty"`
	RiskLevel               *RiskLevel           `json:"riskLevel,omitempty" url:"riskLevel,omitempty"`
	KycRiskLevel            *RiskLevel           `json:"kycRiskLevel,omitempty" url:"kycRiskLevel,omitempty"`
	AcquisitionChannel      *AcquisitionChannel  `json:"acquisitionChannel,omitempty" url:"acquisitionChannel,omitempty"`
	ReasonForAccountOpening []string             `json:"reasonForAccountOpening,omitempty" url:"reasonForAccountOpening,omitempty"`
	SourceOfFunds           []SourceOfFunds      `json:"sourceOfFunds,omitempty" url:"sourceOfFunds,omitempty"`
	UserSegment             *ConsumerUserSegment `json:"userSegment,omitempty" url:"userSegment,omitempty"`
	PepStatus               []*PepStatus         `json:"pepStatus,omitempty" url:"pepStatus,omitempty"`
	SanctionsStatus         *SanctionsStatus     `json:"sanctionsStatus,omitempty" url:"sanctionsStatus,omitempty"`
	AdverseMediaStatus      *AdverseMediaStatus  `json:"adverseMediaStatus,omitempty" url:"adverseMediaStatus,omitempty"`
	// Timestamp of the last successful transaction of the user
	LastTransactionTimestamp *float64                                      `json:"lastTransactionTimestamp,omitempty" url:"lastTransactionTimestamp,omitempty"`
	LinkedEntities           *UserEntityLink                               `json:"linkedEntities,omitempty" url:"linkedEntities,omitempty"`
	SavedPaymentDetails      []*UserWithRulesResultSavedPaymentDetailsItem `json:"savedPaymentDetails,omitempty" url:"savedPaymentDetails,omitempty"`
	// Additional information that can be added via tags
	Tags []*UserTag `json:"tags,omitempty" url:"tags,omitempty"`
	// Uploaded user's attachment
	Attachments      []*PersonAttachment    `json:"attachments,omitempty" url:"attachments,omitempty"`
	UpdateCount      *float64               `json:"updateCount,omitempty" url:"updateCount,omitempty"`
	ExecutedRules    []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	HitRules         []*HitRulesDetails     `json:"hitRules,omitempty" url:"hitRules,omitempty"`
	RiskScoreDetails *UserRiskScoreDetails  `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserWithRulesResult) GetUserId() string {
	if u == nil {
		return ""
	}
	return u.UserId
}

func (u *UserWithRulesResult) GetCreatedTimestamp() float64 {
	if u == nil {
		return 0
	}
	return u.CreatedTimestamp
}

func (u *UserWithRulesResult) GetActivatedTimestamp() *float64 {
	if u == nil {
		return nil
	}
	return u.ActivatedTimestamp
}

func (u *UserWithRulesResult) GetUserDetails() *UserDetails {
	if u == nil {
		return nil
	}
	return u.UserDetails
}

func (u *UserWithRulesResult) GetUserStateDetails() *UserStateDetails {
	if u == nil {
		return nil
	}
	return u.UserStateDetails
}

func (u *UserWithRulesResult) GetKycStatusDetails() *KycStatusDetails {
	if u == nil {
		return nil
	}
	return u.KycStatusDetails
}

func (u *UserWithRulesResult) GetEoddDate() *float64 {
	if u == nil {
		return nil
	}
	return u.EoddDate
}

func (u *UserWithRulesResult) GetEmploymentStatus() *EmploymentStatus {
	if u == nil {
		return nil
	}
	return u.EmploymentStatus
}

func (u *UserWithRulesResult) GetOccupation() *string {
	if u == nil {
		return nil
	}
	return u.Occupation
}

func (u *UserWithRulesResult) GetLegalDocuments() []*LegalDocument {
	if u == nil {
		return nil
	}
	return u.LegalDocuments
}

func (u *UserWithRulesResult) GetContactDetails() *ContactDetails {
	if u == nil {
		return nil
	}
	return u.ContactDetails
}

func (u *UserWithRulesResult) GetEmploymentDetails() *EmploymentDetails {
	if u == nil {
		return nil
	}
	return u.EmploymentDetails
}

func (u *UserWithRulesResult) GetTransactionLimits() *TransactionLimits {
	if u == nil {
		return nil
	}
	return u.TransactionLimits
}

func (u *UserWithRulesResult) GetExpectedIncome() *ExpectedIncome {
	if u == nil {
		return nil
	}
	return u.ExpectedIncome
}

func (u *UserWithRulesResult) GetRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.RiskLevel
}

func (u *UserWithRulesResult) GetKycRiskLevel() *RiskLevel {
	if u == nil {
		return nil
	}
	return u.KycRiskLevel
}

func (u *UserWithRulesResult) GetAcquisitionChannel() *AcquisitionChannel {
	if u == nil {
		return nil
	}
	return u.AcquisitionChannel
}

func (u *UserWithRulesResult) GetReasonForAccountOpening() []string {
	if u == nil {
		return nil
	}
	return u.ReasonForAccountOpening
}

func (u *UserWithRulesResult) GetSourceOfFunds() []SourceOfFunds {
	if u == nil {
		return nil
	}
	return u.SourceOfFunds
}

func (u *UserWithRulesResult) GetUserSegment() *ConsumerUserSegment {
	if u == nil {
		return nil
	}
	return u.UserSegment
}

func (u *UserWithRulesResult) GetPepStatus() []*PepStatus {
	if u == nil {
		return nil
	}
	return u.PepStatus
}

func (u *UserWithRulesResult) GetSanctionsStatus() *SanctionsStatus {
	if u == nil {
		return nil
	}
	return u.SanctionsStatus
}

func (u *UserWithRulesResult) GetAdverseMediaStatus() *AdverseMediaStatus {
	if u == nil {
		return nil
	}
	return u.AdverseMediaStatus
}

func (u *UserWithRulesResult) GetLastTransactionTimestamp() *float64 {
	if u == nil {
		return nil
	}
	return u.LastTransactionTimestamp
}

func (u *UserWithRulesResult) GetLinkedEntities() *UserEntityLink {
	if u == nil {
		return nil
	}
	return u.LinkedEntities
}

func (u *UserWithRulesResult) GetSavedPaymentDetails() []*UserWithRulesResultSavedPaymentDetailsItem {
	if u == nil {
		return nil
	}
	return u.SavedPaymentDetails
}

func (u *UserWithRulesResult) GetTags() []*UserTag {
	if u == nil {
		return nil
	}
	return u.Tags
}

func (u *UserWithRulesResult) GetAttachments() []*PersonAttachment {
	if u == nil {
		return nil
	}
	return u.Attachments
}

func (u *UserWithRulesResult) GetUpdateCount() *float64 {
	if u == nil {
		return nil
	}
	return u.UpdateCount
}

func (u *UserWithRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if u == nil {
		return nil
	}
	return u.ExecutedRules
}

func (u *UserWithRulesResult) GetHitRules() []*HitRulesDetails {
	if u == nil {
		return nil
	}
	return u.HitRules
}

func (u *UserWithRulesResult) GetRiskScoreDetails() *UserRiskScoreDetails {
	if u == nil {
		return nil
	}
	return u.RiskScoreDetails
}

func (u *UserWithRulesResult) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserWithRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler UserWithRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserWithRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserWithRulesResult) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserWithRulesResultSavedPaymentDetailsItem struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
	Npp                *NppDetails
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromCard(value *CardDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "CARD", Card: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromGenericBankAccount(value *GenericBankAccountDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromIban(value *IbanDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "IBAN", Iban: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromAch(value *AchDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "ACH", Ach: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromSwift(value *SwiftDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "SWIFT", Swift: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromMpesa(value *MpesaDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "MPESA", Mpesa: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromUpi(value *UpiDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "UPI", Upi: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromWallet(value *WalletDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "WALLET", Wallet: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromCheck(value *CheckDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "CHECK", Check: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromCash(value *CashDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "CASH", Cash: value}
}

func NewUserWithRulesResultSavedPaymentDetailsItemFromNpp(value *NppDetails) *UserWithRulesResultSavedPaymentDetailsItem {
	return &UserWithRulesResultSavedPaymentDetailsItem{Method: "NPP", Npp: value}
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetMethod() string {
	if u == nil {
		return ""
	}
	return u.Method
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetCard() *CardDetails {
	if u == nil {
		return nil
	}
	return u.Card
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetGenericBankAccount() *GenericBankAccountDetails {
	if u == nil {
		return nil
	}
	return u.GenericBankAccount
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetIban() *IbanDetails {
	if u == nil {
		return nil
	}
	return u.Iban
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetAch() *AchDetails {
	if u == nil {
		return nil
	}
	return u.Ach
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetSwift() *SwiftDetails {
	if u == nil {
		return nil
	}
	return u.Swift
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetMpesa() *MpesaDetails {
	if u == nil {
		return nil
	}
	return u.Mpesa
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetUpi() *UpiDetails {
	if u == nil {
		return nil
	}
	return u.Upi
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetWallet() *WalletDetails {
	if u == nil {
		return nil
	}
	return u.Wallet
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetCheck() *CheckDetails {
	if u == nil {
		return nil
	}
	return u.Check
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetCash() *CashDetails {
	if u == nil {
		return nil
	}
	return u.Cash
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) GetNpp() *NppDetails {
	if u == nil {
		return nil
	}
	return u.Npp
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", u)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Cash = value
	case "NPP":
		value := new(NppDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Npp = value
	}
	return nil
}

func (u UserWithRulesResultSavedPaymentDetailsItem) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	switch u.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.Method, u)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(u.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(u.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(u.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(u.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(u.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(u.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(u.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(u.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(u.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(u.Cash, "method", "CASH")
	case "NPP":
		return internal.MarshalJSONWithExtraProperty(u.Npp, "method", "NPP")
	}
}

type UserWithRulesResultSavedPaymentDetailsItemVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
	VisitNpp(*NppDetails) error
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) Accept(visitor UserWithRulesResultSavedPaymentDetailsItemVisitor) error {
	switch u.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", u.Method, u)
	case "CARD":
		return visitor.VisitCard(u.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(u.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(u.Iban)
	case "ACH":
		return visitor.VisitAch(u.Ach)
	case "SWIFT":
		return visitor.VisitSwift(u.Swift)
	case "MPESA":
		return visitor.VisitMpesa(u.Mpesa)
	case "UPI":
		return visitor.VisitUpi(u.Upi)
	case "WALLET":
		return visitor.VisitWallet(u.Wallet)
	case "CHECK":
		return visitor.VisitCheck(u.Check)
	case "CASH":
		return visitor.VisitCash(u.Cash)
	case "NPP":
		return visitor.VisitNpp(u.Npp)
	}
}

func (u *UserWithRulesResultSavedPaymentDetailsItem) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Card != nil {
		fields = append(fields, "CARD")
	}
	if u.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if u.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if u.Ach != nil {
		fields = append(fields, "ACH")
	}
	if u.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if u.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if u.Upi != nil {
		fields = append(fields, "UPI")
	}
	if u.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if u.Check != nil {
		fields = append(fields, "CHECK")
	}
	if u.Cash != nil {
		fields = append(fields, "CASH")
	}
	if u.Npp != nil {
		fields = append(fields, "NPP")
	}
	if len(fields) == 0 {
		if u.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Method)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Method != "" {
		field := fields[0]
		if u.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Method,
				u,
			)
		}
	}
	return nil
}

// Standardized model for a Generic wallet transaction
type WalletDetails struct {
	// Wallet type if there are various types of wallets belonging to the same user. E.g. Checking, savings, vault, different currency wallets etc.
	WalletType *string `json:"walletType,omitempty" url:"walletType,omitempty"`
	// Unique ID of the wallet
	WalletId *string `json:"walletId,omitempty" url:"walletId,omitempty"`
	// Payment Channel used through wallet
	PaymentChannel *string `json:"paymentChannel,omitempty" url:"paymentChannel,omitempty"`
	// Name of the account holder for a specific wallet
	Name    *string  `json:"name,omitempty" url:"name,omitempty"`
	EmailId *EmailId `json:"emailId,omitempty" url:"emailId,omitempty"`
	// Additional information that can be added via tags
	Tags []*Tag `json:"tags,omitempty" url:"tags,omitempty"`
	// Phone number associated with the wallet, if any
	WalletPhoneNumber *string        `json:"walletPhoneNumber,omitempty" url:"walletPhoneNumber,omitempty"`
	WalletBalance     *Amount        `json:"walletBalance,omitempty" url:"walletBalance,omitempty"`
	Network           *WalletNetwork `json:"network,omitempty" url:"network,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WalletDetails) GetWalletType() *string {
	if w == nil {
		return nil
	}
	return w.WalletType
}

func (w *WalletDetails) GetWalletId() *string {
	if w == nil {
		return nil
	}
	return w.WalletId
}

func (w *WalletDetails) GetPaymentChannel() *string {
	if w == nil {
		return nil
	}
	return w.PaymentChannel
}

func (w *WalletDetails) GetName() *string {
	if w == nil {
		return nil
	}
	return w.Name
}

func (w *WalletDetails) GetEmailId() *EmailId {
	if w == nil {
		return nil
	}
	return w.EmailId
}

func (w *WalletDetails) GetTags() []*Tag {
	if w == nil {
		return nil
	}
	return w.Tags
}

func (w *WalletDetails) GetWalletPhoneNumber() *string {
	if w == nil {
		return nil
	}
	return w.WalletPhoneNumber
}

func (w *WalletDetails) GetWalletBalance() *Amount {
	if w == nil {
		return nil
	}
	return w.WalletBalance
}

func (w *WalletDetails) GetNetwork() *WalletNetwork {
	if w == nil {
		return nil
	}
	return w.Network
}

func (w *WalletDetails) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WalletDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler WalletDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WalletDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WalletDetails) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Network of the wallet
type WalletNetwork string

const (
	WalletNetworkBitcoin         WalletNetwork = "BITCOIN"
	WalletNetworkEthereum        WalletNetwork = "ETHEREUM"
	WalletNetworkPolygon         WalletNetwork = "POLYGON"
	WalletNetworkBnbSmartChain   WalletNetwork = "BNB_SMART_CHAIN"
	WalletNetworkBnbBeaconChain  WalletNetwork = "BNB_BEACON_CHAIN"
	WalletNetworkArbitrumL2      WalletNetwork = "ARBITRUM_L2"
	WalletNetworkSolana          WalletNetwork = "SOLANA"
	WalletNetworkAvalancheCChain WalletNetwork = "AVALANCHE_C_CHAIN"
	WalletNetworkTezos           WalletNetwork = "TEZOS"
	WalletNetworkViction         WalletNetwork = "VICTION"
	WalletNetworkLitecoin        WalletNetwork = "LITECOIN"
	WalletNetworkBitcoinCash     WalletNetwork = "BITCOIN_CASH"
	WalletNetworkRipple          WalletNetwork = "RIPPLE"
	WalletNetworkStellar         WalletNetwork = "STELLAR"
	WalletNetworkEosPublic       WalletNetwork = "EOS_PUBLIC"
	WalletNetworkTron            WalletNetwork = "TRON"
	WalletNetworkCardano         WalletNetwork = "CARDANO"
	WalletNetworkPolkadot        WalletNetwork = "POLKADOT"
	WalletNetworkNearProtocol    WalletNetwork = "NEAR_PROTOCOL"
	WalletNetworkCosmos          WalletNetwork = "COSMOS"
	WalletNetworkDogecoin        WalletNetwork = "DOGECOIN"
	WalletNetworkOptimismMainnet WalletNetwork = "OPTIMISM_MAINNET"
	WalletNetworkFantom          WalletNetwork = "FANTOM"
	WalletNetworkHedera          WalletNetwork = "HEDERA"
	WalletNetworkAlgorand        WalletNetwork = "ALGORAND"
	WalletNetworkCelestia        WalletNetwork = "CELESTIA"
)

func NewWalletNetworkFromString(s string) (WalletNetwork, error) {
	switch s {
	case "BITCOIN":
		return WalletNetworkBitcoin, nil
	case "ETHEREUM":
		return WalletNetworkEthereum, nil
	case "POLYGON":
		return WalletNetworkPolygon, nil
	case "BNB_SMART_CHAIN":
		return WalletNetworkBnbSmartChain, nil
	case "BNB_BEACON_CHAIN":
		return WalletNetworkBnbBeaconChain, nil
	case "ARBITRUM_L2":
		return WalletNetworkArbitrumL2, nil
	case "SOLANA":
		return WalletNetworkSolana, nil
	case "AVALANCHE_C_CHAIN":
		return WalletNetworkAvalancheCChain, nil
	case "TEZOS":
		return WalletNetworkTezos, nil
	case "VICTION":
		return WalletNetworkViction, nil
	case "LITECOIN":
		return WalletNetworkLitecoin, nil
	case "BITCOIN_CASH":
		return WalletNetworkBitcoinCash, nil
	case "RIPPLE":
		return WalletNetworkRipple, nil
	case "STELLAR":
		return WalletNetworkStellar, nil
	case "EOS_PUBLIC":
		return WalletNetworkEosPublic, nil
	case "TRON":
		return WalletNetworkTron, nil
	case "CARDANO":
		return WalletNetworkCardano, nil
	case "POLKADOT":
		return WalletNetworkPolkadot, nil
	case "NEAR_PROTOCOL":
		return WalletNetworkNearProtocol, nil
	case "COSMOS":
		return WalletNetworkCosmos, nil
	case "DOGECOIN":
		return WalletNetworkDogecoin, nil
	case "OPTIMISM_MAINNET":
		return WalletNetworkOptimismMainnet, nil
	case "FANTOM":
		return WalletNetworkFantom, nil
	case "HEDERA":
		return WalletNetworkHedera, nil
	case "ALGORAND":
		return WalletNetworkAlgorand, nil
	case "CELESTIA":
		return WalletNetworkCelestia, nil
	}
	var t WalletNetwork
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WalletNetwork) Ptr() *WalletNetwork {
	return &w
}

// Classify the method of payment as "Wallet" for WalletDetails
type WalletPaymentMethod = string

type WebhookEvent struct {
	// Unique identifier for the event
	Id string `json:"id" url:"id"`
	// Event triggered by a user or system
	TriggeredBy WebhookEventTriggeredBy `json:"triggeredBy" url:"triggeredBy"`
	// Time at which the event was created. Measured in ms since the Unix epoch.
	CreatedTimestamp float64           `json:"createdTimestamp" url:"createdTimestamp"`
	Type             WebhookEventType  `json:"type" url:"type"`
	Data             *WebhookEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookEvent) GetId() string {
	if w == nil {
		return ""
	}
	return w.Id
}

func (w *WebhookEvent) GetTriggeredBy() WebhookEventTriggeredBy {
	if w == nil {
		return ""
	}
	return w.TriggeredBy
}

func (w *WebhookEvent) GetCreatedTimestamp() float64 {
	if w == nil {
		return 0
	}
	return w.CreatedTimestamp
}

func (w *WebhookEvent) GetType() WebhookEventType {
	if w == nil {
		return ""
	}
	return w.Type
}

func (w *WebhookEvent) GetData() *WebhookEventData {
	if w == nil {
		return nil
	}
	return w.Data
}

func (w *WebhookEvent) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookEvent) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookEventBase struct {
	// Unique identifier for the event
	Id string `json:"id" url:"id"`
	// Event triggered by a user or system
	TriggeredBy WebhookEventBaseTriggeredBy `json:"triggeredBy" url:"triggeredBy"`
	// Time at which the event was created. Measured in ms since the Unix epoch.
	CreatedTimestamp float64 `json:"createdTimestamp" url:"createdTimestamp"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookEventBase) GetId() string {
	if w == nil {
		return ""
	}
	return w.Id
}

func (w *WebhookEventBase) GetTriggeredBy() WebhookEventBaseTriggeredBy {
	if w == nil {
		return ""
	}
	return w.TriggeredBy
}

func (w *WebhookEventBase) GetCreatedTimestamp() float64 {
	if w == nil {
		return 0
	}
	return w.CreatedTimestamp
}

func (w *WebhookEventBase) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookEventBase) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookEventBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookEventBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookEventBase) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Event triggered by a user or system
type WebhookEventBaseTriggeredBy string

const (
	WebhookEventBaseTriggeredByManual WebhookEventBaseTriggeredBy = "MANUAL"
	WebhookEventBaseTriggeredBySystem WebhookEventBaseTriggeredBy = "SYSTEM"
)

func NewWebhookEventBaseTriggeredByFromString(s string) (WebhookEventBaseTriggeredBy, error) {
	switch s {
	case "MANUAL":
		return WebhookEventBaseTriggeredByManual, nil
	case "SYSTEM":
		return WebhookEventBaseTriggeredBySystem, nil
	}
	var t WebhookEventBaseTriggeredBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookEventBaseTriggeredBy) Ptr() *WebhookEventBaseTriggeredBy {
	return &w
}

type WebhookEventData struct {
	UserStateDetails           *UserStateDetails
	CaseClosedDetails          *CaseClosedDetails
	CaseOpenedDetails          *CaseOpenedDetails
	AlertClosedDetails         *AlertClosedDetails
	AlertOpenedDetails         *AlertOpenedDetails
	TransactionStatusDetails   *TransactionStatusDetails
	KycStatusDetails           *KycStatusDetails
	UserTagsUpdate             *UserTagsUpdate
	CraRiskLevelUpdatedDetails *CraRiskLevelUpdatedDetails

	typ string
}

func NewWebhookEventDataFromUserStateDetails(value *UserStateDetails) *WebhookEventData {
	return &WebhookEventData{typ: "UserStateDetails", UserStateDetails: value}
}

func NewWebhookEventDataFromCaseClosedDetails(value *CaseClosedDetails) *WebhookEventData {
	return &WebhookEventData{typ: "CaseClosedDetails", CaseClosedDetails: value}
}

func NewWebhookEventDataFromCaseOpenedDetails(value *CaseOpenedDetails) *WebhookEventData {
	return &WebhookEventData{typ: "CaseOpenedDetails", CaseOpenedDetails: value}
}

func NewWebhookEventDataFromAlertClosedDetails(value *AlertClosedDetails) *WebhookEventData {
	return &WebhookEventData{typ: "AlertClosedDetails", AlertClosedDetails: value}
}

func NewWebhookEventDataFromAlertOpenedDetails(value *AlertOpenedDetails) *WebhookEventData {
	return &WebhookEventData{typ: "AlertOpenedDetails", AlertOpenedDetails: value}
}

func NewWebhookEventDataFromTransactionStatusDetails(value *TransactionStatusDetails) *WebhookEventData {
	return &WebhookEventData{typ: "TransactionStatusDetails", TransactionStatusDetails: value}
}

func NewWebhookEventDataFromKycStatusDetails(value *KycStatusDetails) *WebhookEventData {
	return &WebhookEventData{typ: "KycStatusDetails", KycStatusDetails: value}
}

func NewWebhookEventDataFromUserTagsUpdate(value *UserTagsUpdate) *WebhookEventData {
	return &WebhookEventData{typ: "UserTagsUpdate", UserTagsUpdate: value}
}

func NewWebhookEventDataFromCraRiskLevelUpdatedDetails(value *CraRiskLevelUpdatedDetails) *WebhookEventData {
	return &WebhookEventData{typ: "CraRiskLevelUpdatedDetails", CraRiskLevelUpdatedDetails: value}
}

func (w *WebhookEventData) GetUserStateDetails() *UserStateDetails {
	if w == nil {
		return nil
	}
	return w.UserStateDetails
}

func (w *WebhookEventData) GetCaseClosedDetails() *CaseClosedDetails {
	if w == nil {
		return nil
	}
	return w.CaseClosedDetails
}

func (w *WebhookEventData) GetCaseOpenedDetails() *CaseOpenedDetails {
	if w == nil {
		return nil
	}
	return w.CaseOpenedDetails
}

func (w *WebhookEventData) GetAlertClosedDetails() *AlertClosedDetails {
	if w == nil {
		return nil
	}
	return w.AlertClosedDetails
}

func (w *WebhookEventData) GetAlertOpenedDetails() *AlertOpenedDetails {
	if w == nil {
		return nil
	}
	return w.AlertOpenedDetails
}

func (w *WebhookEventData) GetTransactionStatusDetails() *TransactionStatusDetails {
	if w == nil {
		return nil
	}
	return w.TransactionStatusDetails
}

func (w *WebhookEventData) GetKycStatusDetails() *KycStatusDetails {
	if w == nil {
		return nil
	}
	return w.KycStatusDetails
}

func (w *WebhookEventData) GetUserTagsUpdate() *UserTagsUpdate {
	if w == nil {
		return nil
	}
	return w.UserTagsUpdate
}

func (w *WebhookEventData) GetCraRiskLevelUpdatedDetails() *CraRiskLevelUpdatedDetails {
	if w == nil {
		return nil
	}
	return w.CraRiskLevelUpdatedDetails
}

func (w *WebhookEventData) UnmarshalJSON(data []byte) error {
	valueUserStateDetails := new(UserStateDetails)
	if err := json.Unmarshal(data, &valueUserStateDetails); err == nil {
		w.typ = "UserStateDetails"
		w.UserStateDetails = valueUserStateDetails
		return nil
	}
	valueCaseClosedDetails := new(CaseClosedDetails)
	if err := json.Unmarshal(data, &valueCaseClosedDetails); err == nil {
		w.typ = "CaseClosedDetails"
		w.CaseClosedDetails = valueCaseClosedDetails
		return nil
	}
	valueCaseOpenedDetails := new(CaseOpenedDetails)
	if err := json.Unmarshal(data, &valueCaseOpenedDetails); err == nil {
		w.typ = "CaseOpenedDetails"
		w.CaseOpenedDetails = valueCaseOpenedDetails
		return nil
	}
	valueAlertClosedDetails := new(AlertClosedDetails)
	if err := json.Unmarshal(data, &valueAlertClosedDetails); err == nil {
		w.typ = "AlertClosedDetails"
		w.AlertClosedDetails = valueAlertClosedDetails
		return nil
	}
	valueAlertOpenedDetails := new(AlertOpenedDetails)
	if err := json.Unmarshal(data, &valueAlertOpenedDetails); err == nil {
		w.typ = "AlertOpenedDetails"
		w.AlertOpenedDetails = valueAlertOpenedDetails
		return nil
	}
	valueTransactionStatusDetails := new(TransactionStatusDetails)
	if err := json.Unmarshal(data, &valueTransactionStatusDetails); err == nil {
		w.typ = "TransactionStatusDetails"
		w.TransactionStatusDetails = valueTransactionStatusDetails
		return nil
	}
	valueKycStatusDetails := new(KycStatusDetails)
	if err := json.Unmarshal(data, &valueKycStatusDetails); err == nil {
		w.typ = "KycStatusDetails"
		w.KycStatusDetails = valueKycStatusDetails
		return nil
	}
	valueUserTagsUpdate := new(UserTagsUpdate)
	if err := json.Unmarshal(data, &valueUserTagsUpdate); err == nil {
		w.typ = "UserTagsUpdate"
		w.UserTagsUpdate = valueUserTagsUpdate
		return nil
	}
	valueCraRiskLevelUpdatedDetails := new(CraRiskLevelUpdatedDetails)
	if err := json.Unmarshal(data, &valueCraRiskLevelUpdatedDetails); err == nil {
		w.typ = "CraRiskLevelUpdatedDetails"
		w.CraRiskLevelUpdatedDetails = valueCraRiskLevelUpdatedDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, w)
}

func (w WebhookEventData) MarshalJSON() ([]byte, error) {
	if w.typ == "UserStateDetails" || w.UserStateDetails != nil {
		return json.Marshal(w.UserStateDetails)
	}
	if w.typ == "CaseClosedDetails" || w.CaseClosedDetails != nil {
		return json.Marshal(w.CaseClosedDetails)
	}
	if w.typ == "CaseOpenedDetails" || w.CaseOpenedDetails != nil {
		return json.Marshal(w.CaseOpenedDetails)
	}
	if w.typ == "AlertClosedDetails" || w.AlertClosedDetails != nil {
		return json.Marshal(w.AlertClosedDetails)
	}
	if w.typ == "AlertOpenedDetails" || w.AlertOpenedDetails != nil {
		return json.Marshal(w.AlertOpenedDetails)
	}
	if w.typ == "TransactionStatusDetails" || w.TransactionStatusDetails != nil {
		return json.Marshal(w.TransactionStatusDetails)
	}
	if w.typ == "KycStatusDetails" || w.KycStatusDetails != nil {
		return json.Marshal(w.KycStatusDetails)
	}
	if w.typ == "UserTagsUpdate" || w.UserTagsUpdate != nil {
		return json.Marshal(w.UserTagsUpdate)
	}
	if w.typ == "CraRiskLevelUpdatedDetails" || w.CraRiskLevelUpdatedDetails != nil {
		return json.Marshal(w.CraRiskLevelUpdatedDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", w)
}

type WebhookEventDataVisitor interface {
	VisitUserStateDetails(*UserStateDetails) error
	VisitCaseClosedDetails(*CaseClosedDetails) error
	VisitCaseOpenedDetails(*CaseOpenedDetails) error
	VisitAlertClosedDetails(*AlertClosedDetails) error
	VisitAlertOpenedDetails(*AlertOpenedDetails) error
	VisitTransactionStatusDetails(*TransactionStatusDetails) error
	VisitKycStatusDetails(*KycStatusDetails) error
	VisitUserTagsUpdate(*UserTagsUpdate) error
	VisitCraRiskLevelUpdatedDetails(*CraRiskLevelUpdatedDetails) error
}

func (w *WebhookEventData) Accept(visitor WebhookEventDataVisitor) error {
	if w.typ == "UserStateDetails" || w.UserStateDetails != nil {
		return visitor.VisitUserStateDetails(w.UserStateDetails)
	}
	if w.typ == "CaseClosedDetails" || w.CaseClosedDetails != nil {
		return visitor.VisitCaseClosedDetails(w.CaseClosedDetails)
	}
	if w.typ == "CaseOpenedDetails" || w.CaseOpenedDetails != nil {
		return visitor.VisitCaseOpenedDetails(w.CaseOpenedDetails)
	}
	if w.typ == "AlertClosedDetails" || w.AlertClosedDetails != nil {
		return visitor.VisitAlertClosedDetails(w.AlertClosedDetails)
	}
	if w.typ == "AlertOpenedDetails" || w.AlertOpenedDetails != nil {
		return visitor.VisitAlertOpenedDetails(w.AlertOpenedDetails)
	}
	if w.typ == "TransactionStatusDetails" || w.TransactionStatusDetails != nil {
		return visitor.VisitTransactionStatusDetails(w.TransactionStatusDetails)
	}
	if w.typ == "KycStatusDetails" || w.KycStatusDetails != nil {
		return visitor.VisitKycStatusDetails(w.KycStatusDetails)
	}
	if w.typ == "UserTagsUpdate" || w.UserTagsUpdate != nil {
		return visitor.VisitUserTagsUpdate(w.UserTagsUpdate)
	}
	if w.typ == "CraRiskLevelUpdatedDetails" || w.CraRiskLevelUpdatedDetails != nil {
		return visitor.VisitCraRiskLevelUpdatedDetails(w.CraRiskLevelUpdatedDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", w)
}

// Event triggered by a user or system
type WebhookEventTriggeredBy string

const (
	WebhookEventTriggeredByManual WebhookEventTriggeredBy = "MANUAL"
	WebhookEventTriggeredBySystem WebhookEventTriggeredBy = "SYSTEM"
)

func NewWebhookEventTriggeredByFromString(s string) (WebhookEventTriggeredBy, error) {
	switch s {
	case "MANUAL":
		return WebhookEventTriggeredByManual, nil
	case "SYSTEM":
		return WebhookEventTriggeredBySystem, nil
	}
	var t WebhookEventTriggeredBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookEventTriggeredBy) Ptr() *WebhookEventTriggeredBy {
	return &w
}

type WebhookEventType string

const (
	WebhookEventTypeCaseClosed                WebhookEventType = "CASE_CLOSED"
	WebhookEventTypeUserStateUpdated          WebhookEventType = "USER_STATE_UPDATED"
	WebhookEventTypeAlertClosed               WebhookEventType = "ALERT_CLOSED"
	WebhookEventTypeTransactionStatusUpdated  WebhookEventType = "TRANSACTION_STATUS_UPDATED"
	WebhookEventTypeKycStatusUpdated          WebhookEventType = "KYC_STATUS_UPDATED"
	WebhookEventTypeCaseOpened                WebhookEventType = "CASE_OPENED"
	WebhookEventTypeAlertOpened               WebhookEventType = "ALERT_OPENED"
	WebhookEventTypePepStatusUpdated          WebhookEventType = "PEP_STATUS_UPDATED"
	WebhookEventTypeUserTagsUpdated           WebhookEventType = "USER_TAGS_UPDATED"
	WebhookEventTypeUserTagsDeleted           WebhookEventType = "USER_TAGS_DELETED"
	WebhookEventTypeCraRiskLevelUpdated       WebhookEventType = "CRA_RISK_LEVEL_UPDATED"
	WebhookEventTypeListUpdated               WebhookEventType = "LIST_UPDATED"
	WebhookEventTypeSanctionsStatusUpdated    WebhookEventType = "SANCTIONS_STATUS_UPDATED"
	WebhookEventTypeAdverseMediaStatusUpdated WebhookEventType = "ADVERSE_MEDIA_STATUS_UPDATED"
)

func NewWebhookEventTypeFromString(s string) (WebhookEventType, error) {
	switch s {
	case "CASE_CLOSED":
		return WebhookEventTypeCaseClosed, nil
	case "USER_STATE_UPDATED":
		return WebhookEventTypeUserStateUpdated, nil
	case "ALERT_CLOSED":
		return WebhookEventTypeAlertClosed, nil
	case "TRANSACTION_STATUS_UPDATED":
		return WebhookEventTypeTransactionStatusUpdated, nil
	case "KYC_STATUS_UPDATED":
		return WebhookEventTypeKycStatusUpdated, nil
	case "CASE_OPENED":
		return WebhookEventTypeCaseOpened, nil
	case "ALERT_OPENED":
		return WebhookEventTypeAlertOpened, nil
	case "PEP_STATUS_UPDATED":
		return WebhookEventTypePepStatusUpdated, nil
	case "USER_TAGS_UPDATED":
		return WebhookEventTypeUserTagsUpdated, nil
	case "USER_TAGS_DELETED":
		return WebhookEventTypeUserTagsDeleted, nil
	case "CRA_RISK_LEVEL_UPDATED":
		return WebhookEventTypeCraRiskLevelUpdated, nil
	case "LIST_UPDATED":
		return WebhookEventTypeListUpdated, nil
	case "SANCTIONS_STATUS_UPDATED":
		return WebhookEventTypeSanctionsStatusUpdated, nil
	case "ADVERSE_MEDIA_STATUS_UPDATED":
		return WebhookEventTypeAdverseMediaStatusUpdated, nil
	}
	var t WebhookEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookEventType) Ptr() *WebhookEventType {
	return &w
}

type WebhookKycStatusDetails struct {
	Reason *string    `json:"reason,omitempty" url:"reason,omitempty"`
	Status *KycStatus `json:"status,omitempty" url:"status,omitempty"`
	UserId string     `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookKycStatusDetails) GetReason() *string {
	if w == nil {
		return nil
	}
	return w.Reason
}

func (w *WebhookKycStatusDetails) GetStatus() *KycStatus {
	if w == nil {
		return nil
	}
	return w.Status
}

func (w *WebhookKycStatusDetails) GetUserId() string {
	if w == nil {
		return ""
	}
	return w.UserId
}

func (w *WebhookKycStatusDetails) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookKycStatusDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookKycStatusDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookKycStatusDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookKycStatusDetails) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookUserStateDetails struct {
	Reason *string   `json:"reason,omitempty" url:"reason,omitempty"`
	State  UserState `json:"state" url:"state"`
	UserId string    `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookUserStateDetails) GetReason() *string {
	if w == nil {
		return nil
	}
	return w.Reason
}

func (w *WebhookUserStateDetails) GetState() UserState {
	if w == nil {
		return ""
	}
	return w.State
}

func (w *WebhookUserStateDetails) GetUserId() string {
	if w == nil {
		return ""
	}
	return w.UserId
}

func (w *WebhookUserStateDetails) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookUserStateDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookUserStateDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookUserStateDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookUserStateDetails) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
