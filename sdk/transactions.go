// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/flagright/flagright-go/sdk/internal"
)

type TransactionMonitoringResult struct {
	// Transaction ID that the results pertain to
	TransactionId    string                        `json:"transactionId" url:"transactionId"`
	Status           RuleAction                    `json:"status" url:"status"`
	RiskScoreDetails *TransactionRiskScoringResult `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`
	// Unique transaction identifier
	ExecutedRules []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	// Unique transaction identifier
	HitRules []*HitRulesDetails `json:"hitRules,omitempty" url:"hitRules,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionMonitoringResult) GetTransactionId() string {
	if t == nil {
		return ""
	}
	return t.TransactionId
}

func (t *TransactionMonitoringResult) GetStatus() RuleAction {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionMonitoringResult) GetRiskScoreDetails() *TransactionRiskScoringResult {
	if t == nil {
		return nil
	}
	return t.RiskScoreDetails
}

func (t *TransactionMonitoringResult) GetExecutedRules() []*ExecutedRulesResult {
	if t == nil {
		return nil
	}
	return t.ExecutedRules
}

func (t *TransactionMonitoringResult) GetHitRules() []*HitRulesDetails {
	if t == nil {
		return nil
	}
	return t.HitRules
}

func (t *TransactionMonitoringResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionMonitoringResult) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionMonitoringResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionMonitoringResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionMonitoringResult) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionWithRulesResult struct {
	Type TransactionType `json:"type" url:"type"`
	// Unique transaction identifier
	TransactionId string `json:"transactionId" url:"transactionId"`
	// Timestamp of when transaction took place
	Timestamp float64 `json:"timestamp" url:"timestamp"`
	// UserId for where the transaction originates from
	OriginUserId *string `json:"originUserId,omitempty" url:"originUserId,omitempty"`
	// UserId for transaction's destination. In other words, where the value is being transferred to.
	DestinationUserId        *string                   `json:"destinationUserId,omitempty" url:"destinationUserId,omitempty"`
	TransactionState         *TransactionState         `json:"transactionState,omitempty" url:"transactionState,omitempty"`
	OriginAmountDetails      *TransactionAmountDetails `json:"originAmountDetails,omitempty" url:"originAmountDetails,omitempty"`
	DestinationAmountDetails *TransactionAmountDetails `json:"destinationAmountDetails,omitempty" url:"destinationAmountDetails,omitempty"`
	// Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.
	OriginPaymentDetails      *TransactionWithRulesResultOriginPaymentDetails      `json:"originPaymentDetails,omitempty" url:"originPaymentDetails,omitempty"`
	DestinationPaymentDetails *TransactionWithRulesResultDestinationPaymentDetails `json:"destinationPaymentDetails,omitempty" url:"destinationPaymentDetails,omitempty"`
	OriginFundsInfo           *OriginFundsInfo                                     `json:"originFundsInfo,omitempty" url:"originFundsInfo,omitempty"`
	// IDs of transactions related to this transaction. Ex: refund, split bills
	RelatedTransactionIds []string `json:"relatedTransactionIds,omitempty" url:"relatedTransactionIds,omitempty"`
	// Type of produce being used by the consumer (ex wallets, payments etc)
	ProductType *string `json:"productType,omitempty" url:"productType,omitempty"`
	// Whether a promotion code was used or not the transaction
	PromotionCodeUsed *bool `json:"promotionCodeUsed,omitempty" url:"promotionCodeUsed,omitempty"`
	// Reference field for the transaction indicating the purpose of the transaction etc.
	Reference             *string     `json:"reference,omitempty" url:"reference,omitempty"`
	OriginDeviceData      *DeviceData `json:"originDeviceData,omitempty" url:"originDeviceData,omitempty"`
	DestinationDeviceData *DeviceData `json:"destinationDeviceData,omitempty" url:"destinationDeviceData,omitempty"`
	// Additional information that can be added via tags
	Tags             []*Tag                        `json:"tags,omitempty" url:"tags,omitempty"`
	ExecutedRules    []*ExecutedRulesResult        `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	HitRules         []*HitRulesDetails            `json:"hitRules,omitempty" url:"hitRules,omitempty"`
	Status           RuleAction                    `json:"status" url:"status"`
	RiskScoreDetails *TransactionRiskScoringResult `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionWithRulesResult) GetType() TransactionType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TransactionWithRulesResult) GetTransactionId() string {
	if t == nil {
		return ""
	}
	return t.TransactionId
}

func (t *TransactionWithRulesResult) GetTimestamp() float64 {
	if t == nil {
		return 0
	}
	return t.Timestamp
}

func (t *TransactionWithRulesResult) GetOriginUserId() *string {
	if t == nil {
		return nil
	}
	return t.OriginUserId
}

func (t *TransactionWithRulesResult) GetDestinationUserId() *string {
	if t == nil {
		return nil
	}
	return t.DestinationUserId
}

func (t *TransactionWithRulesResult) GetTransactionState() *TransactionState {
	if t == nil {
		return nil
	}
	return t.TransactionState
}

func (t *TransactionWithRulesResult) GetOriginAmountDetails() *TransactionAmountDetails {
	if t == nil {
		return nil
	}
	return t.OriginAmountDetails
}

func (t *TransactionWithRulesResult) GetDestinationAmountDetails() *TransactionAmountDetails {
	if t == nil {
		return nil
	}
	return t.DestinationAmountDetails
}

func (t *TransactionWithRulesResult) GetOriginPaymentDetails() *TransactionWithRulesResultOriginPaymentDetails {
	if t == nil {
		return nil
	}
	return t.OriginPaymentDetails
}

func (t *TransactionWithRulesResult) GetDestinationPaymentDetails() *TransactionWithRulesResultDestinationPaymentDetails {
	if t == nil {
		return nil
	}
	return t.DestinationPaymentDetails
}

func (t *TransactionWithRulesResult) GetOriginFundsInfo() *OriginFundsInfo {
	if t == nil {
		return nil
	}
	return t.OriginFundsInfo
}

func (t *TransactionWithRulesResult) GetRelatedTransactionIds() []string {
	if t == nil {
		return nil
	}
	return t.RelatedTransactionIds
}

func (t *TransactionWithRulesResult) GetProductType() *string {
	if t == nil {
		return nil
	}
	return t.ProductType
}

func (t *TransactionWithRulesResult) GetPromotionCodeUsed() *bool {
	if t == nil {
		return nil
	}
	return t.PromotionCodeUsed
}

func (t *TransactionWithRulesResult) GetReference() *string {
	if t == nil {
		return nil
	}
	return t.Reference
}

func (t *TransactionWithRulesResult) GetOriginDeviceData() *DeviceData {
	if t == nil {
		return nil
	}
	return t.OriginDeviceData
}

func (t *TransactionWithRulesResult) GetDestinationDeviceData() *DeviceData {
	if t == nil {
		return nil
	}
	return t.DestinationDeviceData
}

func (t *TransactionWithRulesResult) GetTags() []*Tag {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *TransactionWithRulesResult) GetExecutedRules() []*ExecutedRulesResult {
	if t == nil {
		return nil
	}
	return t.ExecutedRules
}

func (t *TransactionWithRulesResult) GetHitRules() []*HitRulesDetails {
	if t == nil {
		return nil
	}
	return t.HitRules
}

func (t *TransactionWithRulesResult) GetStatus() RuleAction {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionWithRulesResult) GetRiskScoreDetails() *TransactionRiskScoringResult {
	if t == nil {
		return nil
	}
	return t.RiskScoreDetails
}

func (t *TransactionWithRulesResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionWithRulesResult) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionWithRulesResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionWithRulesResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionWithRulesResult) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionWithRulesResultDestinationPaymentDetails struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Check              *CheckDetails
	Cash               *CashDetails
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromCard(value *CardDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "CARD", Card: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromGenericBankAccount(value *GenericBankAccountDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromIban(value *IbanDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "IBAN", Iban: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromAch(value *AchDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "ACH", Ach: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromUpi(value *UpiDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "UPI", Upi: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromWallet(value *WalletDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "WALLET", Wallet: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromSwift(value *SwiftDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "SWIFT", Swift: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromMpesa(value *MpesaDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "MPESA", Mpesa: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromCheck(value *CheckDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "CHECK", Check: value}
}

func NewTransactionWithRulesResultDestinationPaymentDetailsFromCash(value *CashDetails) *TransactionWithRulesResultDestinationPaymentDetails {
	return &TransactionWithRulesResultDestinationPaymentDetails{Method: "CASH", Cash: value}
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetCard() *CardDetails {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetGenericBankAccount() *GenericBankAccountDetails {
	if t == nil {
		return nil
	}
	return t.GenericBankAccount
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetIban() *IbanDetails {
	if t == nil {
		return nil
	}
	return t.Iban
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetAch() *AchDetails {
	if t == nil {
		return nil
	}
	return t.Ach
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetUpi() *UpiDetails {
	if t == nil {
		return nil
	}
	return t.Upi
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetWallet() *WalletDetails {
	if t == nil {
		return nil
	}
	return t.Wallet
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetSwift() *SwiftDetails {
	if t == nil {
		return nil
	}
	return t.Swift
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetMpesa() *MpesaDetails {
	if t == nil {
		return nil
	}
	return t.Mpesa
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetCheck() *CheckDetails {
	if t == nil {
		return nil
	}
	return t.Check
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) GetCash() *CashDetails {
	if t == nil {
		return nil
	}
	return t.Cash
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", t)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Ach = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Wallet = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Mpesa = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Cash = value
	}
	return nil
}

func (t TransactionWithRulesResultDestinationPaymentDetails) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(t.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(t.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(t.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(t.Ach, "method", "ACH")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(t.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(t.Wallet, "method", "WALLET")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(t.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(t.Mpesa, "method", "MPESA")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(t.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(t.Cash, "method", "CASH")
	}
}

type TransactionWithRulesResultDestinationPaymentDetailsVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) Accept(visitor TransactionWithRulesResultDestinationPaymentDetailsVisitor) error {
	switch t.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return visitor.VisitCard(t.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(t.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(t.Iban)
	case "ACH":
		return visitor.VisitAch(t.Ach)
	case "UPI":
		return visitor.VisitUpi(t.Upi)
	case "WALLET":
		return visitor.VisitWallet(t.Wallet)
	case "SWIFT":
		return visitor.VisitSwift(t.Swift)
	case "MPESA":
		return visitor.VisitMpesa(t.Mpesa)
	case "CHECK":
		return visitor.VisitCheck(t.Check)
	case "CASH":
		return visitor.VisitCash(t.Cash)
	}
}

func (t *TransactionWithRulesResultDestinationPaymentDetails) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Card != nil {
		fields = append(fields, "CARD")
	}
	if t.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if t.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if t.Ach != nil {
		fields = append(fields, "ACH")
	}
	if t.Upi != nil {
		fields = append(fields, "UPI")
	}
	if t.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if t.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if t.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if t.Check != nil {
		fields = append(fields, "CHECK")
	}
	if t.Cash != nil {
		fields = append(fields, "CASH")
	}
	if len(fields) == 0 {
		if t.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Method)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Method != "" {
		field := fields[0]
		if t.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Method,
				t,
			)
		}
	}
	return nil
}

// Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.
type TransactionWithRulesResultOriginPaymentDetails struct {
	Method             string
	Card               *CardDetails
	GenericBankAccount *GenericBankAccountDetails
	Iban               *IbanDetails
	Ach                *AchDetails
	Swift              *SwiftDetails
	Mpesa              *MpesaDetails
	Upi                *UpiDetails
	Wallet             *WalletDetails
	Check              *CheckDetails
	Cash               *CashDetails
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromCard(value *CardDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "CARD", Card: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromGenericBankAccount(value *GenericBankAccountDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "GENERIC_BANK_ACCOUNT", GenericBankAccount: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromIban(value *IbanDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "IBAN", Iban: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromAch(value *AchDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "ACH", Ach: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromSwift(value *SwiftDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "SWIFT", Swift: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromMpesa(value *MpesaDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "MPESA", Mpesa: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromUpi(value *UpiDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "UPI", Upi: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromWallet(value *WalletDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "WALLET", Wallet: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromCheck(value *CheckDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "CHECK", Check: value}
}

func NewTransactionWithRulesResultOriginPaymentDetailsFromCash(value *CashDetails) *TransactionWithRulesResultOriginPaymentDetails {
	return &TransactionWithRulesResultOriginPaymentDetails{Method: "CASH", Cash: value}
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetMethod() string {
	if t == nil {
		return ""
	}
	return t.Method
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetCard() *CardDetails {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetGenericBankAccount() *GenericBankAccountDetails {
	if t == nil {
		return nil
	}
	return t.GenericBankAccount
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetIban() *IbanDetails {
	if t == nil {
		return nil
	}
	return t.Iban
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetAch() *AchDetails {
	if t == nil {
		return nil
	}
	return t.Ach
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetSwift() *SwiftDetails {
	if t == nil {
		return nil
	}
	return t.Swift
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetMpesa() *MpesaDetails {
	if t == nil {
		return nil
	}
	return t.Mpesa
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetUpi() *UpiDetails {
	if t == nil {
		return nil
	}
	return t.Upi
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetWallet() *WalletDetails {
	if t == nil {
		return nil
	}
	return t.Wallet
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetCheck() *CheckDetails {
	if t == nil {
		return nil
	}
	return t.Check
}

func (t *TransactionWithRulesResultOriginPaymentDetails) GetCash() *CashDetails {
	if t == nil {
		return nil
	}
	return t.Cash
}

func (t *TransactionWithRulesResultOriginPaymentDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Method string `json:"method"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Method = unmarshaler.Method
	if unmarshaler.Method == "" {
		return fmt.Errorf("%T did not include discriminant method", t)
	}
	switch unmarshaler.Method {
	case "CARD":
		value := new(CardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Card = value
	case "GENERIC_BANK_ACCOUNT":
		value := new(GenericBankAccountDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.GenericBankAccount = value
	case "IBAN":
		value := new(IbanDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Iban = value
	case "ACH":
		value := new(AchDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Ach = value
	case "SWIFT":
		value := new(SwiftDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Swift = value
	case "MPESA":
		value := new(MpesaDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Mpesa = value
	case "UPI":
		value := new(UpiDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Upi = value
	case "WALLET":
		value := new(WalletDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Wallet = value
	case "CHECK":
		value := new(CheckDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Check = value
	case "CASH":
		value := new(CashDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Cash = value
	}
	return nil
}

func (t TransactionWithRulesResultOriginPaymentDetails) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	switch t.Method {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return internal.MarshalJSONWithExtraProperty(t.Card, "method", "CARD")
	case "GENERIC_BANK_ACCOUNT":
		return internal.MarshalJSONWithExtraProperty(t.GenericBankAccount, "method", "GENERIC_BANK_ACCOUNT")
	case "IBAN":
		return internal.MarshalJSONWithExtraProperty(t.Iban, "method", "IBAN")
	case "ACH":
		return internal.MarshalJSONWithExtraProperty(t.Ach, "method", "ACH")
	case "SWIFT":
		return internal.MarshalJSONWithExtraProperty(t.Swift, "method", "SWIFT")
	case "MPESA":
		return internal.MarshalJSONWithExtraProperty(t.Mpesa, "method", "MPESA")
	case "UPI":
		return internal.MarshalJSONWithExtraProperty(t.Upi, "method", "UPI")
	case "WALLET":
		return internal.MarshalJSONWithExtraProperty(t.Wallet, "method", "WALLET")
	case "CHECK":
		return internal.MarshalJSONWithExtraProperty(t.Check, "method", "CHECK")
	case "CASH":
		return internal.MarshalJSONWithExtraProperty(t.Cash, "method", "CASH")
	}
}

type TransactionWithRulesResultOriginPaymentDetailsVisitor interface {
	VisitCard(*CardDetails) error
	VisitGenericBankAccount(*GenericBankAccountDetails) error
	VisitIban(*IbanDetails) error
	VisitAch(*AchDetails) error
	VisitSwift(*SwiftDetails) error
	VisitMpesa(*MpesaDetails) error
	VisitUpi(*UpiDetails) error
	VisitWallet(*WalletDetails) error
	VisitCheck(*CheckDetails) error
	VisitCash(*CashDetails) error
}

func (t *TransactionWithRulesResultOriginPaymentDetails) Accept(visitor TransactionWithRulesResultOriginPaymentDetailsVisitor) error {
	switch t.Method {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Method, t)
	case "CARD":
		return visitor.VisitCard(t.Card)
	case "GENERIC_BANK_ACCOUNT":
		return visitor.VisitGenericBankAccount(t.GenericBankAccount)
	case "IBAN":
		return visitor.VisitIban(t.Iban)
	case "ACH":
		return visitor.VisitAch(t.Ach)
	case "SWIFT":
		return visitor.VisitSwift(t.Swift)
	case "MPESA":
		return visitor.VisitMpesa(t.Mpesa)
	case "UPI":
		return visitor.VisitUpi(t.Upi)
	case "WALLET":
		return visitor.VisitWallet(t.Wallet)
	case "CHECK":
		return visitor.VisitCheck(t.Check)
	case "CASH":
		return visitor.VisitCash(t.Cash)
	}
}

func (t *TransactionWithRulesResultOriginPaymentDetails) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Card != nil {
		fields = append(fields, "CARD")
	}
	if t.GenericBankAccount != nil {
		fields = append(fields, "GENERIC_BANK_ACCOUNT")
	}
	if t.Iban != nil {
		fields = append(fields, "IBAN")
	}
	if t.Ach != nil {
		fields = append(fields, "ACH")
	}
	if t.Swift != nil {
		fields = append(fields, "SWIFT")
	}
	if t.Mpesa != nil {
		fields = append(fields, "MPESA")
	}
	if t.Upi != nil {
		fields = append(fields, "UPI")
	}
	if t.Wallet != nil {
		fields = append(fields, "WALLET")
	}
	if t.Check != nil {
		fields = append(fields, "CHECK")
	}
	if t.Cash != nil {
		fields = append(fields, "CASH")
	}
	if len(fields) == 0 {
		if t.Method != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Method)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Method != "" {
		field := fields[0]
		if t.Method != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Method,
				t,
			)
		}
	}
	return nil
}

type TransactionsVerifyResponse struct {
	// Transaction ID that the results pertain to
	TransactionId    string                        `json:"transactionId" url:"transactionId"`
	Status           RuleAction                    `json:"status" url:"status"`
	RiskScoreDetails *TransactionRiskScoringResult `json:"riskScoreDetails,omitempty" url:"riskScoreDetails,omitempty"`
	// Unique transaction identifier
	ExecutedRules []*ExecutedRulesResult `json:"executedRules,omitempty" url:"executedRules,omitempty"`
	// Unique transaction identifier
	HitRules []*HitRulesDetails `json:"hitRules,omitempty" url:"hitRules,omitempty"`
	Message  *string            `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionsVerifyResponse) GetTransactionId() string {
	if t == nil {
		return ""
	}
	return t.TransactionId
}

func (t *TransactionsVerifyResponse) GetStatus() RuleAction {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionsVerifyResponse) GetRiskScoreDetails() *TransactionRiskScoringResult {
	if t == nil {
		return nil
	}
	return t.RiskScoreDetails
}

func (t *TransactionsVerifyResponse) GetExecutedRules() []*ExecutedRulesResult {
	if t == nil {
		return nil
	}
	return t.ExecutedRules
}

func (t *TransactionsVerifyResponse) GetHitRules() []*HitRulesDetails {
	if t == nil {
		return nil
	}
	return t.HitRules
}

func (t *TransactionsVerifyResponse) GetMessage() *string {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransactionsVerifyResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionsVerifyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionsVerifyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionsVerifyResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionsVerifyResponse) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionsVerifyRequest struct {
	// Boolean string whether Flagright should validate if provided originUserId exist. True by default
	ValidateOriginUserId *BooleanString `json:"-" url:"validateOriginUserId,omitempty"`
	// Boolean string whether Flagright should validate if provided destinationUserId exist. True by default
	ValidateDestinationUserId *BooleanString `json:"-" url:"validateDestinationUserId,omitempty"`
	// Boolean string whether Flagright should validate if provided transactionId exist. True by default
	ValidateTransactionId *BooleanString `json:"-" url:"validateTransactionId,omitempty"`
	TrsOnly               *BooleanString `json:"-" url:"_trsOnly,omitempty"`
	Body                  *Transaction   `json:"-" url:"-"`
}

func (t *TransactionsVerifyRequest) UnmarshalJSON(data []byte) error {
	body := new(Transaction)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	t.Body = body
	return nil
}

func (t *TransactionsVerifyRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.Body)
}
